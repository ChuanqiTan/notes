
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>算法导论 读书笔记 &#8212; Chuanqi 的技术文档</title>
    <link rel="stylesheet" href="../../_static/sphinx13.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="C++ 宏编程 学习笔记" href="../../language/cpp/cpp_micro.html" />
    <link rel="prev" title="操作系统概论" href="../os.html" />
    <link rel="canonical" href="http://www.sphinx-doc.org/en/master/software/introduction-to-algorithms-notes/introduction-to-algorithms-notes.html" />

    <!--<link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,700'-->
          <!--rel='stylesheet' type='text/css' />-->
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
      .injected { display:none; }
    </style>
    <script type="text/javascript">
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

  </head><body>
<div class="pageheader">
  <ul>
    <li><a href="../../index.html">博客首页</a></li>
    <li><a href="https://tanchuanqi.com" target="_blank">个人主页</a></li>
  </ul>
  <div>
    <a href="../../index.html">
      <img src="../../_static/sphinxheader.png" alt="SPHINX" />
    </a>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../../language/cpp/cpp_micro.html" title="C++ 宏编程 学习笔记"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="../os.html" title="操作系统概论"
             accesskey="P">上一页</a> |</li>
        <!--<li><a href="../../index.html">首页</a>&#160;|</li>-->
        <!--<li><a href="../../contents.html">Documentation</a> &#187;</li>-->
 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">算法导论 读书笔记</a><ul>
<li><a class="reference internal" href="#id2">第一部分：基础知识</a><ul>
<li><a class="reference internal" href="#id3">第1章：算法在计算中的作用</a></li>
<li><a class="reference internal" href="#id4">第2章：算法入门</a></li>
<li><a class="reference internal" href="#id5">第3章：函数的增长</a></li>
<li><a class="reference internal" href="#id6">第4章：递归式</a></li>
<li><a class="reference internal" href="#id7">第5章：概率分析与随机算法</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id8">第二部分：排序和顺序统计学</a><ul>
<li><a class="reference internal" href="#id9">第6章：堆排序</a></li>
<li><a class="reference internal" href="#id10">第7章：快速排序</a></li>
<li><a class="reference internal" href="#id11">第8章：线性时间排序</a></li>
<li><a class="reference internal" href="#id12">第9章：中位数和顺序统计学</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id13">第三部分：数据结构</a><ul>
<li><a class="reference internal" href="#id14">第10章：基本数据结构</a></li>
<li><a class="reference internal" href="#id15">第11章：散列表</a></li>
<li><a class="reference internal" href="#id16">第12章：二叉查找树</a></li>
<li><a class="reference internal" href="#id17">第13章：红黑树</a></li>
<li><a class="reference internal" href="#id18">第14章：数据结构的扩张</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id19">第四部分：高级设计和分析技术</a><ul>
<li><a class="reference internal" href="#id20">第15章：动态规划</a></li>
<li><a class="reference internal" href="#id21">第16章：贪心算法</a></li>
<li><a class="reference internal" href="#id22">第17章：平摊分析</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id23">第五部分：高级数据结构</a><ul>
<li><a class="reference internal" href="#b">第18章：B树</a></li>
<li><a class="reference internal" href="#id25">第19章：二项堆</a></li>
<li><a class="reference internal" href="#id26">第20章：斐波那契堆</a></li>
<li><a class="reference internal" href="#id27">第21章：用于不相交集合的数据结构</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id28">第六部分：图算法</a><ul>
<li><a class="reference internal" href="#id29">第22章：图的基本算法</a></li>
<li><a class="reference internal" href="#id30">第23章：最小生成树</a></li>
<li><a class="reference internal" href="#id31">第24章：单源最短路径</a></li>
<li><a class="reference internal" href="#id32">第25章：每对顶点间的最短路径</a></li>
<li><a class="reference internal" href="#id33">第26章：最大流</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id34">第七部分：其它的零散代码</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="../os.html"
                        title="上一章">操作系统概论</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="../../language/cpp/cpp_micro.html"
                        title="下一章">C++ 宏编程 学习笔记</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="转向" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
    <div class="documentwrapper">
      <div class="bodywrapper">
        <div class="body" role="main">
          
  <div class="section" id="id1">
<h1>算法导论 读书笔记<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="sidebar">
<p class="first sidebar-title">笔记代码开源</p>
<div class="last line-block">
<div class="line">项目地址：<a class="reference external" href="http://code.google.com/p/introduction-to-algorithms-notes/">http://code.google.com/p/introduction-to-algorithms-notes/</a></div>
</div>
</div>
<div class="section" id="id2">
<h2>第一部分：基础知识<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<div class="section" id="id3">
<h3>第1章：算法在计算中的作用<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><strong>算法</strong> 即是一系列的计算步骤，用来将一个有效的输入转换成一个有效的输出。</li>
<li>计算机的有限的资源必须被有效的利用，算法就是来解决这些问题的方法。</li>
</ul>
</div>
<div class="section" id="id4">
<h3>第2章：算法入门<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><strong>循环不变式</strong> 的三个性质：（循环不变式通常用来证明递归的正确性）<ul>
<li>初始化：它在循环的第一轮迭代开始之前，应该是正确的。</li>
<li>保持：如果在循环的某一次迭代开始之前它是正确的，那么，在下一次迭代开始之前，它也应该保持正确。</li>
<li>终止：当循环结束时，不变式给了我们一个有用的性质，它有助于表明算法是正确的。</li>
</ul>
</li>
<li>伪代码中的约定：<ul>
<li>书写上的”缩进”表示程序中的分程序（程序块）结构。</li>
<li>while,for,repeat等循环结构和if,then,else条件结构与Pascal中相同。</li>
<li>符号 “▷”表示后面部分是个注释。</li>
<li>多重赋值i←j←e是将表达式e的值赋给变量i和j；等价于j←e，再进行赋值i←j。</li>
<li>变量（如i,j和key等）是局部给定过程的。</li>
<li>数组元素是通过”数组名[下标]”这样的形式来访问的。</li>
<li>复合数据一般组织成对象，它们是由属性(attribute)和域(field)所组成的。</li>
<li>参数采用按值传递方式：被调用的过程会收到参数的一份副本。</li>
<li>布尔运算符”and”和”or”都是具有短路能力。</li>
</ul>
</li>
<li>算法分析即指对一个算法所需要的资源进行预测。</li>
<li>对于一个算法，一般只考察其最坏情况的运行时间，理由有三：<ul>
<li>一个算法的最坏情况运行时间是在任何输入下运行时间的一个上界。</li>
<li>对于某些算法来说，最坏情况出现得还是相当频繁的。</li>
<li>大致上看来，”平均情况”通常和最坏情况一样差。</li>
</ul>
</li>
<li><strong>分治策略</strong> ：将原问题划分成ｎ个规模较小而结构与原问题相似的子问题；递归地解决这些小问题，然后再合并其结果，就得到原问题的解。</li>
<li>分治模式在每一层递归上都有三个步骤：<ul>
<li>分解(Divde)：将原问题分解成一系列子问题；</li>
<li>解决(Conquer)：递归地解答各子问题。若子问题足够小，则直接求解；</li>
<li>合并(Combine)：将子问题的结果合并成原问题的解。</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id5">
<h3>第3章：函数的增长<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>对几个记号的大意：o（非渐近紧确上界） ≈ &lt;； O（渐近上界） ≈ ≤； Θ（渐近紧界）≈ =； Ω（渐近下界）≈ ≥； ω（非渐近紧确下界）≈ &nbsp;&gt;; 这里的&lt;,≤,=,≥,&gt;指的是规模上的比较，即o(g(n))的规模比g(n)小。</p>
<blockquote>
<div><div class="line-block">
<div class="line">o(g(n))={ f(n): 对任意正常数c，存在常数n0&gt;0，使对所有的n≧n0，有0≦f(n)&lt;cg(n) }</div>
<div class="line">O(g(n))={ f(n): 存在正常数c和n0，使对所有n≧n0，有0≦f(n)≦cg(n) }</div>
<div class="line">Θ(g(n))={ f(n):存在正常数c1，c2和n0，使对所有的n≧n0，有0≦c1g(n)≦f(n)≦c2g(n) }</div>
<div class="line">Ω(g(n))={ f(n):存在正常数c和n0，使对所有n≧n0，有0≦cg(n)≦f(n) }</div>
<div class="line">ω(g(n))={ f(n) 对任意正常数c，存在常数n0&gt;0，使对所有的n≧n0，有0≦cg(n)&lt;f(n) }</div>
</div>
</div></blockquote>
</div>
<div class="section" id="id6">
<h3>第4章：递归式<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<ul>
<li><p class="first"><strong>递归式</strong> 是一组等式或不等式，它所描述的函数是用在更小的输入下该函数的值来定义的。
例如Merge-Sort的最坏情况运行时间T(n)可以用以下递归式来表示：</p>
<blockquote>
<div><p>T(n) =2T(n/2) + n,   if n &gt; 11,   if n=1</p>
</div></blockquote>
</li>
<li><p class="first">解递归式的方法主要有三种：代换法、递归树方法、主方法。</p>
</li>
<li><dl class="first docutils">
<dt>代换法(Substitution method)(P38~P40)</dt>
<dd><div class="first last line-block">
<div class="line">定义：先猜测某个界的存在，再用数学归纳法去证明该猜测的正确性。</div>
<div class="line">缺点：只能用于解的形式很容易猜的情形。</div>
<div class="line">总结：这种方法需要经验的积累，可以通过转换为先前见过的类似递归式来求解。</div>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>递归树方法(Recursion-tree method)</dt>
<dd><div class="first last line-block">
<div class="line">起因：代换法有时很难得到一个正确的好的猜测值。</div>
<div class="line">用途：画出一个递归树是一种得到好猜测的直接方法。</div>
<div class="line">分析(重点)：在递归树中，每一个结点都代表递归函数调用集合中一个子问题的代价。将递归树中每一层内的代价相加得到一个每层代价的集合，再将每层的代价相加得到递归式所有层次的总代价。</div>
<div class="line">总结：递归树最适合用来产生好的猜测，然后用代换法加以验证。</div>
</div>
</dd>
</dl>
<p><strong>递归树的方法非常直观，总的代价就是把所有层次的代价相加起来得到。但是分析这个总代价的规模却不是件很容易的事情，有时需要用到很多数学的知识。</strong></p>
</li>
<li><dl class="first docutils">
<dt>主方法(Master method)</dt>
<dd><p class="first last"><strong>主方法是最好用的Cookbook方法，太神奇了，可以瞬间估计出递归算法的时间复杂度</strong> ，主方法总结了常见的情况并给出了一个公式。</p>
</dd>
</dl>
<div class="line-block">
<div class="line">优点：针对形如T(n)=aT(n’)+f(n)的递归式</div>
<div class="line">缺点：并不能解所有形如上式的递归式的解。因为主方法在第1种情况与第2种情况之间、第2种情况与第3种情况之间都存在着一条沟，所以会存在着不能适用的情况。</div>
<div class="line">直觉上：实际上主方法一直在比较f(n)与 nlogba 的规模，然后选取规模大的作为最后的递归式的规模。</div>
</div>
<p>主方法：设a&gt;=1和b&gt;=1是常数f(n)是定义在非负整数上的一个确定的非负函数。又设T(n)也是定义在非负整数上的一个非负函数，且满足递归方程Tn=aTnb+f(n)
方程Tn=aTnb+f(n)中的n/b可以是[n/b]，也可以是n/b。那么，在f(n)的三类情况下，我们有T(n)的渐近估计式：</p>
<ul class="simple">
<li>若对于某常数ε&gt;0，有 <span class="math notranslate nohighlight">\(f(n)=O(n^{log_b{a-ε}})\)</span>  ，则 <span class="math notranslate nohighlight">\(T(n)=Θ(n^{log_b{a}})\)</span> ；</li>
<li>若 <span class="math notranslate nohighlight">\(f(n)=Θ(n^{log_b{a}})\)</span>  ，则 <span class="math notranslate nohighlight">\(T(n)=Θ(n^{log_b{a}} * logn)\)</span> ；</li>
<li>若对其常数ε&gt;0，有 <span class="math notranslate nohighlight">\(f(n)=Ω(n^{log_b{a+ε}})\)</span>  且对于某常数c&gt;1和所有充分大的正整数n有af(n/b)≤cf(n)，则 <span class="math notranslate nohighlight">\(T(n)=θ(f(n))\)</span> 。</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id7">
<h3>第5章：概率分析与随机算法<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<ul>
<li><p class="first">随机算法：如果一个算法的行为不只是由输入决定，同时也由随机数生成器所产生的数值决定，则称这个算法是随机的。</p>
</li>
<li><p class="first">指示器随机变量I(A)的定义很简单</p>
<div class="math notranslate nohighlight">
\[\begin{split}I(A) =
\begin{cases}
0, &amp; 如果A不发生的话 \\
1, &amp; 如果A发生的话
\end{cases}\end{split}\]</div>
</li>
</ul>
<p>&nbsp;&nbsp;事件A对应的指示器随机变量的期望期等于事件A发生的概率。</p>
<ul>
<li><p class="first">介绍了两种 <strong>随机排列数组</strong> 的生成方法：</p>
<ul>
<li><p class="first">随机优先级法：为数组的每个元素赋一个随机的优先级，再根据这个优先级对数组中的元素进行排序。可证这样得到的数字满足随机的性质。</p>
</li>
<li><p class="first">原地交换法：依次把A[i]与A[Random(i+1, Length(A))]进行swap，得到的新数组也满足随机性:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>for i ← 1 to n
    do swap A[i] ↔ A[Random(i, Length(A))]
</pre></div>
</div>
</li>
</ul>
</li>
<li><p class="first">在真正的环境中的输入可能并不是随机的，所以我们可以采用先将输入进行随机打乱的方法来保证输入数据的随机性，这点在很多算法中得以体现，比如快排有其随机选取种子数来向输入中加入随机化的成分。</p>
</li>
<li><p class="first">生日悖论似乎是很不符合逻辑，但是经过概率分析之后的确如此。</p>
<p>生日悖论非常有意思，理解它的关键在于明白， <strong>在一个23个人的房间内，某2个人生日相同的组合其实有非常多种</strong> 的（23*222＝253种），所以有2人生日相同的概率接近50%；</p>
<dl class="docutils">
<dt>如果问题变成：你进入一个22个人的房间，发现里面有人和你生日相同的概率是多少时？，这个概率就非常的低了：</dt>
<dd><p class="first last">f=1-(364/365)^22=0.0585713252643433458470990293331</p>
</dd>
<dt>正确的解法应该是考虑k个人的房间中所有人生日都不相同的概率为：</dt>
<dd><p class="first last">f = 1 - (365/365 * 364/365 * … * (365-n+1)/365) = 0.4756953076625503</p>
</dd>
<dt>生日悖论也可以这样进行分解：</dt>
<dd><p class="first last">1号进入22人房间里有人和他生日相同的概率+2号进入21人房间里有人和他生日相同的概率+3号进入20人房间里有人和他生日相同的概率+…+22号进入1人房间里有人和他生日相同的概率+23号进入0人房间里有人和他生日相同的概率。</p>
</dd>
</dl>
<p>对生日悖论正确理解的关键就是在于明白23个人房间里相同生日的组合非常多，明白了这个组合之后就可以进行正确的分解而不是依赖于直觉进行错误的分解。</p>
</li>
<li><dl class="first docutils">
<dt>还值得提一下的是”在线雇佣问题”与”苏格拉底的择偶观”很相似。</dt>
<dd><p class="first last">先用三分之一的时间，即分出大、中、小三类，再用三分之一的时间验证自己的观点是否正确，等到最后三分之一时，选择了属于大类中的一支美丽的麦穗。</p>
</dd>
</dl>
</li>
</ul>
</div>
</div>
<div class="section" id="id8">
<h2>第二部分：排序和顺序统计学<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>这一部分将要给出几个解决以下排序问题的算法：<ul>
<li>输入：n个数的序列&lt;a1,a2, … an&gt;</li>
<li>输出：输入序列的一个重排&lt;a1’,a2’,…,an’&gt;，使a1’≦a2’≦…≦an’</li>
</ul>
</li>
<li>原地排序算法：只有线性个数的元素会被移动到集合之外的排序算法。</li>
<li>第6章介绍堆排序</li>
<li>第7章介绍快速排序</li>
<li>第8章介绍了 <strong>基于”比较”排序的算法的下界为Ω(nlgn)</strong> 。并介绍了几种不基于比较的排序方法，它们能突破Ω(nlgn)的下界。计数排序、基数排序、桶排序。</li>
<li>第9章介绍了顺序统计的概念：第i个顺序统计是集合中第i小的数。并介绍了两个算法：<ul>
<li>最坏情况为O(n^2)，但平均情况下为线性O(n)的算法</li>
<li>最坏情况下为线性O(n)的算法</li>
</ul>
</li>
</ul>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     quick_sort.cpp</span>
<span class="cm"> * @brief    归并排序</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="kt">void</span> <span class="n">_MergeSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">begin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">begin</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">middle</span> <span class="o">=</span> <span class="n">begin</span> <span class="o">+</span> <span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">begin</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
  <span class="n">_MergeSort</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">middle</span><span class="p">);</span>
  <span class="n">_MergeSort</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">out</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">middle</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">middle</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">out</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
      <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">out</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
      <span class="o">++</span><span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">middle</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">out</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">out</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">out</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">out</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
 
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">out</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">v</span><span class="p">[</span><span class="n">begin</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">MergeSort</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">_MergeSort</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">copy</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="s">&quot;  &quot;</span><span class="p">));</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">MergeSort</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
  <span class="n">copy</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="s">&quot;  &quot;</span><span class="p">));</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="mi">83</span>  <span class="mi">86</span>  <span class="mi">77</span>  <span class="mi">15</span>  <span class="mi">93</span>  <span class="mi">35</span>  <span class="mi">86</span>  <span class="mi">92</span>  <span class="mi">49</span>  <span class="mi">21</span>  <span class="mi">62</span>  <span class="mi">27</span>  <span class="mi">90</span>  <span class="mi">59</span>  <span class="mi">63</span>  <span class="mi">26</span>  <span class="mi">40</span>  <span class="mi">26</span>  <span class="mi">72</span>  <span class="mi">36</span>  <span class="mi">11</span>  <span class="mi">68</span>  <span class="mi">67</span>  <span class="mi">29</span>  <span class="mi">82</span>  <span class="mi">30</span>  <span class="mi">62</span>  <span class="mi">23</span>  <span class="mi">67</span>  <span class="mi">35</span>  
<span class="mi">11</span>  <span class="mi">15</span>  <span class="mi">21</span>  <span class="mi">23</span>  <span class="mi">26</span>  <span class="mi">26</span>  <span class="mi">27</span>  <span class="mi">29</span>  <span class="mi">30</span>  <span class="mi">35</span>  <span class="mi">35</span>  <span class="mi">36</span>  <span class="mi">40</span>  <span class="mi">49</span>  <span class="mi">59</span>  <span class="mi">62</span>  <span class="mi">62</span>  <span class="mi">63</span>  <span class="mi">67</span>  <span class="mi">67</span>  <span class="mi">68</span>  <span class="mi">72</span>  <span class="mi">77</span>  <span class="mi">82</span>  <span class="mi">83</span>  <span class="mi">86</span>  <span class="mi">86</span>  <span class="mi">90</span>  <span class="mi">92</span>  <span class="mi">93</span>  
</pre></div>
</div>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     binary_search.cpp</span>
<span class="cm"> * @brief    二分查找</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>

<span class="kt">bool</span> <span class="n">BinarySearch</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">vec</span><span class="p">,</span> <span class="kt">int</span> <span class="n">begin</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">begin</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">middle</span> <span class="o">=</span> <span class="n">begin</span> <span class="o">+</span> <span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">begin</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> 
  <span class="k">if</span> <span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span> <span class="o">==</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">[</span><span class="n">middle</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">BinarySearch</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">middle</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">BinarySearch</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="n">middle</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="n">copy</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cout</span><span class="p">,</span> <span class="s">&quot;  &quot;</span><span class="p">));</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">boolalpha</span> <span class="o">&lt;&lt;</span> <span class="n">ita</span><span class="o">::</span><span class="n">BinarySearch</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="mi">15</span>  <span class="mi">21</span>  <span class="mi">26</span>  <span class="mi">26</span>  <span class="mi">27</span>  <span class="mi">35</span>  <span class="mi">36</span>  <span class="mi">40</span>  <span class="mi">49</span>  <span class="mi">59</span>  <span class="mi">62</span>  <span class="mi">63</span>  <span class="mi">72</span>  <span class="mi">77</span>  <span class="mi">83</span>  <span class="mi">86</span>  <span class="mi">86</span>  <span class="mi">90</span>  <span class="mi">92</span>  <span class="mi">93</span>  
<span class="mf">0f</span><span class="n">alse</span>	<span class="mf">1f</span><span class="n">alse</span>	<span class="mf">2f</span><span class="n">alse</span>	<span class="mf">3f</span><span class="n">alse</span>	<span class="mf">4f</span><span class="n">alse</span>	<span class="mf">5f</span><span class="n">alse</span>	<span class="mf">6f</span><span class="n">alse</span>	<span class="mf">7f</span><span class="n">alse</span>	<span class="mf">8f</span><span class="n">alse</span>	<span class="mf">9f</span><span class="n">alse</span>	
<span class="mf">10f</span><span class="n">alse</span>	<span class="mf">11f</span><span class="n">alse</span>	<span class="mf">12f</span><span class="n">alse</span>	<span class="mf">13f</span><span class="n">alse</span>	<span class="mf">14f</span><span class="n">alse</span>	<span class="mi">15</span><span class="nb">true</span>	<span class="mf">16f</span><span class="n">alse</span>	<span class="mf">17f</span><span class="n">alse</span>	<span class="mf">18f</span><span class="n">alse</span>	<span class="mf">19f</span><span class="n">alse</span>	
<span class="mf">20f</span><span class="n">alse</span>	<span class="mi">21</span><span class="nb">true</span>	<span class="mf">22f</span><span class="n">alse</span>	<span class="mf">23f</span><span class="n">alse</span>	<span class="mf">24f</span><span class="n">alse</span>	<span class="mf">25f</span><span class="n">alse</span>	<span class="mi">26</span><span class="nb">true</span>	<span class="mi">27</span><span class="nb">true</span>	<span class="mf">28f</span><span class="n">alse</span>	<span class="mf">29f</span><span class="n">alse</span>	
<span class="mf">30f</span><span class="n">alse</span>	<span class="mf">31f</span><span class="n">alse</span>	<span class="mf">32f</span><span class="n">alse</span>	<span class="mf">33f</span><span class="n">alse</span>	<span class="mf">34f</span><span class="n">alse</span>	<span class="mi">35</span><span class="nb">true</span>	<span class="mi">36</span><span class="nb">true</span>	<span class="mf">37f</span><span class="n">alse</span>	<span class="mf">38f</span><span class="n">alse</span>	<span class="mf">39f</span><span class="n">alse</span>	
<span class="mi">40</span><span class="nb">true</span>	<span class="mf">41f</span><span class="n">alse</span>	<span class="mf">42f</span><span class="n">alse</span>	<span class="mf">43f</span><span class="n">alse</span>	<span class="mf">44f</span><span class="n">alse</span>	<span class="mf">45f</span><span class="n">alse</span>	<span class="mf">46f</span><span class="n">alse</span>	<span class="mf">47f</span><span class="n">alse</span>	<span class="mf">48f</span><span class="n">alse</span>	<span class="mi">49</span><span class="nb">true</span>	
<span class="mf">50f</span><span class="n">alse</span>	<span class="mf">51f</span><span class="n">alse</span>	<span class="mf">52f</span><span class="n">alse</span>	<span class="mf">53f</span><span class="n">alse</span>	<span class="mf">54f</span><span class="n">alse</span>	<span class="mf">55f</span><span class="n">alse</span>	<span class="mf">56f</span><span class="n">alse</span>	<span class="mf">57f</span><span class="n">alse</span>	<span class="mf">58f</span><span class="n">alse</span>	<span class="mi">59</span><span class="nb">true</span>	
<span class="mf">60f</span><span class="n">alse</span>	<span class="mf">61f</span><span class="n">alse</span>	<span class="mi">62</span><span class="nb">true</span>	<span class="mi">63</span><span class="nb">true</span>	<span class="mf">64f</span><span class="n">alse</span>	<span class="mf">65f</span><span class="n">alse</span>	<span class="mf">66f</span><span class="n">alse</span>	<span class="mf">67f</span><span class="n">alse</span>	<span class="mf">68f</span><span class="n">alse</span>	<span class="mf">69f</span><span class="n">alse</span>	
<span class="mf">70f</span><span class="n">alse</span>	<span class="mf">71f</span><span class="n">alse</span>	<span class="mi">72</span><span class="nb">true</span>	<span class="mf">73f</span><span class="n">alse</span>	<span class="mf">74f</span><span class="n">alse</span>	<span class="mf">75f</span><span class="n">alse</span>	<span class="mf">76f</span><span class="n">alse</span>	<span class="mi">77</span><span class="nb">true</span>	<span class="mf">78f</span><span class="n">alse</span>	<span class="mf">79f</span><span class="n">alse</span>	
<span class="mf">80f</span><span class="n">alse</span>	<span class="mf">81f</span><span class="n">alse</span>	<span class="mf">82f</span><span class="n">alse</span>	<span class="mi">83</span><span class="nb">true</span>	<span class="mf">84f</span><span class="n">alse</span>	<span class="mf">85f</span><span class="n">alse</span>	<span class="mi">86</span><span class="nb">true</span>	<span class="mf">87f</span><span class="n">alse</span>	<span class="mf">88f</span><span class="n">alse</span>	<span class="mf">89f</span><span class="n">alse</span>	
<span class="mi">90</span><span class="nb">true</span>	<span class="mf">91f</span><span class="n">alse</span>	<span class="mi">92</span><span class="nb">true</span>	<span class="mi">93</span><span class="nb">true</span>	<span class="mf">94f</span><span class="n">alse</span>	<span class="mf">95f</span><span class="n">alse</span>	<span class="mf">96f</span><span class="n">alse</span>	<span class="mf">97f</span><span class="n">alse</span>	<span class="mf">98f</span><span class="n">alse</span>	<span class="mf">99f</span><span class="n">alse</span>	
</pre></div>
</div>
<div class="section" id="id9">
<h3>第6章：堆排序<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li>堆排序是一个时间复杂度为O(nlgn)、原地排序算法。</li>
<li>“堆”数据结构不只在推排序时有用，还可以构成一个有效 <strong>的优先队列</strong> 。</li>
<li>堆的定义是这样的：<ul>
<li>一个堆是一颗完全二叉树</li>
<li>对于大（小）根堆，每个节点的值都比它的子节点要大（小）</li>
</ul>
</li>
<li>虽然堆排的理论效率好，但是往往一个好的快排的实现要优于堆排。</li>
<li>所以堆更常见于作为高效的优先级队列（因为它是部分排序的，对于一个优先级队列来说，部分排序已经足够了）：一个堆可以在O(lgn)的时间内，支持大小为n的集合上的任意优先队列的操作。</li>
</ul>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     heap_sort.cpp</span>
<span class="cm"> * @brief    堆的使用与堆排序</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;priority_queue.h&quot;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="c1">/// @brief 保持堆的性质</span>
<span class="c1">///</span>
<span class="c1">/// 将to_make的[0,length)元素视为一棵完全二叉树，以第i个元素为根的子树除了第i个元素之外都满足大堆的性质</span>
<span class="c1">/// 调用此方法之后，这棵完全二叉树以第i个元素为根的子树都满足大堆的性质</span>
<span class="c1">/// @param  to_make   保存数据的数组</span>
<span class="c1">/// @param  length    标记to_make的[0,length)元素视为一个完全二叉树&lt;br/&gt;</span>
<span class="c1">///                   第length个元素之后[length, n)的元素不包括在这棵完全二叉树里</span>
<span class="c1">/// @param  i         需要处理的第i个元素</span>
<span class="c1">/// @note   to_make的前length个元素并不一定是一个堆（因为它不满足大堆的性质），但可以映射为完全二叉树</span>
<span class="kt">void</span> <span class="n">MakeHeap</span><span class="p">(</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">to_make</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">the_max</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="o">&amp;&amp;</span> <span class="n">to_make</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">to_make</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">the_max</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">right</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="o">&amp;&amp;</span> <span class="n">to_make</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">to_make</span><span class="p">[</span><span class="n">the_max</span><span class="p">]</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">the_max</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span> <span class="n">the_max</span> <span class="o">!=</span> <span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span> <span class="n">to_make</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">to_make</span><span class="p">[</span><span class="n">the_max</span><span class="p">]</span> <span class="p">);</span>
    <span class="n">MakeHeap</span><span class="p">(</span> <span class="n">to_make</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">the_max</span> <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// @brief 建堆</span>
<span class="c1">///</span>
<span class="c1">/// 将to_built数组改建成一个大头堆</span>
<span class="kt">void</span> <span class="n">BuildHeap</span><span class="p">(</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">to_built</span> <span class="p">)</span> <span class="p">{</span>
  <span class="c1">//这里只需要从to_built.size() / 2 - 1开始的原因在于：</span>
  <span class="c1">//对叶子结点来说，它和它的子结点（为空）总是满足堆的定义的，所以只需要处理非叶子结点</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">to_built</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">MakeHeap</span><span class="p">(</span> <span class="n">to_built</span><span class="p">,</span> <span class="n">to_built</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">i</span> <span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">copy</span><span class="p">(</span> <span class="n">to_built</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">to_built</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">cout</span><span class="p">,</span> <span class="s">&quot;  &quot;</span> <span class="p">)</span> <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// 堆排序</span>
<span class="kt">void</span> <span class="n">HeapSort</span><span class="p">(</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">to_sort</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">BuildHeap</span><span class="p">(</span> <span class="n">to_sort</span> <span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">to_sort</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span> <span class="n">to_sort</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">to_sort</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
    <span class="n">MakeHeap</span><span class="p">(</span> <span class="n">to_sort</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">copy</span><span class="p">(</span> <span class="n">to_sort</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">to_sort</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">cout</span><span class="p">,</span> <span class="s">&quot;  &quot;</span> <span class="p">)</span> <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// 测试 堆排序与优先队列 的实现</span>
<span class="kt">int</span> <span class="n">testHeapSort</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">to_init</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">to_sort</span><span class="p">(</span> <span class="n">to_init</span><span class="p">,</span> <span class="n">to_init</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">to_init</span> <span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;原始数组，准备进行堆排序：&quot;</span><span class="p">;</span>
  <span class="n">copy</span><span class="p">(</span> <span class="n">to_sort</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">to_sort</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">cout</span><span class="p">,</span> <span class="s">&quot;  &quot;</span> <span class="p">)</span> <span class="p">);</span>
  <span class="n">HeapSort</span><span class="p">(</span> <span class="n">to_sort</span> <span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;堆排序结束：&quot;</span><span class="p">;</span>
  <span class="n">copy</span><span class="p">(</span> <span class="n">to_sort</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">to_sort</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">cout</span><span class="p">,</span> <span class="s">&quot;  &quot;</span> <span class="p">)</span> <span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;初始化一个优先队列：&quot;</span><span class="p">;</span>
  <span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">queue</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">Push</span><span class="p">(</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">1000</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="n">queue</span><span class="p">.</span><span class="n">Display</span><span class="p">();</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;开始不断的取最高优先级的任务出列：&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span> <span class="o">!</span><span class="n">queue</span><span class="p">.</span><span class="n">IsEmpty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">queue</span><span class="p">.</span><span class="n">Top</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;:</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">Pop</span><span class="p">();</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">Display</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;开始添加任务入列：&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">to_sort</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">Push</span><span class="p">(</span> <span class="n">to_sort</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
    <span class="n">queue</span><span class="p">.</span><span class="n">Display</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">testHeapSort</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>原始数组，准备进行堆排序：1  2  3  4  5  6  
1  2  6  4  5  3  
1  5  6  4  2  3  
6  5  3  4  2  1  
5  4  3  1  2  6  
4  2  3  1  5  6  
3  2  1  4  5  6  
2  1  3  4  5  6  
1  2  3  4  5  6  
堆排序结束：1  2  3  4  5  6  

初始化一个优先队列：335  421  383  649  492  777  386  915  793  886  
开始不断的取最高优先级的任务出列：
335:	383  421  386  649  492  777  886  915  793  
383:	386  421  777  649  492  793  886  915  
386:	421  492  777  649  915  793  886  
421:	492  649  777  886  915  793  
492:	649  793  777  886  915  
649:	777  793  915  886  
777:	793  886  915  
793:	886  915  
886:	915  
915:	
开始添加任务入列：
1  
1  2  
1  2  3  
1  2  3  4  
1  2  3  4  5  
1  2  3  4  5  6  
</pre></div>
</div>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     priority_queue.h</span>
<span class="cm"> * @brief    优先队列</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="c1">/// @brief 优先队列</span>
<span class="c1">///</span>
<span class="c1">/// 堆的主要应用之一：优先队列。\n</span>
<span class="c1">/// 优先级最高的元素在队首，其它的元素依赖于“比较子”满足大头堆的性质。</span>
<span class="c1">/// @param  ItemType    队列中元素的类型</span>
<span class="c1">/// @param  Comparator    用于比较队列中元素优先级的比较子</span>
<span class="c1">/// @param  ContainerType  优先队列内部所使用的容器类型</span>
<span class="c1">/// @see  void MakeHeap(vector&lt;int&gt; &amp;, size_t , size_t)</span>
<span class="c1">/// @see  void BuildHeap(vector&lt;int&gt; &amp;)</span>
<span class="c1">/// @note  优先列队中的元素一旦被加入到队列中去了就不应该再修改；对于队列中的元素应该只支持Top, Pop, Push操作</span>
<span class="k">template</span> <span class="o">&lt;</span>
<span class="k">typename</span> <span class="n">ItemType</span><span class="p">,</span>
<span class="k">typename</span> <span class="n">Comparator</span> <span class="o">=</span> <span class="n">less</span><span class="o">&lt;</span><span class="n">ItemType</span><span class="o">&gt;</span><span class="p">,</span>
<span class="k">typename</span> <span class="n">ContainerType</span> <span class="o">=</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">ItemType</span> <span class="o">&gt;&gt;</span>
<span class="k">class</span> <span class="nc">PriorityQueue</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
  <span class="k">typedef</span> <span class="n">PriorityQueue</span><span class="o">&lt;</span><span class="n">ItemType</span><span class="p">,</span> <span class="n">Comparator</span><span class="p">,</span> <span class="n">ContainerType</span><span class="o">&gt;</span>  <span class="n">_MyType</span><span class="p">;</span>
  <span class="k">typedef</span>  <span class="n">ItemType</span> <span class="o">&amp;</span>      <span class="n">Reference</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">ItemType</span> <span class="k">const</span> <span class="o">&amp;</span>  <span class="n">ConstReference</span><span class="p">;</span>

  <span class="c1">/// 创建一个空的优先队列</span>
<span class="n">PriorityQueue</span><span class="p">()</span> <span class="p">{}</span>

<span class="c1">/// 由一个区间初始化一个优先队列</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">IterType</span><span class="o">&gt;</span>
<span class="n">PriorityQueue</span><span class="p">(</span> <span class="n">IterType</span> <span class="n">begin</span><span class="p">,</span> <span class="n">IterType</span> <span class="n">end</span> <span class="p">)</span> <span class="o">:</span> <span class="n">_queue</span><span class="p">(</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">make_heap</span><span class="p">(</span> <span class="n">_queue</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">_queue</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">_comparator</span> <span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// 向队列中添加一个元素</span>
<span class="kt">void</span> <span class="n">Push</span><span class="p">(</span> <span class="n">ItemType</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">item</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">_queue</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">item</span> <span class="p">);</span>
  <span class="n">push_heap</span><span class="p">(</span> <span class="n">_queue</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">_queue</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">_comparator</span> <span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// @brief 访问const的顶端元素</span>
<span class="c1">/// @return    优先级最高的队首元素的const引用</span>
<span class="n">ConstReference</span> <span class="n">Top</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">*</span><span class="n">_queue</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">/// @brief 访问非const的顶端元素</span>
<span class="c1">///</span>
<span class="c1">/// 在标准STL的优先队列实现中有这个非const方法，但是我认为不应该有这个方法，因为这样的话可以通过这个非const引用来修改Top Item的优先级，这样整个列队就可能不再具有一致性了！\n</span>
<span class="c1">/// 如果需要改变优先级，应该使用RefreshQueue里介绍的方法</span>
<span class="c1">/// @return    优先级最高的队首元素的&lt;b&gt;非const&lt;/b&gt;引用</span>
<span class="c1">/// @see  void RefreshQueue()</span>
<span class="c1">/// @deprecated    &lt;b&gt;如果修改了队首元素的优先级，可能引起优先队列内部的不一致性&lt;/b&gt;</span>
<span class="n">Reference</span> <span class="n">Top</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">*</span><span class="n">_queue</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">/// 队首的元素出队</span>
<span class="kt">void</span> <span class="n">Pop</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">pop_heap</span><span class="p">(</span> <span class="n">_queue</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">_queue</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">_comparator</span> <span class="p">);</span>
  <span class="n">_queue</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">/// 查询队列是否为空</span>
<span class="kt">bool</span> <span class="n">IsEmpty</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">_queue</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">/// @brief 重新排序优先列队中的元素</span>
<span class="c1">///</span>
<span class="c1">/// 这个方法非常重要，有了这个方法之后优先列队就可以支持修改优先级的操作了。</span>
<span class="c1">/// @code</span>
<span class="c1">/// auto comparator = [](ItemType *item1, ItemType *item2){return item1-&gt;Priority() &lt; item2-&gt;Priority();};</span>
<span class="c1">/// PriorityQueue&lt;ItemType *, comparator&gt; q;</span>
<span class="c1">/// items[6]-&gt;SetPriority(66);    //从别处改变了某个元素的优先级</span>
<span class="c1">/// q.RefreshQueue();        //一定要记得调用RefreshQueue函数，否则在元素的优先级被外部修改之后优先队列的内部状态将不一致！    ///</span>
<span class="c1">/// @endcode</span>
<span class="kt">void</span> <span class="n">RefreshQueue</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">make_heap</span><span class="p">(</span> <span class="n">_queue</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">_queue</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">_comparator</span> <span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// 将队列中所有的元素显示的输出流中</span>
<span class="kt">void</span> <span class="n">Display</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">copy</span><span class="p">(</span> <span class="n">_queue</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">_queue</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="n">ItemType</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">cout</span><span class="p">,</span> <span class="s">&quot;  &quot;</span> <span class="p">)</span> <span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
<span class="n">ContainerType</span>     <span class="n">_queue</span><span class="p">;</span>       <span class="c1">///&lt; 容器</span>
<span class="n">Comparator</span>        <span class="n">_comparator</span><span class="p">;</span>  <span class="c1">///&lt; 比较子</span>
<span class="p">};</span>

<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="id10">
<h3>第7章：快速排序<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><strong>快速排序的最坏运行时间为O(n2)，期望运行时间为O(nlgn)</strong> ，且由于O(nlgn)中 <strong>隐含的常数因子很小</strong> ，所以快排通常是用于排序的最佳的实用选择（因为其平均性能非常好）。</li>
<li>快排真的太棒了：算法实现简单易懂、平均性能非常好、原地排序不需要额外的空间、算法简单只需要寥寥几行就搞定（比冒泡还少）。</li>
<li>对10W个随机数进行排序比较，快排平均在600MS，而堆排平均在900MS，性能差距可见一斑啊。</li>
<li>快排的平均情况运行时间与其最佳情况运行时间很接近，而不是非常接近于其最坏情况运行时间，所以一般来说快排效率是最高的，这是快排在现代得以大规模的使用的根本原因。</li>
<li><strong>快排很需要随机化技术</strong> ：因为在真正的应用时很容易出现待排序的数组其实已经是有序的情况，而这种已经有序的情况却正好又是快排算法的软肋，它在待排数组有序时的效率是最差的O(n^2)，所以很需要随机化技术！</li>
</ul>
<p><strong>快速排序的预随机化</strong> ：正如第5章所说的，由于工程中的输入可能不随机的，所以我们要将其随机化。有两种可选方案</p>
<blockquote>
<div><ul class="simple">
<li>直接对输入数据进行随机化排列</li>
<li>采用随机取样的随机化技术。随机取样的效率更高一些，所以在快速排序的随机化版本中采用随机取样的技术。</li>
</ul>
<p>方法很简单，就是在每趟sort之前随机选取一个数与最未尾的元素进行交换操作，这样简单高效的实现了随机化:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//加入随机取样的随机化技术</span>
<span class="kt">int</span> <span class="n">random_swap</span> <span class="o">=</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">EndIndex</span> <span class="o">-</span> <span class="n">BeginIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="n">BeginIndex</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">ToSort</span><span class="p">[</span><span class="n">random_swap</span><span class="p">],</span> <span class="n">ToSort</span><span class="p">[</span><span class="n">EndIndex</span><span class="p">]);</span>
</pre></div>
</div>
<p>这个技术太有用啊，因为快速排序在输入数据已经有序时的性能是最差的，但是 <strong>输入数据已经有序的情况又会经常发生，所以这个随机取样就显得异常的重要</strong> 。如果没有这个随机取样，快排绝得不到这样的应用。
在我做的实验中，对2000个有序的数据进行排序，在未没采用随机化的情况下，平均耗时860MS，而使用了随机取样之后平均耗时8MS，效率提高了100倍。</p>
</div></blockquote>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     quick_sort.cpp</span>
<span class="cm"> * @brief    快速排序</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ctime&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>

<span class="c1">/// @brief 采用了随机取样技术的快速排序</span>
<span class="c1">///</span>
<span class="c1">/// 快速排序的平均效率为O(nlgn)，最坏情况为O(n^2)</span>
<span class="kt">void</span> <span class="n">QuickSort</span><span class="p">(</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">ToSort</span><span class="p">,</span> <span class="kt">int</span> <span class="n">BeginIndex</span><span class="p">,</span> <span class="kt">int</span> <span class="n">EndIndex</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">BeginIndex</span> <span class="o">&lt;</span> <span class="n">EndIndex</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">//加入随机取样的随机化技术</span>
    <span class="c1">//一定要使用，对平均性能的提升作用太大了</span>
    <span class="kt">int</span> <span class="n">random_swap</span> <span class="o">=</span> <span class="p">(</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span> <span class="n">EndIndex</span> <span class="o">-</span> <span class="n">BeginIndex</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="o">+</span> <span class="n">BeginIndex</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span> <span class="n">ToSort</span><span class="p">[</span><span class="n">random_swap</span><span class="p">],</span> <span class="n">ToSort</span><span class="p">[</span><span class="n">EndIndex</span><span class="p">]</span> <span class="p">);</span>

    <span class="c1">//i代表的是比ToSort[EndIndex]小的元素的上界，即ToSort[BeginIndex,i)的元素值都比ToSort[EndIndex]要小</span>
    <span class="c1">//也意味着下一个比ToSort[EndIndex]小的元素要放置的位置；但是在当前可能ToSort[i] &gt;= ToSort[EndIndex]</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">BeginIndex</span><span class="p">;</span>

    <span class="c1">//j代表已经检查过的元素的上界</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">BeginIndex</span><span class="p">;</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">EndIndex</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">//找到满足比ToSort[EndIndex]小的元素</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">ToSort</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ToSort</span><span class="p">[</span><span class="n">EndIndex</span><span class="p">]</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">swap</span><span class="p">(</span> <span class="n">ToSort</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ToSort</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">);</span>  <span class="c1">//将这个比ToSort[EndIndex]小的元素移到第i个去,满足了i代表的意义</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>              <span class="c1">//由于新找到了一个比ToSort[EndIndex]小的元素,所以上界应该+1</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">swap</span><span class="p">(</span> <span class="n">ToSort</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ToSort</span><span class="p">[</span><span class="n">EndIndex</span><span class="p">]</span> <span class="p">);</span>

    <span class="n">QuickSort</span><span class="p">(</span> <span class="n">ToSort</span><span class="p">,</span> <span class="n">BeginIndex</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">);</span>
    <span class="n">QuickSort</span><span class="p">(</span> <span class="n">ToSort</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">EndIndex</span> <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>


<span class="c1">/// @brief 对模糊区间的快速排序</span>
<span class="c1">///</span>
<span class="c1">/// 问题描述： （算法导论7-6题）\n</span>
<span class="c1">/// 考虑这样的一种排序问题，即无法准确地知道待排序的各个数字到底是多少。对于其中的每个数字，</span>
<span class="c1">/// 我们只知道它落在实轴上的某个区间内。亦即，给定的是n个形如[a(i), b(i)]的闭区间（这里小括</span>
<span class="c1">/// 后起下标的作用，后同），其中a(i) &lt;= b(i)。算法的目标是对这些区间进行模糊排序</span>
<span class="c1">/// （fuzzy-sort），亦即，产生各区间的一个排列&lt;i(1), i(2), ..., i(n)&gt;，使得存在一个c(j)属于</span>
<span class="c1">/// 区间[a(i(j)), b(i(j))]，满足c(1) &lt;= c(2) &lt;= c(3) &lt;= ... &lt;= c(n)。 :\n</span>
<span class="c1">/// -   为n个区间的模糊排序设计一个算法。你的算法应该具有算法的一般结构，它可以快速排序左部</span>
<span class="c1">///    端点（即各a(i)），也要能充分利用重叠区间来改善运行时间。（随着各区间重叠得越来越多，</span>
<span class="c1">///    对各区间进行模糊排序的问题会变得越来越容易。你的算法应能充分利用这种重叠。） \n</span>
<span class="c1">/// -   证明：在一般情况下，你的算法的期望运行时间为Θ(nlgn)，但当所有的区间都重叠时，期望的</span>
<span class="c1">///    运行时间为Θ(n)（亦即，当存在一个值x，使得对所有的i，都有x∈[a(i), b(i)]）。你的算法</span>
<span class="c1">///    不应显式地检查这种情况，而是应随着重叠量的增加，性能自然地有所改善。</span>
<span class="kt">void</span> <span class="n">SmoothQuickSort</span><span class="p">(</span> <span class="n">vector</span><span class="o">&lt;</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">to_sort</span><span class="p">,</span> <span class="kt">int</span> <span class="n">begin_index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end_index</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">begin_index</span> <span class="o">&lt;</span> <span class="n">end_index</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">//取最后一个区间为主元</span>
    <span class="k">auto</span> <span class="n">principal</span> <span class="o">=</span> <span class="n">to_sort</span><span class="p">[</span><span class="n">end_index</span><span class="p">];</span>
    <span class="c1">//获取要比较的区间（除去主元）为[begin_index, end_index) =&gt; [i,j]</span>
    <span class="c1">//区间[i,j]意思是：其中所有的元素要不还未处理，要不相互重叠有至少一个重叠值，并且该值还与to_sort[end_index]重叠</span>
    <span class="c1">//即在题目中规定的语义下与to_sort[end_index]绝对相等</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">begin_index</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">end_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">begin_index</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span> <span class="c1">//k为当前正在处理的元素</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">to_sort</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">second</span> <span class="o">&lt;=</span> <span class="n">principal</span><span class="p">.</span><span class="n">first</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">//严格小于主元</span>
        <span class="n">swap</span><span class="p">(</span> <span class="n">to_sort</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">to_sort</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="p">);</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
        <span class="o">++</span><span class="n">k</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">to_sort</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">first</span> <span class="o">&gt;=</span> <span class="n">principal</span><span class="p">.</span><span class="n">second</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">//严格大于主元</span>
        <span class="n">swap</span><span class="p">(</span> <span class="n">to_sort</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">to_sort</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="p">);</span>
        <span class="o">--</span><span class="n">j</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 与主元区间有重叠，则更新主元为重叠区间（交集）</span>
        <span class="c1">// 此方法参考了 http://blogold.chinaunix.net/u/18517/showart_487873.html</span>
        <span class="c1">//</span>
        <span class="c1">// 这种想法真的好，因为缩小了主元的区间（交集），所以就可以认为以后任何与缩小之后主元有重叠</span>
        <span class="c1">// 的区间都一定与当前区间to_sort[k]重叠（因为它完全包括缩小后的主元）\n</span>
        <span class="c1">// 因此这样就可以确定最后在[i,j]中的所有元素在本题的约定下与主元绝对相等（即所有的元素相互</span>
        <span class="c1">// 重叠），所以不需要再处理。这就符合了题目中的“充分利用重叠区间来改善运行时间”\n</span>
        <span class="c1">// 如果没有这步缩小区间，就只能认为[i,j]中的元素各自与主元有重叠而无法判断为绝对相等。</span>
        <span class="c1">// @note  这里很容易弄错的一点是：区间重叠并没有传递性，重叠区间的元素并不能认为是已序的</span>
        <span class="n">principal</span><span class="p">.</span><span class="n">first</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span> <span class="n">to_sort</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">first</span><span class="p">,</span> <span class="n">principal</span><span class="p">.</span><span class="n">first</span> <span class="p">);</span>
        <span class="n">principal</span><span class="p">.</span><span class="n">second</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span> <span class="n">to_sort</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">second</span><span class="p">,</span> <span class="n">principal</span><span class="p">.</span><span class="n">second</span> <span class="p">);</span>
        <span class="o">++</span><span class="n">k</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">swap</span><span class="p">(</span> <span class="n">to_sort</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">to_sort</span><span class="p">[</span><span class="n">end_index</span><span class="p">]</span> <span class="p">);</span>

    <span class="n">SmoothQuickSort</span><span class="p">(</span> <span class="n">to_sort</span><span class="p">,</span> <span class="n">begin_index</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">);</span>
    <span class="n">SmoothQuickSort</span><span class="p">(</span> <span class="n">to_sort</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">end_index</span> <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// 测试快速排序和对模糊区间的快速排序</span>
<span class="kt">int</span> <span class="n">testQuickSort</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;==========================快速排序=============================&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ToSort</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">ToSort</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;随机填充100个数：&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">copy</span><span class="p">(</span> <span class="n">ToSort</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ToSort</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">cout</span><span class="p">,</span> <span class="s">&quot;  &quot;</span> <span class="p">)</span> <span class="p">);</span>
  <span class="n">QuickSort</span><span class="p">(</span> <span class="n">ToSort</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ToSort</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;快速排序的结果如下：&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">copy</span><span class="p">(</span> <span class="n">ToSort</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ToSort</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">cout</span><span class="p">,</span> <span class="s">&quot;  &quot;</span> <span class="p">)</span> <span class="p">);</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;======================模糊区间的快速排序=========================&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">to_sort_smooth</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span><span class="p">;</span>
    <span class="n">to_sort_smooth</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">make_pair</span><span class="p">(</span> <span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span> <span class="p">)</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="n">SmoothQuickSort</span><span class="p">(</span> <span class="n">to_sort_smooth</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">to_sort_smooth</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">);</span>
  <span class="n">for_each</span><span class="p">(</span> <span class="n">to_sort_smooth</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">to_sort_smooth</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">p</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s"> --&gt; </span><span class="se">\t</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span> <span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">testQuickSort</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>==========================快速排序=============================
随机填充100个数：
83  86  77  15  93  35  86  92  49  21  62  27  90  59  63  26  40  26  72  36  
快速排序的结果如下：
15  21  26  26  27  35  36  40  49  59  62  63  72  77  83  86  86  90  92  93  
======================模糊区间的快速排序=========================
24	 --&gt; 	39
56	 --&gt; 	67
58	 --&gt; 	127
42	 --&gt; 	71
70	 --&gt; 	83
19	 --&gt; 	103
37	 --&gt; 	135
67	 --&gt; 	160
26	 --&gt; 	117
73	 --&gt; 	94
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h3>第8章：线性时间排序<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li><dl class="first docutils">
<dt>任何 <strong>比较的排序在最坏的情况下都要用Ω(nlgn)次</strong> 比较来进行排序，所以合并排序和堆排序是渐近最优的。</dt>
<dd>注意的是： <em>快排不是渐近最优的，因为它在最坏的情况下是O(n2)</em> 。</dd>
</dl>
</li>
<li>三种以线性时间运行的排序算法：计数排序、基数排序和桶排序。 <strong>它们都是非比较的</strong></li>
<li>计数排序<ul>
<li>步骤：统计每一种元素的出现次数，然后再从有序的按出现次数输出，所得的结果就的原数列的有序排列。</li>
<li>计数排序的一个重要性就是它是稳定的排序算法，这个稳定性是基数排序的基石。</li>
<li>计数排序的想法真的很简单、高效、可靠</li>
<li>缺点在于：<ul>
<li>需要很多额外的空间（当前类型的值的范围）</li>
<li>只能对离散的类型有效比如int（double就不行了）</li>
<li>基于假设：输入是小范围内的整数构成的。</li>
</ul>
</li>
</ul>
</li>
<li>基数排序<ul>
<li>步骤：按低纬度到高纬度的把元素放到桶中，再收集起来，完成最高纬度之后，收集的结果就已经是有序的了。</li>
<li>基数排序时对每一维进行调用子排序算法时要求这个子排序算法必须是稳定的。</li>
<li><dl class="first docutils">
<dt>基数排序与直觉相反：它是按照从底位到高位的顺序排序的。</dt>
<dd>我觉得原因在于：高有效位对底有效位有着决定性的作用；后面的排序对前面的排序起决定性的作用。</dd>
</dl>
</li>
<li>基于假设：位数有限，并且也是离散的值分布。</li>
</ul>
</li>
<li>桶排序<ul>
<li>桶排序也 <strong>只是期望运行时间能达到线性</strong> ，对于最坏的情况，它的运行时间取决于它内部使用的子排序算法的运行时间，一般为O(nlgn)。</li>
<li>桶排序基于假设：输入的的元素均匀的分布在区间[0, 1]上。</li>
<li>感觉桶排没有什么大的实现价值，因为它限定了输入的区间，还要求最好是均匀分布，它的最坏情况并不好。</li>
</ul>
</li>
<li>所有的 <strong>线性时间内的排序算法，都作出了一定的假设，是建立在一定的假设基础上</strong> 的。</li>
</ul>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     linear_sort.cpp</span>
<span class="cm"> * @brief    线性时间排序算法</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="c1">/// @brief 计数排序</span>
<span class="c1">///</span>
<span class="c1">/// 计数排序的思想是：假定所有的元素都处于[0, k_max_size)区间，然后在n的时间内统计所有的元素的个数。\n</span>
<span class="c1">/// 有了这些元素的个数信息之后，就可以重构出它们的排序结果了。\n</span>
<span class="c1">/// 计数排序的特征：</span>
<span class="c1">/// - 计数排序的一个重要性就是它是稳定的排序算法，这个稳定性是基数排序的基石。</span>
<span class="c1">/// - 计数排序的想法真的很简单、高效、可靠</span>
<span class="c1">/// - 缺点在于：</span>
<span class="c1">///    -# 需要很多额外的空间（当前类型的值的范围）</span>
<span class="c1">///    -# 只能对离散的类型有效比如int（double就不行了）</span>
<span class="c1">///    -# 基于假设：输入是小范围内的整数构成的。</span>
<span class="kt">void</span> <span class="n">CountingSort</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="k">const</span> <span class="n">k_max_size</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>    <span class="c1">//待排序的所有元素都必须位于区间[0, k_max_size)</span>
  <span class="c1">//初始化区间为[0, k_max_size)之间的随机数作为输入</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">15</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">k_max_size</span> <span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">//进行计数 c[i] = j代表着i在输入数据中出现了j次</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">(</span> <span class="n">k_max_size</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="kt">int</span> <span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span> <span class="p">);</span>

  <span class="c1">//对所有的计数从依次总结出最后的排序，并没有使用原书上的方法</span>
  <span class="c1">//比书上的算法更直接，将二步合成了一步，效率上是同样的渐近时间复杂度的，似乎更好点。</span>
  <span class="n">v</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k_max_size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="o">++</span><span class="n">k</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">i</span> <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">copy</span><span class="p">(</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">,</span> <span class="s">&quot;  &quot;</span> <span class="p">)</span> <span class="p">);</span>
<span class="p">}</span>


<span class="c1">/// @brief 基数排序</span>
<span class="c1">///</span>
<span class="c1">/// 基数排序就是按照从底位到高位的顺序依次选取待排序的元素，然后在稳定的前提下放入下一次排序之中，和放扑克牌很相似。</span>
<span class="c1">/// - 基数排序时对每一维进行调用子排序算法时要求这个子排序算法必须是稳定的。</span>
<span class="c1">/// - 基数排序与直觉相反：它是按照从底位到高位的顺序排序的。\n</span>
<span class="c1">///   我觉得原因在于：高有效位对底有效位有着决定性的作用。</span>
<span class="c1">/// @note  基数排序内部所使用的子排序算法必须是稳定的</span>
<span class="kt">void</span> <span class="n">RadixSort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">max_dim</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">dim</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">++</span><span class="n">dim</span><span class="p">;</span>
      <span class="n">j</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">max_dim</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">max_dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;max dim = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">max_dim</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="c1">//得到一个数的某一维的值</span>
  <span class="c1">//eg:  GetDim(987, 0) = 7</span>
  <span class="c1">//     GetDim(987, 1) = 8</span>
  <span class="c1">//     GetDim(987, 2) = 9</span>
  <span class="k">auto</span> <span class="n">GetDim</span> <span class="o">=</span> <span class="p">[](</span> <span class="kt">int</span> <span class="n">number</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">number</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">number</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kt">int</span> <span class="n">dim</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">dim</span> <span class="o">&lt;</span> <span class="n">max_dim</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">barrel</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">barrel</span><span class="p">[</span><span class="n">GetDim</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dim</span><span class="p">)].</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="n">v</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">barrel</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">v</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">barrel</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">begin</span><span class="p">(),</span> <span class="n">barrel</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="o">++</span><span class="n">dim</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// 基数排序算法的初始化和调用</span>
<span class="kt">void</span> <span class="n">RadixSortCaller</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">//初始化[0,999]之间的随机数作为输入</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">,</span> <span class="s">&quot;  &quot;</span> <span class="p">)</span> <span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="n">RadixSort</span><span class="p">(</span> <span class="n">v</span> <span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">,</span> <span class="s">&quot;  &quot;</span> <span class="p">)</span> <span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// @brief 桶排序</span>
<span class="c1">///</span>
<span class="c1">/// 桶排序的算法步骤：</span>
<span class="c1">/// - 构建桶，并将所有的元素放入到相应的桶中去；\n</span>
<span class="c1">///    比如（0.21  0.45  0.24  0.72  0.7  0.29  0.77  0.73  0.97  0.12）根据它们的小数点后第1位，放入到相应的10个桶中去</span>
<span class="c1">/// - 对每一个桶里的元素进行排序\n</span>
<span class="c1">///   比如对于桶2，其中有2个元素0.21, 0,24。 对它们进行好内部排序。</span>
<span class="c1">/// - 依次把每个桶中的元素提取出来并组合在一起\n</span>
<span class="c1">///   得到最后的结果（0.12  0.21  0.24  0.29  0.45  0.7  0.72  0.73  0.77  0.97）</span>
<span class="c1">///</span>
<span class="c1">/// 桶排序也只是期望运行时间能达到线性，对于最坏的情况，它的运行时间取决于它内部使用的子排序算法的运行时间，一般为O(nlgn)。</span>
<span class="c1">/// - 桶排序基于假设：输入的的元素均匀的分布在区间[0, 1]上。</span>
<span class="c1">/// - 感觉桶排没有什么大的实现价值，因为它限定了输入的区间，还要求最好是均匀分布，它的最坏情况并不好。</span>
<span class="kt">void</span> <span class="n">BucketSort</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">//初始化[0,1)之间的随机数</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="p">(</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span> <span class="p">)</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mf">100.0</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="n">copy</span><span class="p">(</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">cout</span><span class="p">,</span> <span class="s">&quot;  &quot;</span> <span class="p">)</span> <span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="c1">//构建桶，并将所有的元素放入到相应的桶中去</span>
  <span class="n">vector</span><span class="o">&lt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">bucket</span><span class="p">(</span> <span class="mi">10</span> <span class="p">);</span>  <span class="c1">//10个桶</span>
  <span class="n">for_each</span><span class="p">(</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="kt">double</span> <span class="n">d</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">bucket</span><span class="p">[</span><span class="n">d</span> <span class="o">*</span> <span class="mi">10</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span> <span class="n">d</span> <span class="p">);</span>
  <span class="p">}</span> <span class="p">);</span>

  <span class="c1">//对每一个桶里的元素进行排序</span>
  <span class="n">for_each</span><span class="p">(</span> <span class="n">bucket</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">bucket</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">sub_v</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">sort</span><span class="p">(</span> <span class="n">sub_v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">sub_v</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span>
  <span class="p">}</span> <span class="p">);</span>

  <span class="c1">//依次把每个桶中的元素提取出来并组合在一起</span>
  <span class="n">v</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
  <span class="n">for_each</span><span class="p">(</span> <span class="n">bucket</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">bucket</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">sub_v</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">v</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">sub_v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">sub_v</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span>
  <span class="p">}</span> <span class="p">);</span>

  <span class="n">copy</span><span class="p">(</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">cout</span><span class="p">,</span> <span class="s">&quot;  &quot;</span> <span class="p">)</span> <span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// 测试计数排序 基数排序 桶排序</span>
<span class="kt">int</span> <span class="n">testLinearSort</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;===========开始计数排序===========&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">CountingSort</span><span class="p">();</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;===========开始基数排序===========&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">RadixSortCaller</span><span class="p">();</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;===========开始桶排序===========&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">BucketSort</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">testLinearSort</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>
===========开始计数排序===========
15  21  27  35  49  59  62  63  77  83  86  86  90  92  93  
===========开始基数排序===========
26  40  26  72  36  11  68  67  29  82  
max dim = 2
11  26  26  29  36  40  67  68  72  82  
===========开始桶排序===========
0.3  0.62  0.23  0.67  0.35  0.29  0.02  0.22  0.58  0.69  
0.02  0.22  0.23  0.29  0.3  0.35  0.58  0.62  0.67  0.69  
</pre></div>
</div>
</div>
<div class="section" id="id12">
<h3>第9章：中位数和顺序统计学<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h3>
<ul>
<li><dl class="first docutils">
<dt>第i个顺序统计量是该集合中第i小的元素。</dt>
<dd><p class="first last">最小值是第1个顺序统计量(i=1)最大值是第n个顺序统计量(i=n)</p>
</dd>
</dl>
</li>
<li><p class="first">中位数是它所在集合的”中点元素”</p>
</li>
<li><dl class="first docutils">
<dt><strong>同时找出最大最小值的算法</strong> ，一般人可能以为需要2n次比较， <strong>实际上只需要至多3n/2次比较</strong> ，使用的技巧是：</dt>
<dd><p class="first last">将一对元素比较，然后把较大者于max比较，较小者与min比较，这样就只需要3n/2次比较就能得到最后的结果。</p>
</dd>
</dl>
</li>
<li><p class="first"><strong>以期望线性时间选择顺序统计量的方法是以快速排序为模型</strong></p>
<p>如同在快速排序中一样，此算法的思想也是对输入数组进行递归划分。 <em>但和快速排序不同的是，快速排序会递归处理划分的两边，而randomized-select只处理划分的一边</em> （因为完全没有必要处理另外一边嘛）。
并由此将期望的运行时间由O(nlgn)下降到了O(n)，但是最坏情况依然是O(n<sup>2</sup> )，虽然这样的最坏情况几乎不会发生，特别是加上随机取样技术之后。</p>
<p><strong>这就是顺序统计量算法能够如此高效的核心原因所在！</strong> 我觉得 <code class="docutils literal notranslate"><span class="pre">C++</span> <span class="pre">STL中的nth_element</span></code> 用的可能就是这个算法，所以它的效率应该很高。</p>
</li>
<li><dl class="first docutils">
<dt>最坏线性时间选择顺序统计量的方法的核心在于：要保证对数组的划分是一个好的划分。</dt>
<dd><p class="first last">于是方法使用了一个很奇怪的取主元的方法（而不是直接取最后一个或者随机），虽然看起来很奇怪，但是该方法被这样的提出就肯定有它的理论基础的。
不过这种取巧的方法不太值得去写一遍，而且明显写出来也很容易的（仅仅相差一个奇怪的取主元方法，这一节的关键内容都在于证明这个方法的最坏线性时间上了），没有什么新技术和新想法。</p>
</dd>
</dl>
</li>
</ul>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     nth_element.cpp</span>
<span class="cm"> * @brief    中位数和顺序统计学</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="p">{</span>

<span class="c1">/// 寻找v数组的子集[begin_index, end_index]中的第i个元素顺序统计量，0 &lt;= i &lt; end_index-begin_index</span>
<span class="kt">int</span> <span class="n">_NthElement</span><span class="p">(</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="k">const</span> <span class="n">begin_index</span><span class="p">,</span> <span class="kt">int</span> <span class="k">const</span> <span class="n">end_index</span><span class="p">,</span> <span class="kt">int</span> <span class="k">const</span> <span class="n">n</span> <span class="p">)</span> <span class="p">{</span>
  <span class="c1">//这个判断纯粹只是一个加速return的技巧，没有这个判断算法也是正确的！</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">begin_index</span> <span class="o">==</span> <span class="n">end_index</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">v</span><span class="p">[</span><span class="n">begin_index</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">//随机取样</span>
  <span class="kt">int</span> <span class="n">swap_index</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span> <span class="n">end_index</span> <span class="o">-</span> <span class="n">begin_index</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="o">+</span> <span class="n">begin_index</span><span class="p">;</span>
  <span class="n">swap</span><span class="p">(</span> <span class="n">v</span><span class="p">[</span><span class="n">swap_index</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">end_index</span><span class="p">]</span> <span class="p">);</span>

  <span class="c1">//根据最后一个主元进行分割成两部分</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">begin_index</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">begin_index</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">end_index</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">[</span><span class="n">end_index</span><span class="p">]</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">swap</span><span class="p">(</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">swap</span><span class="p">(</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">end_index</span><span class="p">]</span> <span class="p">);</span>

  <span class="c1">//主元是本区间的第k个元素顺序统计量，0&lt;=k&lt;size</span>
  <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">begin_index</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span> <span class="n">n</span> <span class="o">==</span> <span class="n">k</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">//找到了</span>
    <span class="k">return</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">//在左区间继续找</span>
    <span class="k">return</span> <span class="n">_NthElement</span><span class="p">(</span> <span class="n">v</span><span class="p">,</span> <span class="n">begin_index</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">//在右区间继续找：由于主元是第k个元素顺序统计量(0&lt;=k&lt;size)，所以小于等于主元的元素有k+1个（包括主元），因此寻找右区间的第n-(k+1)个顺序统计量</span>
    <span class="k">return</span> <span class="n">_NthElement</span><span class="p">(</span> <span class="n">v</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end_index</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="p">}</span>

<span class="c1">/// @brief 寻找v数组中的第i个顺序统计量，0&lt;=i&lt;size</span>
<span class="c1">///</span>
<span class="c1">/// 以快速排序为模型。如同在快速排序中一样，此算法的思想也是</span>
<span class="c1">///  对输入数组进行递归划分。但和快速排序不同的是，快速排序会递归处理划分的两边，而randomized-select</span>
<span class="c1">///  只处理划分的一边。并由此将期望的运行时间由O(nlgn)下降到了O(n)。</span>
<span class="c1">/// @param  v  要进行查找操作的集合</span>
<span class="c1">/// @param  i  查找集合中的第i个顺序统计量</span>
<span class="c1">/// @return    集合中的第i个顺序统计量</span>
<span class="c1">/// @see  int _NthElement(vector&lt;int&gt; &amp;v, int const begin_index, int const end_index, int const n)</span>
<span class="kt">int</span> <span class="n">NthElement</span><span class="p">(</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="k">const</span> <span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">_NthElement</span><span class="p">(</span> <span class="n">v</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// 中位数和顺序统计学</span>
<span class="kt">int</span> <span class="n">testNthElement</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="p">(</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">1000</span> <span class="p">)</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="n">copy</span><span class="p">(</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">cout</span><span class="p">,</span> <span class="s">&quot;  &quot;</span> <span class="p">)</span> <span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;th element is:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">NthElement</span><span class="p">(</span> <span class="n">v</span><span class="p">,</span> <span class="n">i</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">testNthElement</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="mi">383</span>  <span class="mi">886</span>  <span class="mi">777</span>  <span class="mi">915</span>  <span class="mi">793</span>  <span class="mi">335</span>  <span class="mi">386</span>  <span class="mi">492</span>  <span class="mi">649</span>  <span class="mi">421</span>  
<span class="mi">0</span><span class="n">th</span> <span class="n">element</span> <span class="nl">is</span><span class="p">:</span><span class="mi">335</span>
<span class="mi">1</span><span class="n">th</span> <span class="n">element</span> <span class="nl">is</span><span class="p">:</span><span class="mi">383</span>
<span class="mi">2</span><span class="n">th</span> <span class="n">element</span> <span class="nl">is</span><span class="p">:</span><span class="mi">386</span>
<span class="mi">3</span><span class="n">th</span> <span class="n">element</span> <span class="nl">is</span><span class="p">:</span><span class="mi">421</span>
<span class="mi">4</span><span class="n">th</span> <span class="n">element</span> <span class="nl">is</span><span class="p">:</span><span class="mi">492</span>
<span class="mi">5</span><span class="n">th</span> <span class="n">element</span> <span class="nl">is</span><span class="p">:</span><span class="mi">649</span>
<span class="mi">6</span><span class="n">th</span> <span class="n">element</span> <span class="nl">is</span><span class="p">:</span><span class="mi">777</span>
<span class="mi">7</span><span class="n">th</span> <span class="n">element</span> <span class="nl">is</span><span class="p">:</span><span class="mi">793</span>
<span class="mi">8</span><span class="n">th</span> <span class="n">element</span> <span class="nl">is</span><span class="p">:</span><span class="mi">886</span>
<span class="mi">9</span><span class="n">th</span> <span class="n">element</span> <span class="nl">is</span><span class="p">:</span><span class="mi">915</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id13">
<h2>第三部分：数据结构<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
<div class="section" id="id14">
<h3>第10章：基本数据结构<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h3>
<p>没发现有什么值得看的，貌似就是下面这些基本的知识，这些知识都不知道就没法混啦。</p>
<ul class="simple">
<li>栈</li>
<li>队列</li>
<li>链表</li>
<li>树的”左孩子、右兄弟”表示法</li>
</ul>
</div>
<div class="section" id="id15">
<h3>第11章：散列表<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h3>
<ul>
<li><dl class="first docutils">
<dt>在散列表中查找一个元素的时间与在链表中查找一个元素的时候相同，在 <strong>最坏情况为O(n)，但期望时间为O(1)</strong></dt>
<dd><p class="first last">在实践中，散列表的效率是很高的，一般可认为是O(1)</p>
</dd>
</dl>
</li>
<li><p class="first">散列是一种极其有效和实用的技术：基本的字典操作只需要O(1)的平均时间。
而且当待排序的关键字的集合是静态的（即当关键字集合一旦存入后不需要再改变），”完全散列”能够在O(1)的最坏时间内支持查找操作</p>
</li>
<li><p class="first">在众多的简单的解决碰撞的方法中，我觉得比较好的是通过链表法解决碰撞，虽然这个方法的理论最坏效率为O(n)，但是在平均情况下，它的性能也是非常好的，实现简单又高效。</p>
</li>
<li><p class="first"><strong>装载因子</strong> ：给定一个能存放n个元素的、具有m个槽位的散列表T，定义T的装载因子α=n/m，即一个链中平均存储的元素数。</p>
</li>
<li><p class="first">多数的散列函数都假定关键字域为自然数集N，如果所给关键字不是自然数，则必须有一种方法来将它们解释为自然数。</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>除法散列法：h(k)= k mod m</dt>
<dd>一般选取m的值为与2的整数幂不大接近的质数</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>乘法散列法：h(k)= m(kA mod 1)</dt>
<dd>构造散列函数的乘法方法包含两个步骤：首先用关键字剩上常数A(0&lt;A&lt;1)，并抽取kA的小数部分；然后用m剩以这个值，再取结果的底。
Knuth认为A≈5-12是一个比较理想的值。</dd>
</dl>
</li>
<li>全域散列：全域散列的基本思想是 <strong>在执行开始时，就从一族仔细设计的函数中，随机地选择一个作为散列函数</strong><ul>
<li>首先：全域散列表是一种使用”键接法”来解决碰撞问题的散列表方法。</li>
<li>随机化保证了对于任何输入，算法都具有较好的平均性能。</li>
<li>全域的散列函数组：设H为一组散列函数，它将给定的关键字域U映射到{0,1,…,m-1}中，这样的一个函数组称为是全域的。如果从H中随机地选择一个散列函数，当关键字K≠J时，两者发生碰撞的概率不大于1/m。</li>
<li><dl class="first docutils">
<dt>常用的一个全域散列函数类：（ <strong>数论的知识可以证明这个函数类满足全域散列函数的性质，我只要相信这个常用的函数可以被证明就可以了！</strong> ）</dt>
<dd>首先选择一个足够大的质数p ，使得每一个可能的关键字k 都落到0 到p-1 的范围内，包括首尾的0 和p-1。
这里我们假设全域是0 – 15，p 为17。设集合Zp 为{0, 1, 2, …, p-1}，集合Zp* 为{1, 2, 3, …, p}。
由于p 是质数，我们可以定义散列函数h(a, b, k) = ((a*k + b) mod p) mod m。其中a 属于Zp，b 属于Zp*。
由所有这样的a 和b 构成的散列函数，组成了函数簇。即全域散列。</dd>
</dl>
</li>
<li>明白这个散列函数的选取是在 <strong>执行开始</strong> 随机的选取一个是很重要的，要不然就会不明白到时候怎么进行查找
这里所谓的随机性应该这样理解：对于某一个散列表来说，它在初始化时已经把a,b固定了，但是对于一个还未初始化的全域散列表来说，a,b是随机选取的。</li>
</ul>
</li>
</ul>
</li>
<li><p class="first">开放寻址法：所有的元素都放在散列表里</p>
<blockquote>
<div><ol class="arabic simple">
<li>开放寻址法的好处就在于它根本不用指针，而是计算出要存取的各个槽。这样一来，由于不用存储指针就节省了空间，从而可以用同样的空间来提供更多的槽，其潜在的效果就是可以减少碰撞，提高查找速度。</li>
<li><strong>感觉上开放寻址法很像一个启发式的搜索</strong> ，它的最坏性能也是O(n)，只不过散列函数为它提供了启发信息从而使得一般的平均性能会很好。</li>
<li>在开放寻址法中，对散列元素的删除操作执行起来比较困难，因为删除操作会影响查找操作。解决办法是在槽里的值被删除后置一个特定的值DELETED，而不是删除后不管，查找的时候处理一下就可以了</li>
<li>线性探查、二次探查和双重散列都是对最基本的数组法的改进，虽然它们很漂亮，但是思想上并没有太大的革新，看起来很容易懂的。</li>
<li>双重散钱是用于开放寻址的最好方法之一，因为它所产生的排列具有随机选择的排列的许多特性。</li>
<li>所有的改进的散列方法目的只有一个： <strong>都是在尽力地增加散列结果的随机性</strong> ！</li>
</ol>
</div></blockquote>
</li>
<li><dl class="first docutils">
<dt><strong>完全散列</strong> ：如果某一种散列技术在进行查找时，其最坏情况内存访问次数为O(1)的话，则称其为完全散列。</dt>
<dd><div class="first last line-block">
<div class="line">书上利用了一种 <strong>两级的散列方案，每一级都采用全域散列</strong> 。</div>
<div class="line">通常利用一种两级的散列方案，每一级上都采用全域散列。为了 <strong>确保在第二级上不出现碰撞</strong> ，需要让第二级散列表Sj的大小mj为散列到槽j中的关键字数nj的平方。</div>
<div class="line">如果利用从某一全域散列函数类中随机选出的散列函数h，来将n个关键字存储到一个大小为m=n的散列表中，并将每个二次散列表的大小置为mj=nj<sup>2</sup> (j=0, 1, …, m-1)，则在一个完全散列方案中，存储所有二次散列表所需的存储总量的期望值小于2n。</div>
<div class="line">完全散列的关键在于：二次散列表中要求没有碰撞！这是通过确保槽的个数是关键字的个数的平方来实现的，第一次散列时要求的槽数为关键字的个数，第二次散列时要求的槽数为当前槽中被分配的关键字的个数的平方。</div>
<div class="line">完全散列的关键在于是对：静态的关键字集合，关键字集合不但不能增加，甚至减少都不行，因为二级散列的槽的个数为散列到该二级散列所在的一级槽中元素的个数的平方。</div>
<div class="line">这种二次散列时要求N2的空间要求似乎感觉会使得完全散列会对空间需求太大，实际上，通过合适的选取第一次的散列函数，总存储空间的预期仍然为O(n)。</div>
</div>
</dd>
</dl>
</li>
<li><p class="first">完全散列的核心在于： <strong>将N个关键值散列到</strong> N<sup>2</sup><strong>个的槽中，就一定可以找到一个无碰撞的散列函数来提供常量级别的查找时间 （空间换时间嘛）</strong> 。</p>
</li>
</ul>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     hash_table.cpp</span>
<span class="cm"> * @brief    散列表</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>


<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="c1">/// @brief Noraml Hash Table</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">HashTable</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">T</span>     <span class="n">value</span><span class="p">;</span>
    <span class="n">Node</span>  <span class="o">*</span><span class="n">pre</span><span class="p">;</span>
    <span class="n">Node</span>  <span class="o">*</span><span class="n">next</span><span class="p">;</span>
  <span class="p">};</span>

<span class="k">public</span><span class="o">:</span>
  <span class="k">explicit</span> <span class="n">HashTable</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span> <span class="n">data_</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">}</span>    

  <span class="o">~</span><span class="n">HashTable</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="nl">n</span> <span class="p">:</span> <span class="n">data_</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">Node</span><span class="o">*</span> <span class="n">Find</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">data_</span><span class="p">[</span><span class="n">GetHashValue</span><span class="p">(</span><span class="n">v</span><span class="p">)];</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">Insert</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Find</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">shared</span> <span class="o">=</span> <span class="n">GetHashValue</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">old_node</span> <span class="o">=</span> <span class="n">data_</span><span class="p">[</span><span class="n">shared</span><span class="p">];</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">new_node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">();</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">pre</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">old_node</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">old_node</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">old_node</span><span class="o">-&gt;</span><span class="n">pre</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">data_</span><span class="p">[</span><span class="n">shared</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">Delete</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">Find</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pre</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">data_</span><span class="p">[</span><span class="n">GetHashValue</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">p</span><span class="o">-&gt;</span><span class="n">pre</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">pre</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pre</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">Display</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">data_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;槽[&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span> <span class="mi">3</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span> <span class="mi">3</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;] &quot;</span><span class="p">;</span>

      <span class="n">Node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">data_</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; --&gt; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>


<span class="k">private</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">GetHashValue</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">v</span> <span class="o">%</span> <span class="n">data_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*&gt;</span> <span class="n">data_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">/// @brief 全域散列表</span>
<span class="c1">///</span>
<span class="c1">/// - 全域散列表是一种使用“键接法”来解决碰撞问题的散列表方法。\n</span>
<span class="c1">/// - 随机化保证了对于任何输入，算法都具有较好的平均性能。\n</span>
<span class="c1">/// - 全域的散列函数组：设H为一组散列函数，它将给定的关键字域U映射到{0,1,…,m-1}</span>
<span class="c1">///   中，这样的一个函数组称为是全域的。如果从H中随机地选择一个散列函数，当关键</span>
<span class="c1">///   字K≠J时，两者发生碰撞的概率不大于1/m。</span>
<span class="c1">/// - 明白这个散列函数的选取是在“&lt;b&gt;执行开始&lt;/b&gt;”随机的选取一个是很重要的，要</span>
<span class="c1">///   不然就会不明白到时候怎么进行查找。\n</span>
<span class="c1">///   这里所谓的随机性应该这样理解：对于某一个散列表来说，它在初始化时已经把a,b</span>
<span class="c1">///   固定了，但是对于一个还未初始化的全域散列表来说，a,b是随机选取的。</span>
<span class="c1">///</span>
<span class="c1">/// 全域散列函数类，首先选择一个足够大的质数p ，使得每一个可能的关键字k 都落到0 到p-1 的范围内，包括首尾的0 和p-1。\n</span>
<span class="c1">/// 这里我们假设全域是0 – 15，p 为17。设集合Zp 为{0, 1, 2, …, p-1}，集合Zp* 为{1, 2, 3, …, p-1}。\n</span>
<span class="c1">/// 由于p 是质数，我们可以定义散列函数\n</span>
<span class="c1">///                     h(a, b, k) = ((a*k + b) mod p) mod m\n</span>
<span class="c1">/// 其中a 属于Zp，b 属于Zp*。由所有这样的a 和b 构成的散列函数，组成了函数簇。即全域散列。\n</span>
<span class="c1">/// 全域散列的基本思想是在执行&lt;b&gt;开始&lt;/b&gt;时，从一族仔细设计的函数中，随机的选择一个作为散列函数。\n</span>
<span class="c1">/// 使之独立于要存储的关键字。不管对手选择了怎样的关键字，其平均性态都很好。\n</span>
<span class="c1">/// @param  T  散列表里要存储的元素类型</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">UniversalHashTable</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">/// 构造一个全域散列表,同时从一族仔细设计的函数中，随机的选择一个作为散列函数。</span>
  <span class="n">UniversalHashTable</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">_p</span> <span class="o">=</span> <span class="mi">101</span><span class="p">;</span>    <span class="c1">//一个足够大的质数</span>
    <span class="n">_m</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>    <span class="c1">//槽的个数</span>
    <span class="n">_items</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span> <span class="n">_m</span><span class="p">,</span> <span class="k">nullptr</span> <span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">//全部先设置好头结点</span>
      <span class="n">_items</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">_Node</span><span class="p">();</span>
      <span class="n">_items</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 全域散列的基本思想是在执行&lt;b&gt;开始&lt;/b&gt;时，从一族仔细设计的函数中，随机的选择一个作为散列函数。</span>
    <span class="n">_a</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span> <span class="n">_p</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">_b</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="n">_p</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">UniversalHashTable</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">for_each</span><span class="p">(</span> <span class="n">_items</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">_items</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span> <span class="n">_Node</span> <span class="o">*</span> <span class="n">item</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">while</span> <span class="p">(</span> <span class="n">item</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">next</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
        <span class="k">delete</span> <span class="n">item</span><span class="p">;</span>
        <span class="n">item</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">/// 向散列表中插入一个元素</span>
  <span class="kt">void</span> <span class="n">Insert</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">new_value</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">//始终插入在键表的头，头结点之后的第1个位置</span>
    <span class="n">_Node</span> <span class="o">*</span><span class="n">new_item</span> <span class="o">=</span> <span class="k">new</span> <span class="n">_Node</span><span class="p">;</span>
    <span class="n">new_item</span><span class="o">-&gt;</span><span class="n">Item</span> <span class="o">=</span> <span class="n">new_value</span><span class="p">;</span>
    <span class="n">new_item</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">hash_value</span> <span class="o">=</span> <span class="n">_HashFunction</span><span class="p">(</span> <span class="n">new_value</span> <span class="p">);</span>

    <span class="n">new_item</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">=</span> <span class="n">_items</span><span class="p">[</span><span class="n">hash_value</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
    <span class="n">_items</span><span class="p">[</span><span class="n">hash_value</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">=</span> <span class="n">new_item</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// @brief 从散列表中删除一个元素</span>
  <span class="c1">///</span>
  <span class="c1">/// @return  是否成功的删除这样的元素</span>
  <span class="kt">bool</span> <span class="n">Delete</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">delete_value</span> <span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">hash_value</span> <span class="o">=</span> <span class="n">_HashFunction</span><span class="p">(</span> <span class="n">delete_value</span> <span class="p">);</span>
    <span class="n">_Node</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">_items</span><span class="p">[</span><span class="n">hash_value</span><span class="p">];</span>

    <span class="k">while</span> <span class="p">(</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">Next</span><span class="o">-&gt;</span><span class="n">Item</span> <span class="o">==</span> <span class="n">delete_value</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
        <span class="n">root</span><span class="o">-&gt;</span><span class="n">Next</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">Next</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
        <span class="k">delete</span> <span class="n">temp</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// 在散列表中搜索一个元素</span>
  <span class="n">T</span> <span class="o">*</span> <span class="n">Search</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">search_value</span> <span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">hash_value</span> <span class="o">=</span> <span class="n">_HashFunction</span><span class="p">(</span> <span class="n">search_value</span> <span class="p">);</span>
    <span class="n">_Node</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">_items</span><span class="p">[</span><span class="n">hash_value</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span> <span class="n">root</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">Item</span> <span class="o">==</span> <span class="n">search_value</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">&amp;</span><span class="p">(</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">Item</span> <span class="p">);</span>
      <span class="p">}</span>
      <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// 将散列表中的所有的元素显示在输出流中</span>
  <span class="kt">void</span> <span class="n">Display</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">_Node</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="n">_items</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>  <span class="c1">//跳过头结点</span>

      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;槽[&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span> <span class="mi">3</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">setw</span><span class="p">(</span> <span class="mi">3</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;]&quot;</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span> <span class="n">item</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; -&gt; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">Item</span><span class="p">;</span>
        <span class="n">item</span> <span class="o">=</span> <span class="n">item</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>


<span class="k">private</span><span class="o">:</span>
  <span class="c1">/// @brief 节点（使用单键表）</span>
  <span class="c1">///</span>
  <span class="c1">/// 要是用双键表就会方便很多啊</span>
  <span class="k">struct</span> <span class="n">_Node</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">Item</span><span class="p">;</span>
    <span class="n">_Node</span> <span class="o">*</span><span class="n">Next</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="c1">/// @brief 全域散列函数</span>
  <span class="c1">///</span>
  <span class="c1">/// 本函数、一开始时随机选取_a,_b、再加上选取_p,_m的方法，就是全域散列的核心所在！！！</span>
  <span class="c1">/// h(a, b, k) = ((a*k + b) mod p) mod m</span>
  <span class="kt">int</span> <span class="nf">_HashFunction</span><span class="p">(</span> <span class="n">T</span> <span class="n">k</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">_a</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="n">_b</span> <span class="p">)</span> <span class="o">%</span> <span class="n">_p</span> <span class="o">%</span> <span class="n">_m</span><span class="p">;</span>
  <span class="p">}</span>


  <span class="kt">int</span> <span class="n">_p</span><span class="p">,</span> <span class="n">_m</span><span class="p">,</span> <span class="n">_a</span><span class="p">,</span> <span class="n">_b</span><span class="p">;</span>      <span class="c1">///&lt; 全域散列表的各个参数</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">_Node</span> <span class="o">*&gt;</span> <span class="n">_items</span><span class="p">;</span>    <span class="c1">///&lt; 槽：存储真正的键表，使用的是带头结点的单键表</span>
<span class="p">};</span>


<span class="c1">/// 测试全域散列表类</span>
<span class="kt">int</span> <span class="nf">testUniversalHashTable</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">UniversalHashTable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">table</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;开始往UniversalHashTable里添加内容[0,100)：&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">table</span><span class="p">.</span><span class="n">Insert</span><span class="p">(</span> <span class="n">i</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="n">table</span><span class="p">.</span><span class="n">Display</span><span class="p">();</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;开始删除内容[0,5)：&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">table</span><span class="p">.</span><span class="n">Delete</span><span class="p">(</span> <span class="n">i</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="n">table</span><span class="p">.</span><span class="n">Display</span><span class="p">();</span>

  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">finded</span> <span class="o">=</span> <span class="n">table</span><span class="p">.</span><span class="n">Search</span><span class="p">(</span> <span class="n">i</span> <span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;开始检索结点[&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;]：&quot;</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">finded</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">finded</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span>  <span class="s">&quot;未找到&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">testNormalHashTable</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">HashTable</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ht</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ht</span><span class="p">.</span><span class="n">Insert</span><span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span><span class="p">);</span>
  <span class="p">}</span> 
  <span class="n">ht</span><span class="p">.</span><span class="n">Display</span><span class="p">();</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ht</span><span class="p">.</span><span class="n">Delete</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">ht</span><span class="p">.</span><span class="n">Display</span><span class="p">();</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ht</span><span class="p">.</span><span class="n">Insert</span><span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span><span class="p">);</span>
  <span class="p">}</span> 
  <span class="n">ht</span><span class="p">.</span><span class="n">Display</span><span class="p">();</span>
<span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">testUniversalHashTable</span><span class="p">();</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;=============================================&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">testNormalHashTable</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>开始往UniversalHashTable里添加内容[0,100)：
槽[  0  ] -&gt; 97 -&gt; 94 -&gt; 91 -&gt; 75 -&gt; 72 -&gt; 56 -&gt; 53 -&gt; 34 -&gt; 31 -&gt; 15 -&gt; 12
槽[  1  ] -&gt; 88 -&gt; 85 -&gt; 69 -&gt; 66 -&gt; 50 -&gt; 47 -&gt; 28 -&gt; 25 -&gt; 9 -&gt; 6
槽[  2  ] -&gt; 82 -&gt; 79 -&gt; 63 -&gt; 60 -&gt; 44 -&gt; 41 -&gt; 22 -&gt; 19 -&gt; 3 -&gt; 0
槽[  3  ] -&gt; 98 -&gt; 95 -&gt; 76 -&gt; 73 -&gt; 57 -&gt; 54 -&gt; 38 -&gt; 35 -&gt; 16 -&gt; 13
槽[  4  ] -&gt; 92 -&gt; 89 -&gt; 70 -&gt; 67 -&gt; 51 -&gt; 48 -&gt; 32 -&gt; 29 -&gt; 10 -&gt; 7
槽[  5  ] -&gt; 86 -&gt; 83 -&gt; 64 -&gt; 61 -&gt; 45 -&gt; 42 -&gt; 26 -&gt; 23 -&gt; 4 -&gt; 1
槽[  6  ] -&gt; 99 -&gt; 96 -&gt; 80 -&gt; 77 -&gt; 58 -&gt; 55 -&gt; 39 -&gt; 36 -&gt; 20 -&gt; 17
槽[  7  ] -&gt; 93 -&gt; 90 -&gt; 74 -&gt; 71 -&gt; 52 -&gt; 49 -&gt; 33 -&gt; 30 -&gt; 14 -&gt; 11
槽[  8  ] -&gt; 87 -&gt; 84 -&gt; 68 -&gt; 65 -&gt; 46 -&gt; 43 -&gt; 27 -&gt; 24 -&gt; 8 -&gt; 5
槽[  9  ] -&gt; 81 -&gt; 78 -&gt; 62 -&gt; 59 -&gt; 40 -&gt; 37 -&gt; 21 -&gt; 18 -&gt; 2
开始删除内容[0,5)：
槽[  0  ] -&gt; 97 -&gt; 94 -&gt; 91 -&gt; 75 -&gt; 72 -&gt; 56 -&gt; 53 -&gt; 34 -&gt; 31 -&gt; 15 -&gt; 12
槽[  1  ] -&gt; 88 -&gt; 85 -&gt; 69 -&gt; 66 -&gt; 50 -&gt; 47 -&gt; 28 -&gt; 25 -&gt; 9 -&gt; 6
槽[  2  ] -&gt; 82 -&gt; 79 -&gt; 63 -&gt; 60 -&gt; 44 -&gt; 41 -&gt; 22 -&gt; 19
槽[  3  ] -&gt; 98 -&gt; 95 -&gt; 76 -&gt; 73 -&gt; 57 -&gt; 54 -&gt; 38 -&gt; 35 -&gt; 16 -&gt; 13
槽[  4  ] -&gt; 92 -&gt; 89 -&gt; 70 -&gt; 67 -&gt; 51 -&gt; 48 -&gt; 32 -&gt; 29 -&gt; 10 -&gt; 7
槽[  5  ] -&gt; 86 -&gt; 83 -&gt; 64 -&gt; 61 -&gt; 45 -&gt; 42 -&gt; 26 -&gt; 23
槽[  6  ] -&gt; 99 -&gt; 96 -&gt; 80 -&gt; 77 -&gt; 58 -&gt; 55 -&gt; 39 -&gt; 36 -&gt; 20 -&gt; 17
槽[  7  ] -&gt; 93 -&gt; 90 -&gt; 74 -&gt; 71 -&gt; 52 -&gt; 49 -&gt; 33 -&gt; 30 -&gt; 14 -&gt; 11
槽[  8  ] -&gt; 87 -&gt; 84 -&gt; 68 -&gt; 65 -&gt; 46 -&gt; 43 -&gt; 27 -&gt; 24 -&gt; 8 -&gt; 5
槽[  9  ] -&gt; 81 -&gt; 78 -&gt; 62 -&gt; 59 -&gt; 40 -&gt; 37 -&gt; 21 -&gt; 18
开始检索结点[0]：未找到
开始检索结点[1]：未找到
开始检索结点[2]：未找到
开始检索结点[3]：未找到
开始检索结点[4]：未找到
开始检索结点[5]：5
开始检索结点[6]：6
开始检索结点[7]：7
开始检索结点[8]：8
开始检索结点[9]：9
=============================================
槽[  0 ]  --&gt; 40 --&gt; 90
槽[  1 ]  --&gt; 11 --&gt; 21
槽[  2 ]  --&gt; 72 --&gt; 62 --&gt; 92
槽[  3 ]  --&gt; 63 --&gt; 93
槽[  4 ] 
槽[  5 ]  --&gt; 35 --&gt; 15
槽[  6 ]  --&gt; 36 --&gt; 26 --&gt; 86
槽[  7 ]  --&gt; 27 --&gt; 77
槽[  8 ]  --&gt; 68
槽[  9 ]  --&gt; 59 --&gt; 49

槽[  0 ]  --&gt; 90
槽[  1 ] 
槽[  2 ]  --&gt; 72 --&gt; 62 --&gt; 92
槽[  3 ]  --&gt; 63 --&gt; 93
槽[  4 ] 
槽[  5 ] 
槽[  6 ]  --&gt; 86
槽[  7 ]  --&gt; 77
槽[  8 ]  --&gt; 68
槽[  9 ]  --&gt; 59

槽[  0 ]  --&gt; 30 --&gt; 90
槽[  1 ]  --&gt; 11
槽[  2 ]  --&gt; 42 --&gt; 22 --&gt; 2 --&gt; 82 --&gt; 72 --&gt; 62 --&gt; 92
槽[  3 ]  --&gt; 73 --&gt; 23 --&gt; 63 --&gt; 93
槽[  4 ] 
槽[  5 ]  --&gt; 35
槽[  6 ]  --&gt; 56 --&gt; 86
槽[  7 ]  --&gt; 67 --&gt; 77
槽[  8 ]  --&gt; 58 --&gt; 68
槽[  9 ]  --&gt; 69 --&gt; 29 --&gt; 59

</pre></div>
</div>
</div>
<div class="section" id="id16">
<h3>第12章：二叉查找树<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h3>
<ul>
<li><p class="first"><strong>二叉查找树</strong> 的定义：对任何结点X，其左子树中的关键字最大不超过key[X]；其右子树中的关键字最小不小于key[x]。</p>
</li>
<li><p class="first">首先先明显：二叉查找树上的基本操作的时间都与树的高度成正比的，所以高度越小的树性能越高。</p>
</li>
<li><p class="first">查询二叉查找树可以考虑使用非递归的版本，它运行要快得多而且也很容易理解:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">SEARCH</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span><span class="o">:</span>
<span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="p">.</span><span class="n">Key</span> <span class="o">!=</span> <span class="n">k</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">.</span><span class="n">Key</span><span class="p">)</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">Left</span><span class="p">;</span>
    <span class="k">else</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">Right</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">x</span><span class="p">;</span>
</pre></div>
</div>
</li>
<li><dl class="first docutils">
<dt>前趋和后继：</dt>
<dd><div class="first last line-block">
<div class="line"><span class="raw-html"><S></span> 前趋：左一次，然后右到头； <span class="raw-html"></S></span></div>
<div class="line"><span class="raw-html"><S></span> 后继：右一次，然后左到头。 <span class="raw-html"></S></span></div>
<div class="line"><strong>错！不止这么简单，以后继为例：当结点的右子树不存在时，应该一路向上传递，直到找到根结点（没有后继）或者是找到一次非右子树传递（后继找到）为止。我的代码就在这里犯一次错误了，本以为很简单的！</strong></div>
<div class="line"><strong>以上的这2条只对存在左结点（前趋）或右结点（后继）时才有效。</strong></div>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>对二叉查找树的插入和删除操作也不复杂，唯一有点难度的地方就是在删除同时存在左右子树的结点时需要进行一些处理。</dt>
<dd><p class="first last">书上叙述的有点过度的复杂，其实可以很简单地说明白：对于这样的结点x，找到x结点的前趋（或后继）y，将x的值替换为y的值，然后递归删除y结点就可以了。因为y一定没有右子树（后继对应没有左子树），所以递归删除的时候就是很简单的情况了。</p>
</dd>
</dl>
</li>
<li><p class="first">可以证明：随机构造的二叉村在平均情况下的行为更接近于最佳情况下的行为，而不是接近最坏情况下的行为。所以一棵在n个关键字上随机构造的二叉查找树的期望高度为O(lgn)。</p>
</li>
</ul>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     binary_search_tree.cpp</span>
<span class="cm"> * @brief    二叉查找树</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>


<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;graphviz_shower.h&quot;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="c1">/// @brief 二叉查找树</span>
<span class="c1">///</span>
<span class="c1">/// 二叉查找树的定义：对任何结点X，其左子树中的关键字最大不超过key[X]；其右子树中的关键字最小不小于key[x]。</span>
<span class="c1">/// 可以证明：随机构造的二叉村在平均情况下的行为更接近于最佳情况下的行为，而不是接近最坏情况下的行为。所以一棵在n个关键字上随机构造的二叉查找树的期望高度为O(lgn)</span>
<span class="k">class</span> <span class="nc">BinarySearchTree</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
  <span class="c1">/// 二叉查找树中的结点</span>
  <span class="k">struct</span> <span class="n">_Node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">Value</span><span class="p">;</span>
    <span class="n">_Node</span> <span class="o">*</span><span class="n">Parent</span><span class="p">;</span>
    <span class="n">_Node</span> <span class="o">*</span><span class="n">Left</span><span class="p">;</span>
    <span class="n">_Node</span> <span class="o">*</span><span class="n">Right</span><span class="p">;</span>
  <span class="p">};</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">BinarySearchTree</span><span class="p">()</span> <span class="o">:</span> <span class="n">_root</span><span class="p">(</span> <span class="k">nullptr</span> <span class="p">)</span> <span class="p">{}</span>

  <span class="o">~</span><span class="n">BinarySearchTree</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//从根结点开始递归的析构</span>
    <span class="n">_RecursiveReleaseNode</span><span class="p">(</span> <span class="n">_root</span> <span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">/// @brief 插入一个结点</span>
  <span class="c1">///</span>
  <span class="c1">/// 向二叉查找树中插入一个值</span>
  <span class="c1">/// @param  new_value  要插入的值</span>
  <span class="c1">/// @return        是否插入成功，失败意味着树中已经存在该值</span>
  <span class="kt">bool</span> <span class="n">Insert</span><span class="p">(</span> <span class="kt">int</span> <span class="k">const</span> <span class="n">new_value</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">Search</span><span class="p">(</span> <span class="n">new_value</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">//已经存在</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">_root</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">//插入的是第1个节点</span>
      <span class="n">_root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">_Node</span><span class="p">();</span>
      <span class="n">_root</span><span class="o">-&gt;</span><span class="n">Value</span> <span class="o">=</span> <span class="n">new_value</span><span class="p">;</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//非第1个节点</span>
    <span class="n">_Node</span> <span class="o">*</span><span class="n">current_node</span> <span class="o">=</span> <span class="n">_root</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span> <span class="n">current_node</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">_Node</span> <span class="o">*&amp;</span><span class="n">next_node_pointer</span> <span class="o">=</span> <span class="p">(</span> <span class="n">new_value</span> <span class="o">&gt;</span> <span class="n">current_node</span><span class="o">-&gt;</span><span class="n">Value</span> <span class="o">?</span> <span class="n">current_node</span><span class="o">-&gt;</span><span class="nl">Right</span> <span class="p">:</span> <span class="n">current_node</span><span class="o">-&gt;</span><span class="n">Left</span> <span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">next_node_pointer</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">current_node</span> <span class="o">=</span> <span class="n">next_node_pointer</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">next_node_pointer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">_Node</span><span class="p">();</span>
        <span class="n">next_node_pointer</span><span class="o">-&gt;</span><span class="n">Value</span> <span class="o">=</span> <span class="n">new_value</span><span class="p">;</span>
        <span class="n">next_node_pointer</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="o">=</span> <span class="n">current_node</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// @brief 删除结点</span>
  <span class="c1">///</span>
  <span class="c1">/// 在二叉查找树中删除一个值</span>
  <span class="c1">/// @param  delete_value  要删除的值</span>
  <span class="c1">/// @return          是否删除成功，删除失败意味着树中没有这个值的结点</span>
  <span class="kt">bool</span> <span class="n">Delete</span><span class="p">(</span> <span class="kt">int</span> <span class="k">const</span> <span class="n">delete_value</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">_Node</span> <span class="o">*</span><span class="n">delete_node</span> <span class="o">=</span> <span class="n">_Search</span><span class="p">(</span> <span class="n">_root</span><span class="p">,</span> <span class="n">delete_value</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">delete_node</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">//未找到该点</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">_DeleteNode</span><span class="p">(</span> <span class="n">delete_node</span> <span class="p">);</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">/// @brief 查找元素</span>
  <span class="c1">///</span>
  <span class="c1">/// 在当前二叉查找树中查找某一值</span>
  <span class="c1">/// @param  search_value  要查找的值</span>
  <span class="c1">/// @return          是否在二叉树中找到值为search_value的结点</span>
  <span class="c1">/// @retval    true    查找到了该元素</span>
  <span class="c1">/// @retval    false    找不到该元素</span>
  <span class="kt">bool</span> <span class="n">Search</span><span class="p">(</span> <span class="kt">int</span> <span class="k">const</span> <span class="n">search_value</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_Search</span><span class="p">(</span> <span class="n">_root</span><span class="p">,</span> <span class="n">search_value</span> <span class="p">)</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// @brief 使用dot描述当前二叉查找树</span>
  <span class="kt">void</span> <span class="n">Display</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">stringstream</span> <span class="n">ss</span><span class="p">;</span>
    <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;digraph graphname&quot;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">1000</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;{&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span>
    <span class="o">&lt;&lt;</span> <span class="s">&quot;    node [shape = record,height = .1];&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">_Display</span><span class="p">(</span> <span class="n">ss</span><span class="p">,</span> <span class="n">_root</span> <span class="p">);</span>
    <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;}&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="n">qi</span><span class="o">::</span><span class="n">ShowGraphvizViaDot</span><span class="p">(</span> <span class="n">ss</span><span class="p">.</span><span class="n">str</span><span class="p">()</span> <span class="p">);</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="c1">/// 真正的删除操作</span>
  <span class="c1">///</span>
  <span class="c1">/// 唯一有点难度的地方就是在删除同时存在左右子树的结点时需要进行一些处理。\n</span>
  <span class="c1">/// 书上叙述的有点过度的复杂，其实可以很简单地说明白：对于这样的结点x，找到x结点的前趋（或后继）y，将x的值替换为</span>
  <span class="c1">/// y的值，然后递归删除y结点就可以了。因为y一定没有右子树（后继对应没有左子树），所以递归删除的时候就是很简单的</span>
  <span class="c1">/// 情况了。</span>
  <span class="c1">/// @note    我这里的方法的确比书上介绍的要好而且容易理解，我这里方法更好的的关键在于：\n</span>
  <span class="c1">///        我的_DeleteNode的参数是要删除的结点的指针，所以是在删除同时存在左右子树的结点时，我可以直接使用y</span>
  <span class="c1">///        的值赋给x结点，再递归删除y结点。如果本方法的参数不是结点的指针而是结点的值，再递归删除y结点的值</span>
  <span class="c1">///        时就会出问题，因为此时x结点的值==y结点的值了。嗯，我的这种以结点指针为参数的思路的确不错！</span>
  <span class="kt">void</span> <span class="n">_DeleteNode</span><span class="p">(</span> <span class="n">_Node</span> <span class="o">*</span> <span class="n">delete_node</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">delete_node</span><span class="o">-&gt;</span><span class="n">Left</span> <span class="o">&amp;&amp;</span> <span class="n">delete_node</span><span class="o">-&gt;</span><span class="n">Right</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">//要删除的结点同时存在左子树和右子树</span>
      <span class="c1">//前驱结点：前驱一定存在，因为该结点同时存在左右子树</span>
      <span class="n">_Node</span> <span class="o">*</span><span class="n">previous_node</span> <span class="o">=</span> <span class="n">_GetPreviousNode</span><span class="p">(</span> <span class="n">delete_node</span> <span class="p">);</span>

      <span class="n">delete_node</span><span class="o">-&gt;</span><span class="n">Value</span> <span class="o">=</span> <span class="n">previous_node</span><span class="o">-&gt;</span><span class="n">Value</span><span class="p">;</span>

      <span class="c1">//previous_nde一定没有右子树，所以再递归调用一定是走这个if的else分支</span>
      <span class="n">_DeleteNode</span><span class="p">(</span> <span class="n">previous_node</span> <span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">//要删除的结点至少有一个子结点为空</span>
      <span class="c1">//sub_node为delete_node的子树</span>
      <span class="c1">//sub_node要么为delete_node的左子树，要么为delete_node的右子树，或者在delete_node无子结点时为空</span>
      <span class="n">_Node</span> <span class="o">*</span><span class="n">sub_node</span> <span class="o">=</span> <span class="p">(</span> <span class="n">delete_node</span><span class="o">-&gt;</span><span class="n">Left</span> <span class="o">?</span> <span class="n">delete_node</span><span class="o">-&gt;</span><span class="nl">Left</span> <span class="p">:</span> <span class="n">delete_node</span><span class="o">-&gt;</span><span class="n">Right</span> <span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span> <span class="n">delete_node</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">//是第1个结点</span>
        <span class="n">_root</span> <span class="o">=</span> <span class="n">sub_node</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="p">(</span> <span class="n">delete_node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Left</span> <span class="o">==</span> <span class="n">delete_node</span>
          <span class="o">?</span> <span class="n">delete_node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="nl">Left</span>
          <span class="p">:</span> <span class="n">delete_node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Right</span> <span class="p">)</span>
        <span class="o">=</span> <span class="n">sub_node</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span> <span class="n">sub_node</span> <span class="p">)</span> <span class="p">{</span>
          <span class="c1">//在delete_node有子结点时需要设置子结点的Parent指针</span>
          <span class="n">sub_node</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="o">=</span> <span class="n">delete_node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>

      <span class="k">delete</span> <span class="n">delete_node</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">/// @brief 得到一个同时存在左右子树的节点的前驱</span>
  <span class="c1">///</span>
  <span class="c1">/// @note    node的前驱一定存在，因为node同时存在左子树和右子树，如果不满足这个先决条件，则该算法的结果是错误的。\n</span>
  <span class="c1">///        以后继为例：当结点的右子树不存在时，应该一路向上传递，直到找到根结点（没有后继）或者是找到一次非右子树传递（后继找到）为止。我的代码就在这里犯一次错误了，本以为很简单的！</span>
  <span class="n">_Node</span> <span class="o">*</span> <span class="n">_GetPreviousNode</span><span class="p">(</span> <span class="n">_Node</span> <span class="o">*</span> <span class="n">node</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">Left</span> <span class="o">||</span> <span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">Right</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">//先决条件必须满足，否则求无限制的结点的前驱算法不是这样的</span>
      <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">logic_error</span><span class="p">(</span> <span class="s">&quot;node必须同时存在左子树和右子树&quot;</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">//还是注意先决条件：node是一个同时存在左右子树的结点，否则算法不是这样的</span>
    <span class="c1">//求结点的前驱：先左一下，再右到头</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Left</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Right</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Right</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">_RecursiveReleaseNode</span><span class="p">(</span> <span class="n">_Node</span> <span class="o">*</span><span class="n">node</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">node</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">_RecursiveReleaseNode</span><span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Left</span> <span class="p">);</span>
      <span class="n">_RecursiveReleaseNode</span><span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Right</span> <span class="p">);</span>
      <span class="k">delete</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">/// 非递归查找一个结点</span>
  <span class="n">_Node</span> <span class="o">*</span> <span class="n">_Search</span><span class="p">(</span> <span class="n">_Node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="k">const</span> <span class="n">search_value</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span> <span class="n">node</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Value</span> <span class="o">!=</span> <span class="n">search_value</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">search_value</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Value</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Left</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Right</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">//到这里如果node为空就是未找到</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">_Display</span><span class="p">(</span> <span class="n">stringstream</span> <span class="o">&amp;</span><span class="n">ss</span><span class="p">,</span> <span class="n">_Node</span> <span class="o">*</span><span class="n">node</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">node</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    node&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[label = </span><span class="se">\&quot;</span><span class="s">&lt;f0&gt;|&lt;f1&gt;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;|&lt;f2&gt;</span><span class="se">\&quot;</span><span class="s">];&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Left</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    </span><span class="se">\&quot;</span><span class="s">node&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">:f0 -&gt; </span><span class="se">\&quot;</span><span class="s">node&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Left</span><span class="o">-&gt;</span><span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">:f1;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">_Display</span><span class="p">(</span> <span class="n">ss</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Left</span> <span class="p">);</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Right</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    </span><span class="se">\&quot;</span><span class="s">node&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">:f2 -&gt; </span><span class="se">\&quot;</span><span class="s">node&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Right</span><span class="o">-&gt;</span><span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">:f1;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">_Display</span><span class="p">(</span> <span class="n">ss</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Right</span> <span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">_Node</span> <span class="o">*</span><span class="n">_root</span><span class="p">;</span>      <span class="c1">///&lt; 二叉查找树的根结点</span>
<span class="p">};</span>


<span class="c1">/// 测试二叉查找树</span>
<span class="kt">int</span> <span class="nf">testBinarySearchTree</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">BinarySearchTree</span> <span class="n">bst</span><span class="p">;</span>
  <span class="c1">//用随机值生成一棵二叉查找树</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">bst</span><span class="p">.</span><span class="n">Insert</span><span class="p">(</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="n">bst</span><span class="p">.</span><span class="n">Display</span><span class="p">();</span>

  <span class="c1">//删除所有的奇数值结点</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bst</span><span class="p">.</span><span class="n">Delete</span><span class="p">(</span> <span class="n">i</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;### Deleted [&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;] ###&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">bst</span><span class="p">.</span><span class="n">Display</span><span class="p">();</span>

  <span class="c1">//查找100以内的数，如果在二叉查找树中，则显示</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bst</span><span class="p">.</span><span class="n">Search</span><span class="p">(</span> <span class="n">i</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;搜索[&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;]元素：</span><span class="se">\t</span><span class="s">成功&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">testBinarySearchTree</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>### Deleted [15] ###
### Deleted [21] ###
### Deleted [35] ###
### Deleted [49] ###
### Deleted [77] ###
### Deleted [83] ###
### Deleted [93] ###

搜索[86]元素：	成功
搜索[92]元素：	成功
</pre></div>
</div>
<img alt="../../_images/binary_search_tree_output1.png" src="../../_images/binary_search_tree_output1.png" />
<div class="line-block">
<div class="line"><br /></div>
</div>
<img alt="../../_images/binary_search_tree_output2.jpg" src="../../_images/binary_search_tree_output2.jpg" />
</div>
<div class="section" id="id17">
<h3>第13章：红黑树<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h3>
<p>满足下面5个条件(红黑性质)的二叉搜索树，称为红黑树：</p>
<blockquote>
<div><ol class="arabic simple">
<li>每个结点或是红色，或是是黑色。</li>
<li>根结点是黑的。</li>
<li>所有的叶结点(NULL)是黑色的。（NULL被视为一个哨兵结点，所有应该指向NULL的指针，都看成指向了NULL结点。）</li>
<li>如果一个结点是红色的，则它的两个儿子节点都是黑色的。</li>
<li>对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点（黑高度相同）。</li>
</ol>
</div></blockquote>
<ul>
<li><p class="first">黑高度的定义：从某个结点出发(不包括该结点)到达一个叶结点的任意一条路径上，黑色结点的个数成为该结点x的黑高度。红黑树的黑高度定义为其根结点的黑高度。</p>
</li>
<li><p class="first">红黑树是真正的在实际中得到大量应用的复杂数据结构： <strong>C++STL中的关联容器map,set都是红黑树的应用</strong> （所以标准库容器的效率太好了，能用标准库容器尽量使用标准库容器）；Linux内核中的用户态地址空间管理也使用了红黑树。</p>
</li>
<li><dl class="first docutils">
<dt>红黑树是许多”平衡的”查找树中的一种（首先：红黑树是一种近似平衡的二叉树），它能保证在最坏的情况下，基本的动态集合操作的时间为O(lgn)。</dt>
<dd><p class="first last">红黑树NB的地方就在于它是 <strong>近似平衡，这种近似平衡提高了操作的效率，又不是绝对的平衡，没有带来太多的负作用</strong> 。</p>
</dd>
</dl>
</li>
<li><p class="first">通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因而是接近平衡的。</p>
</li>
<li><p class="first">全是黑结点的满二叉树也满足红黑树的定义。满二叉树的效率本身就非常高啊，它是效率最好的二叉树了，所以说它是红黑树的一个特例；普通的红黑树要求并没有满二叉树这么严格。</p>
</li>
<li><dl class="first docutils">
<dt>旋转操作（左旋和右旋）： <strong>旋转操作是一种能保持二叉查找树性质的查找树局部操作</strong> 。</dt>
<dd><p class="first last">所有对红黑树结构的修改都只能通过左右旋来完成，这样才能保证修改后的红黑树首先是一棵二叉查找树。</p>
</dd>
</dl>
</li>
<li><p class="first"><strong>红黑树的插入操作</strong> ：将结点Z插入树T中，就好像T是一棵普通的二叉查找树一样，然后将Z着为红色。为保证红黑性质能继续保持，我们调用一个辅助程序来对结点重新着色并旋转。</p>
<p>这么做是有它的智慧的：首先，插入结点Z的位置的确应该和普通二叉查找树一样，因为红黑树本身就首先是一棵二叉查找树；
然后将Z着为红色，是为了保证性质5的正确性，因为性质5如果被破坏了是最难以恢复的；
到这里，有可能被破坏的性质就只剩下性质2和性质4了，这都可以通过后来的辅助程序进行修复的。</p>
<div class="line-block">
<div class="line">插入操作可能破坏的性质：</div>
<div class="line">性质2：当被一棵空树进行插入操作时发生；</div>
<div class="line">性质4：当新结点被插入到红色结点之后时发生；</div>
</div>
</li>
<li><p class="first"><strong>红黑树的删除操作</strong> ：和插入操作一样，先用BST的删除结点操作，然后调用相应的辅助函数做相应的调整。首先只有被删除的结点为黑结点时才需要进行修补，理由如下：</p>
<ul class="simple">
<li>树中各结点的黑高度都没有变化</li>
<li>不存在两个相邻的红色结点</li>
<li>因为如果被删除的点是红色，就不可能是根，所以根仍然是黑色的</li>
</ul>
</li>
<li><p class="first">当被删除了黑结点之后，红黑树的性质5被破坏，上面说过了性质5被破坏后的修复难度是最大的。
<strong>这里的修复过程使用了一个很新的思想</strong> ，即视为被删除的结点的子结点有额外的一种黑色，当这一重额外的黑色存在之后，性质5就得到了继续。
然后再通过转移的方法逐步把这一重额外的黑色逐渐向上转移直到根或者红色的结点，最后消除这一重额外的黑色。</p>
<div class="line-block">
<div class="line">删除操作中可能被破坏的性质：</div>
<div class="line">性质2：当y是根时，且y的一个孩子是红色，若此时这个孩子成为根结点；</div>
<div class="line">性质4：当x和p[y]都是红色时；</div>
<div class="line">性质5：包含y的路径中，黑高度都减少了；</div>
</div>
</li>
<li><p class="first">红黑树是平衡查找树，还有B树也是另一类平衡查找树。</p>
</li>
</ul>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     red_black_tree.cpp</span>
<span class="cm"> * @brief    红黑树</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>


<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;graphviz_shower.h&quot;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="c1">/// @brief 红黑树</span>
<span class="c1">///</span>
<span class="c1">/// 满足下面几个条件(红黑性质)的二叉搜索树，称为红黑树：</span>
<span class="c1">/// -# 每个结点或是红色，或是是黑色。</span>
<span class="c1">/// -# 根结点是黑的。</span>
<span class="c1">/// -# 所有的叶结点(NULL)是黑色的。（NULL被视为一个哨兵结点，所有应该指向NULL的指针，都看成指向了NULL结点。）</span>
<span class="c1">/// -# 如果一个结点是红色的，则它的两个儿子节点都是黑色的。</span>
<span class="c1">/// -# 对每个结点，从该结点到其子孙结点的所有路径上包含相同数目的黑结点。</span>
<span class="c1">///</span>
<span class="c1">/// 红黑树的性质：</span>
<span class="c1">/// - 黑高度的定义： 从某个结点出发(不包括该结点)到达一个叶结点的任意一条路径上，黑色结点的个数成为该结点x的黑高度。</span>
<span class="c1">/// 红黑树的黑高度定义为其根结点的黑高度。</span>
<span class="c1">/// - 红黑树是真正的在实际中得到大量应用的复杂数据结构：C++STL中的关联容器map,set都是红黑树的应用（所以标准库容器的</span>
<span class="c1">/// 效率太好了，能用标准库容器尽量使用标准库容器）；\n Linux内核中的用户态地址空间管理也使用了红黑树。</span>
<span class="c1">/// - 红黑树是许多“&lt;b&gt;平衡的&lt;/b&gt;”查找树中的一种（首先：&lt;span style=&quot;color:#FF0000 &quot;&gt;红黑树是一种近似平衡的二叉树</span>
<span class="c1">/// &lt;/span&gt;），它能保证在最坏的情况下，基本的动态集合操作的时间为O(lgn)。</span>
<span class="c1">/// - 通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其它路径长出两倍，因而是接近平衡的。</span>
<span class="c1">/// - 一要全是黑结点的满二叉树也满足红黑树的定义。满二叉树的效率本身就非常高啊，它是效率最好的二叉树了，所以说它是</span>
<span class="c1">/// 红黑树的一个特例；普通的红黑树要求并没有满二叉树这么严格。</span>
<span class="c1">/// - 红黑树之所以这么高效，是因为它是&lt;span style=&quot;color:#FF0000 &quot;&gt;近似平衡&lt;/span&gt;的，又不要求完全的平衡，减少了维</span>
<span class="c1">/// 护的代价。在计算机科学中有大量的这样的例子，使用近似的东西来提高效率。如二项堆、斐波那契堆等等数不胜数…</span>
<span class="c1">/// @param  TKey  结点中键的类型</span>
<span class="c1">/// @param  TValue  结点中值的类型</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">TKey</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TValue</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">RBTree</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">/// 红黑树中结点颜色的枚举</span>
  <span class="k">enum</span> <span class="n">RBTreeNodeColor</span> <span class="p">{</span>
    <span class="n">BLACK</span><span class="p">,</span>      <span class="c1">///&lt; 黑色</span>
    <span class="n">RED</span>        <span class="c1">///&lt; 红色</span>
  <span class="p">};</span>

  <span class="c1">/// 红黑树中的结点</span>
  <span class="k">struct</span> <span class="n">RBTreeNode</span> <span class="p">{</span>
    <span class="n">TKey</span>        <span class="n">Key</span><span class="p">;</span>      <span class="c1">///&lt; 结点中的KEY</span>
    <span class="n">TValue</span>        <span class="n">Value</span><span class="p">;</span>      <span class="c1">///&lt; 结点中的值</span>
    <span class="n">RBTreeNodeColor</span>    <span class="n">Color</span><span class="p">;</span>      <span class="c1">///&lt; 结点的颜色，红色还是黑色</span>
    <span class="n">RBTreeNode</span>      <span class="o">*</span><span class="n">Parent</span><span class="p">;</span>    <span class="c1">///&lt; 父结点指针</span>
    <span class="n">RBTreeNode</span>      <span class="o">*</span><span class="n">Left</span><span class="p">;</span>      <span class="c1">///&lt; 左孩子指针</span>
    <span class="n">RBTreeNode</span>      <span class="o">*</span><span class="n">Right</span><span class="p">;</span>      <span class="c1">///&lt; 右孩子指针</span>

    <span class="c1">/// @brief 检查是否有效（哨兵结点nil 算作无效结点）</span>
    <span class="c1">/// @return      该结点是否为有效结点，即不为nil结点</span>
    <span class="c1">/// @retval  true  非nil结点</span>
    <span class="c1">/// @retval false  nil结点</span>
    <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">IsValid</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">(</span> <span class="k">this</span> <span class="o">!=</span> <span class="n">s_nil</span> <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="n">RBTree</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">s_nil</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">//叶子结点是一个特殊的黑结点</span>
      <span class="n">s_nil</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RBTreeNode</span><span class="p">();</span>
      <span class="n">s_nil</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">_root</span> <span class="o">=</span> <span class="n">s_nil</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">RBTree</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">_RecursiveReleaseNode</span><span class="p">(</span> <span class="n">_root</span> <span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">/// @brief 插入一个结点</span>
  <span class="c1">///</span>
  <span class="c1">/// 红黑树的插入操作：将结点Z插入树T中，就好像T是一棵普通的二叉查找树一样，然后将Z着为红色。为保证红黑性质能继续</span>
  <span class="c1">/// 保持，我们调用一个辅助程序来对结点重新着色并旋转。这么做是有它的智慧的：首先，插入结点Z的位置的确应该和普通</span>
  <span class="c1">/// 二叉查找树一样，因为红黑树本身就首先是一棵二叉查找树；然后将Z着为红色，是为了保证性质5的正确性，因为性质5如</span>
  <span class="c1">/// 果被破坏了是最难以恢复的；到这里，有可能被破坏的性质就只剩下性质2和性质4了，这都可以通过后来的辅助程序进行修</span>
  <span class="c1">/// 复的。\n</span>
  <span class="c1">/// 插入操作可能破坏的性质：</span>
  <span class="c1">/// - 性质2：当被一棵空树进行插入操作时发生；</span>
  <span class="c1">/// - 性质4：当新结点被插入到红色结点之后时发生；</span>
  <span class="kt">bool</span> <span class="n">Insert</span><span class="p">(</span> <span class="n">TKey</span> <span class="n">key</span><span class="p">,</span> <span class="n">TValue</span> <span class="n">value</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">Search</span><span class="p">(</span> <span class="n">key</span> <span class="p">)</span><span class="o">-&gt;</span><span class="n">IsValid</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">//key重复，添加失败</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">//新添加的结点为红结点，且Left=Right=s_nil</span>
      <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">new_node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RBTreeNode</span><span class="p">();</span>
      <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">Key</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
      <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">Value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
      <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="o">=</span> <span class="n">RED</span><span class="p">;</span>
      <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">Left</span> <span class="o">=</span> <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">Right</span> <span class="o">=</span> <span class="n">s_nil</span><span class="p">;</span>

      <span class="n">_InsertAsNormalBSTree</span><span class="p">(</span> <span class="n">new_node</span> <span class="p">);</span>
      <span class="n">_InsertFixup</span><span class="p">(</span> <span class="n">new_node</span> <span class="p">);</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">/// @brief 删除一个结点</span>
  <span class="c1">/// 红黑树的删除操作：和插入操作一样，先用BST的删除结点操作，然后调用相应的辅助函数做相应的调整。\n</span>
  <span class="c1">/// 首先只有被删除的结点为黑结点时才需要进行修补，理由如下：</span>
  <span class="c1">/// - 树中各结点的黑高度都没有变化</span>
  <span class="c1">/// - 不存在两个相邻的红色结点</span>
  <span class="c1">/// - 因为如果被删除的点是红色，就不可能是根，所以根仍然是黑色的</span>
  <span class="c1">///</span>
  <span class="c1">/// 当被删除了黑结点之后，红黑树的性质5被破坏，上面说过了性质5被破坏后的修复难度是最大的。所以这里的修复过程使用</span>
  <span class="c1">/// 了一个很新的思想，即视为被删除的结点的子结点有额外的一种黑色，当这一重额外的黑色存在之后，性质5就得到了继续</span>
  <span class="c1">/// 。然后再通过转移的方法逐步把这一重额外的黑色逐渐向上转移直到根或者红色的结点，最后消除这一重额外的黑色。\n</span>
  <span class="c1">/// 删除操作中可能被破坏的性质：</span>
  <span class="c1">/// - 性质2：当y是根时，且y的一个孩子是红色，若此时这个孩子成为根结点；</span>
  <span class="c1">/// - 性质4：当x和p[y]都是红色时；</span>
  <span class="c1">/// - 性质5：包含y的路径中，黑高度都减少了；</span>
  <span class="kt">bool</span> <span class="n">Delete</span><span class="p">(</span> <span class="n">TKey</span> <span class="n">key</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">z</span> <span class="o">=</span> <span class="n">Search</span><span class="p">(</span> <span class="n">key</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">IsValid</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">//实际要删除的结点，因为后面会有一个交换，所以实际删除y之后就达到了z的效果</span>
      <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">z</span><span class="o">-&gt;</span><span class="n">Left</span><span class="o">-&gt;</span><span class="n">IsValid</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">z</span><span class="o">-&gt;</span><span class="n">Right</span><span class="o">-&gt;</span><span class="n">IsValid</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">//至少有一个孩子为nil</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">//左右孩子均不为nil，则找后继</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">_Successor</span><span class="p">(</span> <span class="n">z</span> <span class="p">);</span>
      <span class="p">}</span>

      <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">Left</span><span class="o">-&gt;</span><span class="n">IsValid</span><span class="p">()</span> <span class="o">?</span> <span class="n">y</span><span class="o">-&gt;</span><span class="nl">Left</span> <span class="p">:</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">Right</span> <span class="p">);</span>
      <span class="n">x</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="o">=</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">y</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">IsValid</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">_root</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">y</span> <span class="o">==</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Left</span> <span class="p">)</span> <span class="p">{</span>
          <span class="n">y</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Left</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">y</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Right</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span> <span class="n">y</span> <span class="o">!=</span> <span class="n">z</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">z</span><span class="o">-&gt;</span><span class="n">Key</span> <span class="o">=</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">Key</span><span class="p">;</span>
        <span class="n">z</span><span class="o">-&gt;</span><span class="n">Value</span> <span class="o">=</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">Value</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="o">==</span> <span class="n">BLACK</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">_DeleteFixup</span><span class="p">(</span> <span class="n">x</span> <span class="p">);</span>
      <span class="p">}</span>

      <span class="k">delete</span> <span class="n">y</span><span class="p">;</span>  <span class="c1">//最后实际删除了y结点</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">//要删除的结点不存在</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">/// 在红黑树上搜索一个结点</span>
  <span class="n">RBTreeNode</span> <span class="o">*</span> <span class="n">Search</span><span class="p">(</span> <span class="n">TValue</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">value</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">_root</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span> <span class="n">node</span> <span class="o">!=</span> <span class="n">s_nil</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Value</span> <span class="o">!=</span> <span class="n">value</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">node</span> <span class="o">=</span> <span class="p">(</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Value</span> <span class="o">?</span> <span class="n">node</span><span class="o">-&gt;</span><span class="nl">Left</span> <span class="p">:</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Right</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// 判断红黑树是否为空</span>
  <span class="kt">bool</span> <span class="n">Empty</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">!</span><span class="p">(</span> <span class="n">_root</span><span class="o">-&gt;</span><span class="n">IsValid</span><span class="p">()</span> <span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">/// @brief 显示当前二叉查找树的状态</span>
  <span class="kt">void</span> <span class="n">Display</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">stringstream</span> <span class="n">ss</span><span class="p">;</span>

    <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;digraph graphname&quot;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">1000</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;{&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span>
    <span class="o">&lt;&lt;</span> <span class="s">&quot;    node [shape = record,height = .1];&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">_Display</span><span class="p">(</span> <span class="n">ss</span><span class="p">,</span> <span class="n">_root</span> <span class="p">);</span>
    <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;}&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="n">qi</span><span class="o">::</span><span class="n">ShowGraphvizViaDot</span><span class="p">(</span> <span class="n">ss</span><span class="p">.</span><span class="n">str</span><span class="p">()</span> <span class="p">);</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">_RecursiveReleaseNode</span><span class="p">(</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">node</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">IsValid</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">_RecursiveReleaseNode</span><span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Left</span> <span class="p">);</span>
      <span class="n">_RecursiveReleaseNode</span><span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Right</span> <span class="p">);</span>
      <span class="k">delete</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">_Display</span><span class="p">(</span> <span class="n">stringstream</span> <span class="o">&amp;</span><span class="n">ss</span><span class="p">,</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">node</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">IsValid</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    node&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[label = </span><span class="se">\&quot;</span><span class="s">&lt;f0&gt;|&lt;f1&gt;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;|&lt;f2&gt;</span><span class="se">\&quot;</span><span class="s">, color = &quot;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="o">==</span> <span class="n">RED</span> <span class="o">?</span> <span class="s">&quot;red&quot;</span> <span class="o">:</span> <span class="s">&quot;black&quot;</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;];&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Left</span><span class="o">-&gt;</span><span class="n">IsValid</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    </span><span class="se">\&quot;</span><span class="s">node&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">:f0 -&gt; </span><span class="se">\&quot;</span><span class="s">node&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Left</span><span class="o">-&gt;</span><span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">:f1;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">_Display</span><span class="p">(</span> <span class="n">ss</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Left</span> <span class="p">);</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Right</span><span class="o">-&gt;</span><span class="n">IsValid</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    </span><span class="se">\&quot;</span><span class="s">node&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">:f2 -&gt; </span><span class="se">\&quot;</span><span class="s">node&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Right</span><span class="o">-&gt;</span><span class="n">Value</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">:f1;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">_Display</span><span class="p">(</span> <span class="n">ss</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Right</span> <span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">/// @brief 将一个结点简单地加入红黑树</span>
  <span class="c1">///</span>
  <span class="c1">/// 视该红黑树为普通的二叉查找树简单的进行插入操作，需要在此之后调整以满足红黑树的性质</span>
  <span class="c1">/// @note    一定要保证node-&gt;Key一定是一个新的值，否则会无限循环，在这里不检查</span>
  <span class="kt">void</span> <span class="n">_InsertAsNormalBSTree</span><span class="p">(</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">node</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">_root</span><span class="o">-&gt;</span><span class="n">IsValid</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">//插入的是第1个节点</span>
      <span class="n">_root</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
      <span class="n">_root</span><span class="o">-&gt;</span><span class="n">Left</span> <span class="o">=</span> <span class="n">_root</span><span class="o">-&gt;</span><span class="n">Right</span> <span class="o">=</span> <span class="n">_root</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="o">=</span> <span class="n">s_nil</span><span class="p">;</span>
      <span class="n">_root</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//非第1个节点</span>
    <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">current_node</span> <span class="o">=</span> <span class="n">_root</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span> <span class="nb">true</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">RBTreeNode</span> <span class="o">*&amp;</span><span class="n">next_node_pointer</span> <span class="o">=</span> <span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Key</span> <span class="o">&gt;</span> <span class="n">current_node</span><span class="o">-&gt;</span><span class="n">Key</span> <span class="o">?</span> <span class="n">current_node</span><span class="o">-&gt;</span><span class="nl">Right</span> <span class="p">:</span> <span class="n">current_node</span><span class="o">-&gt;</span><span class="n">Left</span> <span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">next_node_pointer</span><span class="o">-&gt;</span><span class="n">IsValid</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">current_node</span> <span class="o">=</span> <span class="n">next_node_pointer</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">//进行真正的插入操作</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="o">=</span> <span class="n">current_node</span><span class="p">;</span>
        <span class="n">next_node_pointer</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">/// @brief 对插入操作的修复</span>
  <span class="c1">///</span>
  <span class="c1">/// 由于对红黑树的插入操作破坏了红黑树的性质，所以需要对它进行修正</span>
  <span class="c1">/// @note    node的结点是需要处理的结点，由于它破坏了红黑性质，它一定是红结点</span>
  <span class="kt">void</span> <span class="n">_InsertFixup</span><span class="p">(</span> <span class="n">RBTreeNode</span> <span class="o">*</span> <span class="n">node</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="o">==</span> <span class="n">RED</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">//标识node的父结点是否为node的祖父结点的左孩子</span>
      <span class="kt">bool</span> <span class="n">parent_is_left_child_flag</span> <span class="o">=</span> <span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="o">==</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Left</span> <span class="p">);</span>
      <span class="c1">//叔叔结点</span>
      <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">uncle</span> <span class="o">=</span> <span class="n">parent_is_left_child_flag</span> <span class="o">?</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="nl">Right</span> <span class="p">:</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Left</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">uncle</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="o">==</span> <span class="n">RED</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">//case1</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>
        <span class="n">uncle</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="o">=</span> <span class="n">RED</span><span class="p">;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">node</span> <span class="o">==</span> <span class="p">(</span> <span class="n">parent_is_left_child_flag</span> <span class="o">?</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="nl">Right</span> <span class="p">:</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Left</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
          <span class="c1">//case2</span>
          <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="p">;</span>
          <span class="n">parent_is_left_child_flag</span> <span class="o">?</span> <span class="n">_LeftRotate</span><span class="p">(</span> <span class="n">node</span> <span class="p">)</span> <span class="o">:</span> <span class="n">_RightRotate</span><span class="p">(</span> <span class="n">node</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">//case3</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="o">=</span> <span class="n">RED</span><span class="p">;</span>
        <span class="n">parent_is_left_child_flag</span> <span class="o">?</span> <span class="n">_RightRotate</span><span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="p">)</span> <span class="o">:</span> <span class="n">_LeftRotate</span><span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">//处理性质2被破坏只需要简简单单一句话</span>
    <span class="n">_root</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// 左旋</span>
  <span class="c1">///</span>
  <span class="c1">/// 旋转操作是一种能保持二叉查找树性质的查找树局部操作</span>
  <span class="kt">void</span> <span class="n">_LeftRotate</span><span class="p">(</span> <span class="n">RBTreeNode</span> <span class="o">*</span> <span class="n">node</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">IsValid</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Right</span><span class="o">-&gt;</span><span class="n">IsValid</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">//左旋操作要求对非哨兵进行操作，并且要求右孩子也不是哨兵</span>
      <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">logic_error</span><span class="p">(</span> <span class="s">&quot;左旋操作要求对非哨兵进行操作，并且要求右孩子也不是哨兵&quot;</span> <span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">//node的右孩子</span>
      <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">right_son</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Right</span><span class="p">;</span>

      <span class="n">node</span><span class="o">-&gt;</span><span class="n">Right</span> <span class="o">=</span> <span class="n">right_son</span><span class="o">-&gt;</span><span class="n">Left</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">right_son</span><span class="o">-&gt;</span><span class="n">Left</span><span class="o">-&gt;</span><span class="n">IsValid</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">right_son</span><span class="o">-&gt;</span><span class="n">Left</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">right_son</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">IsValid</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">_root</span> <span class="o">=</span> <span class="n">right_son</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">node</span> <span class="o">==</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Left</span> <span class="p">)</span> <span class="p">{</span>
          <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Left</span> <span class="o">=</span> <span class="n">right_son</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Right</span> <span class="o">=</span> <span class="n">right_son</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">right_son</span><span class="o">-&gt;</span><span class="n">Left</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
      <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="o">=</span> <span class="n">right_son</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">/// 右旋</span>
  <span class="c1">///</span>
  <span class="c1">/// 旋转操作是一种能保持二叉查找树性质的查找树局部操作</span>
  <span class="kt">void</span> <span class="n">_RightRotate</span><span class="p">(</span> <span class="n">RBTreeNode</span> <span class="o">*</span> <span class="n">node</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">IsValid</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Left</span><span class="o">-&gt;</span><span class="n">IsValid</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">//右旋操作要求对非哨兵进行操作，并且要求左孩子也不是哨兵</span>
      <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">logic_error</span><span class="p">(</span> <span class="s">&quot;右旋操作要求对非哨兵进行操作，并且要求左孩子也不是哨兵&quot;</span> <span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">//node的左孩子</span>
      <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">left_son</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Left</span><span class="p">;</span>

      <span class="n">node</span><span class="o">-&gt;</span><span class="n">Left</span> <span class="o">=</span> <span class="n">left_son</span><span class="o">-&gt;</span><span class="n">Right</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">left_son</span><span class="o">-&gt;</span><span class="n">Right</span><span class="o">-&gt;</span><span class="n">IsValid</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">left_son</span><span class="o">-&gt;</span><span class="n">Right</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">left_son</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">IsValid</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">_root</span> <span class="o">=</span> <span class="n">left_son</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">node</span> <span class="o">==</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Left</span> <span class="p">)</span> <span class="p">{</span>
          <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Left</span> <span class="o">=</span> <span class="n">left_son</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Right</span> <span class="o">=</span> <span class="n">left_son</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">left_son</span><span class="o">-&gt;</span><span class="n">Right</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
      <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="o">=</span> <span class="n">left_son</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">/// 对删除操作的修复</span>
  <span class="kt">void</span> <span class="n">_DeleteFixup</span><span class="p">(</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">x</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">_root</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="o">==</span> <span class="n">BLACK</span> <span class="p">)</span> <span class="p">{</span>
      <span class="kt">bool</span> <span class="n">node_is_parent_left_child</span> <span class="o">=</span> <span class="p">(</span> <span class="n">x</span> <span class="o">==</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Left</span> <span class="p">);</span>
      <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">w</span> <span class="o">=</span> <span class="n">node_is_parent_left_child</span> <span class="o">?</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="nl">Right</span> <span class="p">:</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Left</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="o">==</span> <span class="n">RED</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">//case1</span>
        <span class="n">w</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>
        <span class="n">x</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="o">=</span> <span class="n">RED</span><span class="p">;</span>
        <span class="n">_LeftRotate</span><span class="p">(</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="p">);</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Right</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="c1">//case2</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">Left</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="o">==</span> <span class="n">BLACK</span> <span class="o">&amp;&amp;</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">Right</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="o">==</span> <span class="n">BLACK</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">//两个孩子都为黑结点</span>
        <span class="n">w</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="o">=</span> <span class="n">RED</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">//case3</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span> <span class="n">node_is_parent_left_child</span> <span class="o">?</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">Right</span><span class="o">-&gt;</span><span class="nl">Color</span> <span class="p">:</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">Left</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="p">)</span> <span class="o">==</span> <span class="n">BLACK</span> <span class="p">)</span> <span class="p">{</span>
          <span class="p">(</span> <span class="n">node_is_parent_left_child</span> <span class="o">?</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">Left</span><span class="o">-&gt;</span><span class="nl">Color</span> <span class="p">:</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">Right</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="p">)</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>
          <span class="n">w</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="o">=</span> <span class="n">RED</span><span class="p">;</span>
          <span class="n">node_is_parent_left_child</span> <span class="o">?</span> <span class="n">_RightRotate</span><span class="p">(</span> <span class="n">w</span> <span class="p">)</span> <span class="o">:</span> <span class="n">_LeftRotate</span><span class="p">(</span> <span class="n">w</span> <span class="p">);</span>
          <span class="n">w</span> <span class="o">=</span> <span class="p">(</span> <span class="n">node_is_parent_left_child</span> <span class="o">?</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="nl">Right</span> <span class="p">:</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Left</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">//case4</span>
        <span class="n">w</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Color</span><span class="p">;</span>
        <span class="n">x</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>
        <span class="p">(</span> <span class="n">node_is_parent_left_child</span> <span class="o">?</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">Right</span><span class="o">-&gt;</span><span class="nl">Color</span> <span class="p">:</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">Left</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="p">)</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>
        <span class="n">node_is_parent_left_child</span> <span class="o">?</span> <span class="n">_LeftRotate</span><span class="p">(</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="p">)</span> <span class="o">:</span> <span class="n">_RightRotate</span><span class="p">(</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="p">);</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">_root</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">//最后只需要简单置x为黑结点就可以，_root的改变已经由左右旋自动处理了</span>
    <span class="n">x</span><span class="o">-&gt;</span><span class="n">Color</span> <span class="o">=</span> <span class="n">BLACK</span><span class="p">;</span>    <span class="c1">//改为黑色。</span>
  <span class="p">}</span>

  <span class="c1">/// 得到节点的后继</span>
  <span class="n">RBTreeNode</span> <span class="o">*</span> <span class="n">_Successor</span><span class="p">(</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">node</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Right</span><span class="o">-&gt;</span><span class="n">IsValid</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">//存在右结点时：右一下，左到头</span>
      <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Right</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Left</span><span class="o">-&gt;</span><span class="n">IsValid</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Left</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">//不存在右结点时：一直向上，直到找到一次非右孩子或到根了为止</span>
      <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span> <span class="o">!</span><span class="n">y</span><span class="o">-&gt;</span><span class="n">IsValid</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">node</span> <span class="o">==</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">Right</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>


  <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">_root</span><span class="p">;</span>        <span class="c1">///&lt; 根结点</span>
  <span class="k">static</span> <span class="n">RBTreeNode</span> <span class="o">*</span><span class="n">s_nil</span><span class="p">;</span>    <span class="c1">///&lt; 红黑树的叶子结点（哨兵）</span>
<span class="p">};</span>


<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">TKey</span><span class="p">,</span> <span class="k">typename</span> <span class="n">TValue</span><span class="o">&gt;</span>
<span class="k">typename</span> <span class="n">RBTree</span><span class="o">&lt;</span><span class="n">TKey</span><span class="p">,</span> <span class="n">TValue</span><span class="o">&gt;::</span><span class="n">RBTreeNode</span> <span class="o">*</span> <span class="n">RBTree</span><span class="o">&lt;</span><span class="n">TKey</span><span class="p">,</span> <span class="n">TValue</span><span class="o">&gt;::</span><span class="n">s_nil</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>

<span class="c1">/// 红黑树</span>
<span class="kt">int</span> <span class="nf">testRedBlackTree</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">init</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">11</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">};</span>
  <span class="n">RBTree</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">bst</span><span class="p">;</span>
  <span class="c1">//for ( int i = 0; i &lt; sizeof( init ) / sizeof( init[0] ); ++i )</span>
  <span class="c1">//{</span>
  <span class="c1">//    bst.Insert( init[i], init[i] );</span>
  <span class="c1">//}</span>
  <span class="c1">//bst.Insert( 4, 4 );</span>
  <span class="c1">//bst.Display();</span>

  <span class="c1">//用随机值生成一棵二叉查找树</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span><span class="p">;</span>
    <span class="n">bst</span><span class="p">.</span><span class="n">Insert</span><span class="p">(</span> <span class="n">v</span><span class="p">,</span> <span class="n">v</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="n">bst</span><span class="p">.</span><span class="n">Display</span><span class="p">();</span>

  <span class="c1">//bst.Delete(5);</span>
  <span class="c1">//删除所有的小奇数</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">50</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">bst</span><span class="p">.</span><span class="n">Delete</span><span class="p">(</span> <span class="n">i</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Deleted [&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;]&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">bst</span><span class="p">.</span><span class="n">Display</span><span class="p">();</span>
  <span class="c1">//删除所有的大偶数</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">50</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">bst</span><span class="p">.</span><span class="n">Delete</span><span class="p">(</span> <span class="n">i</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Deleted [&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;]&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">bst</span><span class="p">.</span><span class="n">Display</span><span class="p">();</span>
  <span class="c1">//再随机添加</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span><span class="p">;</span>
    <span class="n">bst</span><span class="p">.</span><span class="n">Insert</span><span class="p">(</span> <span class="n">v</span><span class="p">,</span> <span class="n">v</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="n">bst</span><span class="p">.</span><span class="n">Display</span><span class="p">();</span>
  <span class="c1">//删除所有</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bst</span><span class="p">.</span><span class="n">Delete</span><span class="p">(</span> <span class="n">i</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Deleted [&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;]&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

  <span class="p">}</span>
  <span class="c1">//bst.Display();</span>

  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span><span class="p">;</span>
    <span class="n">bst</span><span class="p">.</span><span class="n">Insert</span><span class="p">(</span> <span class="n">v</span><span class="p">,</span> <span class="n">v</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="n">bst</span><span class="p">.</span><span class="n">Display</span><span class="p">();</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">testRedBlackTree</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Deleted</span> <span class="p">[</span><span class="mi">11</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">15</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">19</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">21</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">23</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">27</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">29</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">35</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">37</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">49</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">56</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">58</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">62</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">68</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">70</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">72</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">82</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">84</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">86</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">90</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">92</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">98</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">8</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">12</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">13</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">14</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">22</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">24</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">25</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">26</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">27</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">29</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">30</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">32</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">34</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">36</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">39</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">40</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">42</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">43</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">45</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">46</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">50</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">51</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">54</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">56</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">57</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">59</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">60</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">62</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">63</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">64</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">67</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">68</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">69</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">70</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">73</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">76</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">77</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">78</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">80</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">81</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">82</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">83</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">84</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">86</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">87</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">88</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">93</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">94</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">95</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">96</span><span class="p">]</span>
<span class="n">Deleted</span> <span class="p">[</span><span class="mi">99</span><span class="p">]</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../../_images/red_black_tree_output1.png"><img alt="../../_images/red_black_tree_output1.png" src="../../_images/red_black_tree_output1.png" style="width: 1285.1999999999998px; height: 366.09999999999997px;" /></a>
<a class="reference internal image-reference" href="../../_images/red_black_tree_output2.png"><img alt="../../_images/red_black_tree_output2.png" src="../../_images/red_black_tree_output2.png" style="width: 1094.4px; height: 354.40000000000003px;" /></a>
<a class="reference internal image-reference" href="../../_images/red_black_tree_output3.png"><img alt="../../_images/red_black_tree_output3.png" src="../../_images/red_black_tree_output3.png" style="width: 614.4000000000001px; height: 290.40000000000003px;" /></a>
<a class="reference internal image-reference" href="../../_images/red_black_tree_output4.png"><img alt="../../_images/red_black_tree_output4.png" src="../../_images/red_black_tree_output4.png" style="width: 1353.6px; height: 313.8px;" /></a>
<a class="reference internal image-reference" href="../../_images/red_black_tree_output5.png"><img alt="../../_images/red_black_tree_output5.png" src="../../_images/red_black_tree_output5.png" style="width: 1247.2px; height: 418.40000000000003px;" /></a>
</div>
<div class="section" id="id18">
<h3>第14章：数据结构的扩张<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h3>
<ul class="simple">
<li>实际的工程中，极少会去创造新的数据结构，通常是对标准的数据结构附加一些信息，并添加一些新的操作以支持应用的要求。</li>
<li>数据结构的扩张：指在实际应用数据结构时对标准的数据结构中增加一些信息、编入一些新的操作等等。附加的信息必须能够为该数据结构上的常规操作所更新和维护。</li>
<li>对一种数据结构的扩张过程可以分为四个步骤：<ol class="arabic">
<li>选择基础的数据结构</li>
<li>确定要在基础数据结构中添加哪些信息</li>
<li>验证可用基础数据结构上的基本修改操作来维护这些新添加的信息</li>
<li>设计新的操作</li>
</ol>
</li>
<li>红黑树的扩张定理：当结点中新添加的信息可以由该结点和它的左右子树来决定，那么就可以在不影响时间复杂度的前提下在插入和删除等操作中对红黑树的这些附加信息进行维护。</li>
</ul>
</div>
</div>
<div class="section" id="id19">
<h2>第四部分：高级设计和分析技术<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>设计和分析高效算法的 <strong>三种重要技术：动态规划、贪心算法和平摊分析</strong></li>
<li>动态规划通常应用于最优化问题，即要做出一组选择以达到一个最优解时。在做选择的同时，经常出现同样形式的子问题。 <strong>关键技术是存储这些子问题每一个的解，以备它重复出现。</strong></li>
<li><dl class="first docutils">
<dt>贪心算法通常也是应用于最优化问题，该算法的思想是以局部最优的方式来做每一个选择。采用贪心算法可以比动态规划更快的得出一个最优解，但是关键是不容易判断贪心算法所得到的是否真的是最优解，这是需要证明的，所以说每一个贪心算法后面都有一个漂亮的动态规划算法作为理论支撑。</dt>
<dd>贪心算法可以在一定的理论之下，通过只考虑局部最优解就可以保证得到的一定是全局最优解。如赫夫曼编码。</dd>
</dl>
</li>
<li>平摊分析是一种用来分析执行一系列类似操作的算法的工具。在一个操作序列中，不可能每一个都以其已知的最坏情况运行，某些操作的代价高些，而其它的低一些。</li>
</ul>
<p>所有的最优化问题都可以通过穷举法来解决，但是这在时间上是不可接受的。所有的高效算法都是为了加快速度：</p>
<blockquote>
<div><ul class="simple">
<li>动态规划：保存子问题的解，以备重复使用</li>
<li>贪心算法：用局部最优解来求全局最优解</li>
</ul>
</div></blockquote>
<p>平摊分析是用来分析算法的工具，它本身并不是一种算法。</p>
<div class="section" id="id20">
<h3>第15章：动态规划<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h3>
<ul>
<li><p class="first">动态规划与分治法之间的区别：</p>
<ul class="simple">
<li>分治法是指将问题分成一些 <strong>独立</strong> 的子问题，递归的求解各子问题</li>
<li>动态规划适用于这些子问题 <strong>独立且重叠</strong> 的情况，也就是各子问题包含公共子问题</li>
</ul>
</li>
<li><p class="first">动态规划算法的设计可以分为4个步骤：</p>
<ol class="arabic simple">
<li>描述最优解的子结构</li>
<li>递归定义最优解的值</li>
<li>按自底向上的方法计算最优解的值</li>
<li>由计算出的结果反向构造出一个最优解</li>
</ol>
</li>
<li><p class="first"><strong>动态规划最最最重要的就是要找出最优解的子结构</strong> ！</p>
</li>
<li><p class="first">最优子结构在问题域中以两种方式变化（在找出这两个问题的解之后，构造出原问题的最优子结构往往就不是难事了）：</p>
<ul class="simple">
<li>有多少个子问题被用在原问题的一个最优解中</li>
<li>在决定一个最优解中使用哪些子问题有多少个选择</li>
</ul>
</li>
<li><p class="first">动态规划说白了就是一个递归的反向展开的过程：在满足①最优子结构②重叠子问题这2个条件下，通过把递归从下至上的进行展开以避免重复计算子问题从而加速了最终问题的求解的过程。</p>
</li>
<li><p class="first"><strong>再次强调”动态规划最关键的一步就是：寻找最优子结构”</strong></p>
</li>
<li><p class="first">动态规划能够消除重复计算子问题是因为它与普通递归相反，它是通过自下而上的方式来进行求解的。</p>
</li>
<li><p class="first">正确使用 <strong>动态规划方法的2个关键要素：最优子结构 和 重叠子问题</strong> 。</p>
<ul class="simple">
<li>如果问题的一个最优解中包含了子问题的最优解，则该问题具有最优子结构；而当一个问题具有最优子结构时，提示我们动态规划可能会适用。</li>
<li>如果问题可以由递归来解决，并且在递归的过程中会不断的出现重复的子问题需要解决，那毫不犹豫的采用动态规划吧！</li>
</ul>
</li>
<li><p class="first">剪贴技术：用来证明在问题的一个最优解中，使用的子问题的解本身也必须是最优的</p>
</li>
<li><p class="first">为了描述子问题空间，可以遵循这样一条有效的经验规则，就是尽量保持这个空间简单，然后在需要时再扩充它</p>
</li>
<li><dl class="first docutils">
<dt>非正式地：一个动态规划算法的运行时间依赖于两个因素的乘积：子问题的总个数和每个子问题中有多少种选择。</dt>
<dd><p class="first last">问题解的代价通常是子问题的代价加上选择本身带来的开销。</p>
</dd>
</dl>
</li>
<li><p class="first">贪心算法与动态规划有一个显著的区别：就是在贪心算法中，是以自顶向下的方式使用最优子结构的。贪心算法会先做选择，在当时看起来是最优的选择，然后再求解一个结果子问题，而不是先寻找子问题的最优解，然后再选择。</p>
</li>
<li><dl class="first docutils">
<dt>要注意：在不能应用最优子结构的时间，就一定不能假设它能够应用。</dt>
<dd><p class="first last"><strong>坚决警惕使用动态规划去解决缺乏最优子结构的问题！</strong></p>
</dd>
</dl>
</li>
<li><p class="first">使用动态规划时： <strong>子问题必须是相互独立的！</strong> 可以这样理解，N个子问题域互不相干，属于完全不同的空间。</p>
</li>
<li><p class="first">重叠子问题：不同的子问题的数目是输入规模的一个多项式。这样，动态规划算法才能充分利用重叠的子问题，减少计算量。即通过每个子问题只解一次，把解保存在一个需要时就可以查看的表中，而每次查表只需要常数时间。</p>
<p>从这段描述可以看出： <strong>动态规划与递归时做备忘录的本质是完全相同的，所以说备忘录方法与普通的动态递归本质完全相同，没有孰优孰劣之分，哪个方便用哪个。</strong></p>
</li>
<li><p class="first">由计算出的结果反向构造一个最优解：把动态规划或者是递归过程中作出的每一次选择（记住：保存的是每次作出的选择）都保存下来，在最后就一定可以通过这些保存的选择来反向构造出最优解。</p>
</li>
<li><p class="first"><strong>做备忘录的递归方法</strong> ：这种方法是动态规划的一个变形，它本质上与动态规划是一样的，但是比动态规划更好理解！</p>
<ul class="simple">
<li>使用普通的递归结构，自上而下的解决问题。</li>
<li>当在递归算法的执行中每一次遇到一个子问题时，就计算它的解并填入一个表中。以后每次遇到该子问题时，只要查看并返回表中先前填入的值即可。</li>
<li>备忘录方法有一个好处就是：它不会去计算那些对最优解无用的子问题，即只计算必须计算的子问题；但是普通的动态规划会计算所有的子问题，不管它是不是必须的。</li>
</ul>
</li>
<li><p class="first">备忘录方法与动态递归方法的比较：</p>
<ul class="simple">
<li>如果所有的子问题都至少要被计算一次，则一个自底向上的动态规划算法通常比一个自顶向下的做备忘录算法好出一个常数因子。因为动态规划没有使用递归的代价，只用到了循环，所以常数因子肯定比递归要好一些。</li>
<li>此外，在有些问题中，还可以用动态规划算法中的表存取模式来进一步的减少时间和空间上的需求；</li>
<li>或者，如果子问题中的某些子问题根本没有必须求解，做备忘录的方法有着只解那些肯定要求解的子问题的优点。（而且这点是自动获得的，那些不必要计算的子问题在备忘录方法中会被自动的抛弃）</li>
</ul>
</li>
<li><dl class="first docutils">
<dt>备忘录方法总结： <strong>由”是否所有的子问题都至少需要被计算一次”来决定使用动态规划还是备忘录</strong></dt>
<dd><p class="first last">再次下定义：这两种方法没孰优孰劣之分，因为它们的本质思想是完全一样的；消除重复子问题。</p>
</dd>
</dl>
</li>
<li><p class="first">动态规划： <strong>最重要最重要的就是找到最优子结构。在找到最优子结构之后的消除重复子问题，这点我太容易处理了，无论是动态规划的自底向上的递推，还是备忘录，或者是备忘录的变型，都可以轻松的应付。关键就是最优子结构。</strong></p>
</li>
</ul>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     longest_common_subsequence.cpp</span>
<span class="cm"> * @brief   最长公共子串问题 </span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>

<span class="k">namespace</span> <span class="p">{</span> <span class="c1">//匿名命名空间</span>
<span class="n">string</span> <span class="k">const</span> <span class="n">LeftHandSide</span> <span class="o">=</span> <span class="s">&quot;abcbdabbadbcddbacbdad&quot;</span><span class="p">;</span>
<span class="n">string</span> <span class="k">const</span> <span class="n">RightHandSide</span> <span class="o">=</span> <span class="s">&quot;bdcaadcbdbddababba&quot;</span><span class="p">;</span>


<span class="c1">/// 普通的递归,时间复杂度为n的指数级</span>
<span class="kt">int</span> <span class="nf">LongestCommonSubsequenceViaRecurise</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">LeftHandSide</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">RightHandSide</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">LongestCommonSubsequenceViaRecurise</span><span class="p">(</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">max</span><span class="p">(</span> <span class="n">LongestCommonSubsequenceViaRecurise</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">),</span> <span class="n">LongestCommonSubsequenceViaRecurise</span><span class="p">(</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="p">)</span> <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>



<span class="c1">/// 加入了备忘录功能的递归</span>
<span class="c1">///</span>
<span class="c1">/// 加入备忘录之后的运行速度超级大幅度的提升,在递归会进行很多重复的子问题的计算的情况下,这样一个小小的改动,极大的提高了效率</span>
<span class="c1">/// 两点改动就可以增加备忘录的功能</span>
<span class="c1">/// 1:在最前面加一个判断,是否已经计算过了,如果已经计算过了就直接取结果返回.</span>
<span class="c1">/// 2:每次要返回之前先把结果保存一下.</span>
<span class="kt">int</span> <span class="nf">_LongestCommonSubsequenceViaMemoize</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">memoize</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">chooses</span> <span class="p">)</span> <span class="p">{</span>
  <span class="c1">//这个检查备忘录的过程就是“备忘录”方法与普通递归的区别</span>
  <span class="c1">//所以说备忘录方法简单好用，只需要使用递归的思维，再加上一个备忘子递归结果的memoize就可以了。</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">memoize</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">//先检查已经存在于备忘录中</span>
    <span class="k">return</span> <span class="n">memoize</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">memoize</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">LeftHandSide</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">RightHandSide</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">//写备忘录</span>
      <span class="n">memoize</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">_LongestCommonSubsequenceViaMemoize</span><span class="p">(</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memoize</span><span class="p">,</span> <span class="n">chooses</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">chooses</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">//记录选择for step 4</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">i_sub</span> <span class="o">=</span> <span class="n">_LongestCommonSubsequenceViaMemoize</span><span class="p">(</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">memoize</span><span class="p">,</span> <span class="n">chooses</span> <span class="p">);</span>
      <span class="kt">int</span> <span class="n">j_sub</span> <span class="o">=</span> <span class="n">_LongestCommonSubsequenceViaMemoize</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">memoize</span><span class="p">,</span> <span class="n">chooses</span> <span class="p">);</span>

      <span class="n">chooses</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span> <span class="n">i_sub</span> <span class="o">&gt;</span> <span class="n">j_sub</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">1</span> <span class="p">);</span>  <span class="c1">//记录选择for step 4</span>
      <span class="n">memoize</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span> <span class="n">i_sub</span><span class="p">,</span> <span class="n">j_sub</span> <span class="p">);</span>    <span class="c1">//写备忘录</span>
    <span class="p">}</span>

    <span class="c1">//备忘录中已经保存当前的子问题的解，直接从备忘录中取出来返回</span>
    <span class="k">return</span> <span class="n">memoize</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">LongestCommonSubsequenceViaMemoize</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">//LongestCommonSubsequenceViaMemoize方法的备忘录。</span>
  <span class="c1">//memoize[i][j]意味着:取LeftHandSide的前i个字符得到的子字符串与取RightHandSide的前j个字符得到的子字符串 的最长公共子序列的长度</span>
  <span class="n">vector</span><span class="o">&lt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">memoize</span><span class="p">;</span>
  <span class="c1">//初始化memoize数组,使得其为memoize[0..m, 0..n]</span>
  <span class="n">memoize</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span> <span class="n">LeftHandSide</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">);</span>
  <span class="n">for_each</span><span class="p">(</span> <span class="n">memoize</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">memoize</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">v</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">v</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span> <span class="n">RightHandSide</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">);</span>
  <span class="p">}</span> <span class="p">);</span>
  <span class="c1">//记录递归中每一次所做出的选择，用以在最后构造LCS，这是动态规划中的步骤4</span>
  <span class="n">vector</span><span class="o">&lt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">chooses</span> <span class="o">=</span> <span class="n">memoize</span><span class="p">;</span>

  <span class="c1">//执行递归，求得LCS的长度，同时记录下了每次递归做出的选择</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">_LongestCommonSubsequenceViaMemoize</span><span class="p">(</span> <span class="n">LeftHandSide</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">RightHandSide</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">memoize</span><span class="p">,</span> <span class="n">chooses</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="c1">//动态规划的step 4：构造出最优解（LCS）</span>
  <span class="c1">//无论是使用备忘录的方法还是传统的动态规划方法，最后构造出最优解（LCS）都不太简单</span>
  <span class="c1">//总结step4的思路是这样的：</span>
  <span class="c1">//在动态规划或者递归的过程中，就需要记录下每次做出的选择，这里用chooses[i][j]保存</span>
  <span class="c1">//最后根据每一步所做的选择来反向构造出最优解（LCS）</span>
  <span class="n">string</span> <span class="n">left</span> <span class="o">=</span> <span class="n">LeftHandSide</span><span class="p">;</span>
  <span class="n">string</span> <span class="n">right</span> <span class="o">=</span> <span class="n">RightHandSide</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span> <span class="o">!</span><span class="n">left</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">right</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">choose</span> <span class="o">=</span> <span class="n">chooses</span><span class="p">[</span><span class="n">left</span><span class="p">.</span><span class="n">size</span><span class="p">()][</span><span class="n">right</span><span class="p">.</span><span class="n">size</span><span class="p">()];</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">choose</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">left</span><span class="p">[</span><span class="n">left</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="p">);</span>
      <span class="n">left</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span> <span class="n">left</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">);</span>
      <span class="n">right</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span> <span class="n">right</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">choose</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">left</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span> <span class="n">left</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">right</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span> <span class="n">right</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">reverse</span><span class="p">(</span> <span class="n">result</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">result</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span>
  <span class="n">copy</span><span class="p">(</span> <span class="n">result</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">result</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">cout</span> <span class="p">)</span> <span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// 正统的动态规划</span>
<span class="c1">///</span>
<span class="c1">/// 正统的动态规划与带备忘录功能的递归的区别就在于:一个是自底向上的,一个是从顶向下</span>
<span class="c1">/// 正统的动态规划与带备忘录功能的递归虽然有着相同的渐近复杂度,但是正统的动态规划往往有着更好的常数因子,因而效率更高</span>
<span class="kt">void</span> <span class="nf">LongestCommonSubsequenceViaDynamicProgramming</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// lcs[i][j]意味着:取LeftHandSide的前i个字符得到的子字符串与取RightHandSide的前j个字符得到的子字符串</span>
  <span class="c1">// 的最长公共子序列的长度，并初始化为0。</span>
  <span class="n">vector</span><span class="o">&lt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">lcs</span><span class="p">(</span><span class="n">LeftHandSide</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">RightHandSide</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

  <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">LeftHandSide</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">RightHandSide</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">LeftHandSide</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">RightHandSide</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">lcs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">lcs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">lcs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span> <span class="n">lcs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">lcs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">lcs</span><span class="p">[</span><span class="n">LeftHandSide</span><span class="p">.</span><span class="n">size</span><span class="p">()][</span><span class="n">RightHandSide</span><span class="p">.</span><span class="n">size</span><span class="p">()]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span>

<span class="c1">/// @brief 最长公共子串问题</span>
<span class="c1">///</span>
<span class="c1">/// 一个给定序列的子序列是在该序列中删去若干元素后得到的序列。给定两个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的公共子序列。\n</span>
<span class="c1">/// 最长公共子串就是求给定两个序列的一个最长公共子序列。例如，X=“ABCBDAB”，Y=“BCDB”是X的一个子序列。\n</span>
<span class="c1">///   问题分析：\n</span>
<span class="c1">///   给定两个序列A和B，称序列Z是A和B的公共子序列，是指Z同是A和B的子序列。问题要求已知两序列A和B的最长公共子序列。如采用列举A的所有子序列，并一一检查其是否又是B的子序列，并随时记录所发现的子序列，最终求出最长公共子序列。这种方法因耗时太多而不可取。\n</span>
<span class="c1">///   考虑最长公共子序列问题如何分解成子问题，设A=“a0，a1，…，am-1”，B=“b0，b1，…，bm-1”，并Z=“z0，z1，…，zk-1”为它们的最长公共子序列。不难证明有以下性质： \n</span>
<span class="c1">///   - 如果am-1=bn-1，则zk-1=am-1=bn-1，且“z0，z1，…，zk-2”是“a0，a1，…，am-2”和“b0，b1，…，bn-2”的一个最长公共子序列；</span>
<span class="c1">///   - 如果am-1!=bn-1，则若zk-1!=am-1，蕴涵“z0，z1，…，zk-1”是“a0，a1，…，am-2”和“b0，b1，…，bn-1”的一个最长公共子序列；</span>
<span class="c1">///   - 如果am-1!=bn-1，则若zk-1!=bn-1，蕴涵“z0，z1，…，zk-1”是“a0，a1，…，am-1”和“b0，b1，…，bn-2”的一个最长公共子序列。</span>
<span class="c1">///   这样，在找A和B的公共子序列时，如有am-1=bn-1，则进一步解决一个子问题，找“a0，a1，…，am-2”和“b0，b1，…，bm-2”的一个 最长公共子序列；如果am-1!=bn-1，则要解决两个\n</span>
<span class="c1">///  子问题，找出“a0，a1，…，am-2”和“b0，b1，…，bn-1”的一个最长公共子序列 和找出“a0，a1，…，am-1”和“b0，b1，…，bn-2”的一个最长公共子序列，再取两者中较长者作为A和B的最长公共子序列。\n</span>
<span class="c1">///   为了节约重复求相同子问题的时间，引入一个数组，不管它们是否对最终解有用，把所有子问题的解存于该数组中，这就是动态规划法所采用的基本方法，具体说明如下。 \n</span>
<span class="c1">///   定义c[i][j]为序列“a0，a1，…，ai-2”和“b0，b1，…，bj-1”的最长公共子序列的长度，计算c[i][j]可递归地表述如下： \n</span>
<span class="c1">///   - c[i][j] = 0             如果i=0或j=0；</span>
<span class="c1">///   - c[i][j] = c[i-1][j-1]+1       如果i,j&gt;0，且a[i-1] == b[j-1]；</span>
<span class="c1">///   - c[i][j] = max{c[i][j-1], c[i-1][j]} 如果i,j&gt;0，且a[i-1] != b[j-1]。</span>
<span class="c1">///   按此算式可写出计算两个序列的最长公共子序列的长度函数。由于c[i][j]的产生仅依赖于c[i-1][j-1]、c[i-1][j]和c[i][j-1]，故可以从c[m][n]开始，跟踪c[i][j]的产生过程，逆向构造出最长公共子序列。细节见程序。</span>
<span class="kt">int</span> <span class="n">LongestCommonSubsequence</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">LongestCommonSubsequenceViaMemoize</span><span class="p">();</span>
  <span class="n">LongestCommonSubsequenceViaDynamicProgramming</span><span class="p">();</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">LongestCommonSubsequenceViaRecurise</span><span class="p">(</span> <span class="n">LeftHandSide</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">RightHandSide</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">LongestCommonSubsequence</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="mi">12</span>
<span class="n">bdaadcddbaba</span>
<span class="mi">12</span>
<span class="mi">12</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     assemble_dispatch.cpp</span>
<span class="cm"> * @brief    装配线调度问题</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>


<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="c1">/// @brief 装配线调度问题</span>
<span class="c1">///</span>
<span class="c1">/// 某汽车工厂有2个装配线，每个装配线有n 个装配站（按顺序编号1～n ），两个装配线对应的装配站执行相同的功能，但所用的时间可能不同。经过第i条流水线（i=1，2）</span>
<span class="c1">/// 的第j 个装配站所花的时间为s[i][j]。从第i条流水线的第j 个装配站移到第j+1个装配站的时间可以忽略，而移到另外一个流水线的下一个装配站则需要一定的时间t[i][j]。</span>
<span class="c1">/// - 汽车进入流水线需要花时间e[i]，出流水线时需要花时间x[i]。</span>
<span class="c1">/// - 汽车的装配需要按顺序经过所有装配站。</span>
<span class="c1">/// - 现在已知装配时间s[i][j]和转移时间t[i][j]以及进入时间e[i]、出流水线时间x[i]，要求输出装配一辆汽车所需要的最短时间。</span>
<span class="kt">void</span> <span class="n">AssembleDispatch</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">e</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
  <span class="kt">int</span> <span class="n">S0</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
  <span class="kt">int</span> <span class="n">S1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">};</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">s</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">S0</span><span class="p">,</span> <span class="n">S1</span><span class="p">};</span>
  <span class="kt">int</span> <span class="n">T0</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
  <span class="kt">int</span> <span class="n">T1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">t</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">T0</span><span class="p">,</span> <span class="n">T1</span><span class="p">};</span>

  <span class="c1">//f[i][j]表示完成第i条装配线的第j个装配站的装配工作完成之后，需要的最少时间</span>
  <span class="n">vector</span><span class="o">&lt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">f</span><span class="p">(</span> <span class="mi">2</span> <span class="p">);</span>
  <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span> <span class="mi">6</span> <span class="p">);</span>
  <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span> <span class="mi">6</span> <span class="p">);</span>

  <span class="c1">//l[i][j]表示第i条装配线上的第j个装配站完成工作的最少时间所选用的是哪一条装配线上的j-1装配站</span>
  <span class="c1">//j = 0, l[i][j]时没有意义，因为第0个装配站没有选择</span>
  <span class="n">vector</span><span class="o">&lt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">l</span><span class="p">(</span> <span class="mi">2</span> <span class="p">);</span>
  <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span> <span class="mi">6</span> <span class="p">);</span>
  <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span> <span class="mi">6</span> <span class="p">);</span>

  <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
  <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">//更新f[0][i]</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
      <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
      <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//更新f[1][i]</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
      <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
      <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//如果不需要记录l[i][j]，这样就很方便的实现了，可见动态规划其实比递归还简单易实现</span>
    <span class="c1">//f[0][i] = min( f[0][i - 1] + s[0][i], f[1][i - 1] + s[0][i] + t[1][i - 1] );</span>
    <span class="c1">//f[1][i] = min( f[1][i - 1] + s[1][i], f[0][i - 1] + s[1][i] + t[0][i - 1] );</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">l_star</span> <span class="o">=</span> <span class="p">(</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span> <span class="p">);</span>
  <span class="kt">int</span> <span class="n">final_min_time</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;最短的装配路线需要时间：&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">final_min_time</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">route</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">route</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">l_star</span> <span class="p">);</span>
    <span class="n">l_star</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="n">l_star</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="n">reverse</span><span class="p">(</span> <span class="n">route</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">route</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span>    <span class="c1">//逆转</span>
  <span class="n">copy</span><span class="p">(</span> <span class="n">route</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">route</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">cout</span><span class="p">,</span> <span class="s">&quot; --&gt; &quot;</span> <span class="p">)</span> <span class="p">);</span>
<span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">AssembleDispatch</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>最短的装配路线需要时间：38
0 --&gt; 1 --&gt; 0 --&gt; 1 --&gt; 1 --&gt; 0 --&gt; 
</pre></div>
</div>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     bitonic_tour.cpp</span>
<span class="cm"> * @brief    双调欧几里得旅行商问题</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>

<span class="c1">/// @brief 双调欧几里得旅行商问题</span>
<span class="c1">///</span>
<span class="c1">/// 欧几里得旅行商问题是对平面上给定的n个点确定一条连接各点的最短闭合旅程的问题，这个问题的一般形式是NP完全的，故其解需要多于多项式的时间。\n</span>
<span class="c1">/// J.L.Bentley建议通过只考虑双调旅程来简化问题，这种旅程即为从最左点开始，严格地从左到右直至最右点，然后严格地从右到左直至出发点。在这种情况下，多项式时间的算法是可能的。\n</span>
<span class="c1">/// 描述一个确定最优双调路线的O(n^2)时间的算法，可以假设任何两点的x坐标都不相同。\n\n</span>
<span class="c1">/// 参考了这篇Blog http://blog.sina.com.cn/s/blog_41630e7e0100dp4o.html \n</span>
<span class="c1">/// 此文的思想正确，但是在表述上有些小BUG，在此基础上修正而来的\n</span>
<span class="c1">///</span>
<span class="c1">/// @remarks  找到最优子问题是动态规划的关键--本问题的最优子问题可以描述如下：\n</span>
<span class="c1">///        将各个节点从左至右进行排序，编号为1，2，....n。  B[i][j]表示从i点到第0点，再折回到第j点的最优双调旅程。这样，B[i][j]的递归最优子问题可以表述为以下三种情况：</span>
<span class="c1">///        - B[i+1,k]    = B[i,k] + w(i,i+1)</span>
<span class="c1">///        - B[i+1,i]    = min{ B[u,i] + w(u,i+1) }        (其中 0&lt;=u&lt;=i)</span>
<span class="c1">///        - B[i+1,i+1]  = min{ B[u,i] + w(u,i+1) + w(i,i+1) }  (其中 0&lt;=u&lt;=i)</span>
<span class="c1">///  @remarks  理解这三个情况的递推公司最重要的是要明白：双调旅程问题的每一趟都是单调的，要不单增要不单减。正确理解并应用这个限制条件是解题的关键！</span>
<span class="kt">void</span> <span class="n">BitonicTour</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">;</span>
    <span class="n">Point</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span> <span class="p">)</span> <span class="o">:</span> <span class="n">X</span><span class="p">(</span> <span class="n">x</span> <span class="p">),</span> <span class="n">Y</span><span class="p">(</span> <span class="n">y</span> <span class="p">)</span> <span class="p">{}</span>
    <span class="n">Point</span><span class="p">()</span> <span class="o">:</span> <span class="n">X</span><span class="p">(</span> <span class="mi">0</span> <span class="p">),</span> <span class="n">Y</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{}</span>
  <span class="p">};</span>

  <span class="c1">//初始化值为算法导论上的例子的值</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">points</span><span class="p">;</span>
  <span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">Point</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span> <span class="p">)</span> <span class="p">);</span>
  <span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">Point</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">);</span>
  <span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">Point</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">)</span> <span class="p">);</span>
  <span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">Point</span><span class="p">(</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span> <span class="p">)</span> <span class="p">);</span>
  <span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">Point</span><span class="p">(</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">);</span>
  <span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">Point</span><span class="p">(</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">6</span> <span class="p">)</span> <span class="p">);</span>
  <span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">Point</span><span class="p">(</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">3</span> <span class="p">)</span> <span class="p">);</span>

  <span class="c1">//任意两点之间的距离</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">distances</span><span class="p">(</span> <span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">)</span> <span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">distances</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span> <span class="n">pow</span><span class="p">(</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">X</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">X</span><span class="p">,</span> <span class="mf">2.0</span> <span class="p">)</span> <span class="o">+</span> <span class="n">pow</span><span class="p">(</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Y</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">Y</span><span class="p">,</span> <span class="mf">2.0</span> <span class="p">)</span> <span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">//B[i][j]表示从i点到第0点，再折回到第j点的最优双调旅程</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&gt;</span> <span class="n">B</span><span class="p">(</span> <span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">distances</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
    <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">//进入到这里有一个很重要的先决条件：</span>
      <span class="c1">//B[&lt;=i][&lt;=j]的所有值已经被计算出来了，可以用来递推B[i][j]</span>
      <span class="c1">//明白了这一点，再加了明白双调旅程是单调的，每一趟的下标必须是递增或者递减就可以完整的明白问题。</span>

      <span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">//这里是i刚向前递推进1的分支</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">vd</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span> <span class="p">)</span> <span class="p">{</span>
          <span class="n">vd</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">distances</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">min_element</span><span class="p">(</span> <span class="n">vd</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vd</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">j</span> <span class="o">==</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">vd</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span> <span class="p">)</span> <span class="p">{</span>
          <span class="n">vd</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">distances</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">min_element</span><span class="p">(</span> <span class="n">vd</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vd</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">distances</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
      <span class="p">}</span>

      <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">B</span><span class="p">[</span><span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">BitonicTour</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="mf">25.584</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     plan_party.cpp</span>
<span class="cm"> * @brief    聚会规划问题</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="p">{</span>
<span class="c1">/// 一个人</span>
<span class="k">struct</span> <span class="n">Human</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">Human</span> <span class="o">*&gt;</span> <span class="n">Childs</span><span class="p">;</span>
  <span class="kt">int</span>        <span class="n">LovePartyValue</span><span class="p">;</span>
  <span class="n">string</span>      <span class="n">Name</span><span class="p">;</span>

  <span class="kt">int</span>        <span class="n">IncludeValue</span><span class="p">;</span>      <span class="c1">///&lt; 该Human参与聚会时，以他为根的子树所能得到的最大喜欢度总和</span>
  <span class="kt">int</span>        <span class="n">NotIncludeValue</span><span class="p">;</span>    <span class="c1">///&lt; 该Human不参与聚会时，以他为根的子树所能得到的最大喜欢度总和</span>
  <span class="c1">//IsValid是动态规划的备忘录方式的一个变种</span>
  <span class="kt">bool</span>      <span class="n">IsValid</span><span class="p">;</span>        <span class="c1">///&lt; IncludeValue,NotIncludeValue值是否有效？（无效时为默认值0）</span>

  <span class="n">Human</span><span class="p">(</span> <span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rank_value</span> <span class="p">)</span>
      <span class="o">:</span> <span class="n">Name</span><span class="p">(</span> <span class="n">name</span> <span class="p">),</span> <span class="n">LovePartyValue</span><span class="p">(</span> <span class="n">rank_value</span> <span class="p">),</span> <span class="n">IncludeValue</span><span class="p">(</span> <span class="n">rank_value</span> <span class="p">),</span> <span class="n">IsValid</span><span class="p">(</span> <span class="nb">false</span> <span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">PlanPartyViaDyanmicProgramming</span><span class="p">(</span> <span class="n">Human</span> <span class="o">*</span><span class="n">root</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">root</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">IsValid</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">//root 参加的情况</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">IncludeValue</span> <span class="o">=</span> <span class="n">accumulate</span><span class="p">(</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">LovePartyValue</span><span class="p">,</span> <span class="p">[](</span> <span class="kt">int</span> <span class="n">acc</span><span class="p">,</span> <span class="n">Human</span> <span class="o">*</span> <span class="n">human</span> <span class="p">)</span><span class="o">-&gt;</span><span class="kt">int</span> <span class="p">{</span>
      <span class="n">PlanPartyViaDyanmicProgramming</span><span class="p">(</span> <span class="n">human</span> <span class="p">);</span>
      <span class="k">return</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">human</span><span class="o">-&gt;</span><span class="n">NotIncludeValue</span><span class="p">;</span>
    <span class="p">}</span> <span class="p">);</span>

    <span class="c1">//root 不参加的情况</span>
    <span class="n">root</span><span class="o">-&gt;</span><span class="n">NotIncludeValue</span> <span class="o">=</span> <span class="n">accumulate</span><span class="p">(</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[](</span> <span class="kt">int</span> <span class="n">acc</span><span class="p">,</span> <span class="n">Human</span> <span class="o">*</span> <span class="n">human</span> <span class="p">)</span><span class="o">-&gt;</span><span class="kt">int</span> <span class="p">{</span>
      <span class="n">PlanPartyViaDyanmicProgramming</span><span class="p">(</span> <span class="n">human</span> <span class="p">);</span>
      <span class="k">return</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">max</span><span class="p">(</span> <span class="n">human</span><span class="o">-&gt;</span><span class="n">IncludeValue</span><span class="p">,</span> <span class="n">human</span><span class="o">-&gt;</span><span class="n">NotIncludeValue</span> <span class="p">);</span>
    <span class="p">}</span> <span class="p">);</span>

    <span class="n">root</span><span class="o">-&gt;</span><span class="n">IsValid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

<span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// 聚会规划问题</span>
<span class="kt">void</span> <span class="n">PlanParty</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Human</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Human</span><span class="p">(</span> <span class="s">&quot;TCQ&quot;</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>    <span class="c1">//总裁结点</span>

  <span class="n">Human</span> <span class="o">*</span><span class="n">c1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Human</span><span class="p">(</span> <span class="s">&quot;WY&quot;</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
  <span class="n">Human</span> <span class="o">*</span><span class="n">c2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Human</span><span class="p">(</span> <span class="s">&quot;ABC&quot;</span><span class="p">,</span> <span class="mi">3</span> <span class="p">);</span>
  <span class="n">root</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">c1</span> <span class="p">);</span>
  <span class="n">root</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">c2</span> <span class="p">);</span>

  <span class="n">PlanPartyViaDyanmicProgramming</span><span class="p">(</span> <span class="n">root</span> <span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">max</span><span class="p">(</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">IncludeValue</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">NotIncludeValue</span> <span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">PlanParty</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="mi">5</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     matrix_list_multiply.cpp</span>
<span class="cm"> * @brief    矩阵链乘法问题</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="p">{</span>
<span class="kt">void</span> <span class="n">Print</span><span class="p">(</span> <span class="n">vector</span><span class="o">&lt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">i</span>  <span class="o">==</span> <span class="n">j</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;A&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;(&quot;</span><span class="p">;</span>
    <span class="n">Print</span><span class="p">(</span> <span class="n">pos</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="p">);</span>
    <span class="n">Print</span><span class="p">(</span> <span class="n">pos</span><span class="p">,</span> <span class="n">pos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span> <span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;)&quot;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// @brief 矩阵链乘法问题</span>
<span class="c1">///</span>
<span class="c1">/// 给定n个矩阵{A1,A2,...,An},其中Ai与Ai+1是可乘的，i=1,2,...n-1。现在要计算这n个矩阵的连乘积。</span>
<span class="c1">/// 由于矩阵的乘法满足结合律，所以通过加括号可以使得计算矩阵的连乘积有许多不同的计算次序。然而采用不同的加扩号方式，所需要的总计算量是不一样的。</span>
<span class="c1">/// 在计算矩阵连乘积时，不同的加括号方式所导致的不同的计算对计算量有很大的影响。如何确定计算矩阵连乘积A1A2，...,An的一个计算次序，使得依此次序计算矩阵连乘积需要的数乘次数最少便成为一个问题。</span>
<span class="kt">void</span> <span class="n">MatrixListMultiply</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">maxtix_length</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">30</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">};</span>

  <span class="c1">//初始化一个6*6的二维vector</span>
  <span class="c1">//times[i][j]表示从第i个矩阵到第j个矩阵之间相乘的最少计算次数，当i&gt;j时没有意义</span>
  <span class="n">vector</span><span class="o">&lt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">times</span><span class="p">;</span>
  <span class="n">times</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span> <span class="mi">6</span> <span class="p">);</span>
  <span class="n">for_each</span><span class="p">(</span> <span class="n">times</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">times</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">v</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">v</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span> <span class="mi">6</span> <span class="p">);</span>
  <span class="p">}</span> <span class="p">);</span>
  <span class="c1">//构造一个6*6的二维数组来保存每次对序列进行最优划分的位置</span>
  <span class="c1">//k_pos[i][j]表示在计算从第i个矩阵到第j个矩阵之间相乘的最少计算次数时，应该从k_pos[i][j]进行划分</span>
  <span class="k">auto</span> <span class="n">k_pos</span> <span class="o">=</span> <span class="n">times</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">l</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">//计算长度为l的序列所需要的最少计算次数。按长度递增，因为短的序列必须在长的序列之前进行计算</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
      <span class="n">times</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>

      <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span> <span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">times</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">times</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">maxtix_length</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">maxtix_length</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">maxtix_length</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">times</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="p">)</span> <span class="p">{</span>
          <span class="n">times</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
          <span class="n">k_pos</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">//for (int i = 0; i &lt; 6; ++i)</span>
  <span class="c1">//{</span>
  <span class="c1">//  for (int j = 0; j &lt; 6; ++j)</span>
  <span class="c1">//  {</span>
  <span class="c1">//    cout &lt;&lt; times[i][j] &lt;&lt; &quot;\t&quot;;</span>
  <span class="c1">//  }</span>
  <span class="c1">//  cout &lt;&lt; endl;</span>
  <span class="c1">//}</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">Print</span><span class="p">(</span> <span class="n">k_pos</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span> <span class="p">);</span>
<span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">MatrixListMultiply</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="mi">15125</span>
<span class="p">((</span><span class="n">A0</span><span class="p">(</span><span class="n">A1A2</span><span class="p">))((</span><span class="n">A3A4</span><span class="p">)</span><span class="n">A5</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     best_binary_search_tree.cpp</span>
<span class="cm"> * @brief    最优二叉查找树</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>


<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="c1">/// @brief 最优二叉查找树</span>
<span class="c1">///</span>
<span class="c1">/// 给定一个有序序列K={k1&lt;k2&lt;k3&lt;,……,&lt;kn}和他们被查询的概率P={p1,p2,p3,……,pn}，要求构造一棵二叉查找树T，使得查询所有元素的总的代价最小。</span>
<span class="c1">/// 对于一个搜索树，当搜索的元素在树内时，表示搜索成功。当不在树内时，表示搜索失败，用一个“虚叶子节点”来标示搜索失败的情况，因此需要n+1个虚</span>
<span class="c1">/// 叶子节点{d0&lt;d1&lt;……&lt;dn}。其中d0表示搜索元素小于k1的失败结果，dn表示搜索元素大于kn的失败情况。di（0&lt;i&lt;n）表示搜索节点在ki和k(i+1)之间时</span>
<span class="c1">/// 的失败情况。对于应di的概率序列是Q={q0,q1,……,qn}</span>
<span class="kt">void</span> <span class="n">BestBinarySearchTree</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">//p1 ... p5：这里的p0是个占位符，为了后面的编码方便，p0是无意义的</span>
  <span class="kt">double</span> <span class="n">p</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">};</span>
  <span class="kt">double</span> <span class="n">q</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">};</span>

  <span class="c1">//e[i][j]表示从pi -- pj的最优二叉查找树的期望查找代价</span>
  <span class="n">vector</span><span class="o">&lt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">e</span><span class="p">(</span> <span class="mi">7</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span> <span class="mi">6</span> <span class="p">)</span> <span class="p">);</span>
  <span class="c1">//w[i][j]表示从pi -- pj的概率总和</span>
  <span class="n">vector</span><span class="o">&lt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">w</span><span class="p">(</span> <span class="mi">7</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span> <span class="mi">6</span> <span class="p">)</span> <span class="p">);</span>

  <span class="c1">//先计算出叶子结点单独成为一棵树时的期望查找代价</span>
  <span class="c1">//当e[i][j]的j&lt;i时，e[i][j]代表的是叶子结点。e[i][i-1]代表的是第i-1个叶子结点的期望查找代价</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">//计算从pi -- pj的概率总和，包括普通结点和这里的虚拟叶子结点都要计算</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">//普通结点</span>
        <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">//虚拟叶子结点</span>
        <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">q</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">//这种按长度来进行递推的想法很明显，因为长度是依赖关系</span>
  <span class="c1">//欲知道长度为n的子集的最优二叉查找树，必定要先知道长度小于n的所有子集的最优二叉查找树</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">length</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">//从长度短的子集开始推导长度长的子集</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span> <span class="o">-</span> <span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">//对[i...j]这个子集进行计算它的最优期望查找代价</span>
      <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

      <span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">vs</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">//i&lt;=k&lt;=j，从k位置将[i...j]进行划分，视pk为[pi...pj]这棵子树的根</span>
        <span class="n">vs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">e</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">w</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="p">);</span>
      <span class="p">}</span>
      <span class="n">e</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">min_element</span><span class="p">(</span> <span class="n">vs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vs</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">//输出p1...p5的最优二叉查找树的期望查找代价</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">BestBinarySearchTree</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="mf">2.75</span>
</pre></div>
</div>
</div>
<div class="section" id="id21">
<h3>第16章：贪心算法<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h3>
<ul>
<li><dl class="first docutils">
<dt>贪心算法使所作的选择看起来都是当前最佳的，期望通所做的局部最优选择来产生一个全局最优解。</dt>
<dd><p class="first last">对算法中的每一个决策点，做一个当时看起来是最佳的选择，这种启发式策略并不是总能产生最优解的。</p>
</dd>
</dl>
</li>
<li><p class="first">贪心算法对大多数优化问题能产生较优解，但很多问题也不能通过这样的局部最优解得到全局最优解（0-1背包）。实际上， <strong>使用贪心算法最关键的就是在于如何证明贪心选择性质以证明当前的问题可以由贪心算法得到最优解</strong></p>
</li>
<li><dl class="first docutils">
<dt>在活动选择问题中，非常关键的一点先决条件就是：活动要先按照结束时间的单调递增顺序排序，这样才能贪心的选择第一个。</dt>
<dd><p class="first last">从直觉上来看，这种活动选择方法是一种”贪婪的”选择方法，它给后面剩下的待调度任务留下了尽可能多的机会。也就是说，此处的贪心选择使得剩下的、未调度的时间最大化</p>
</dd>
</dl>
</li>
<li><p class="first">可以说：动态规划其实是”安全的贪心算法”的基础。无论如何，在 <strong>每一个贪心算法的下面，几乎总是会有一个更加复杂的动态规划解</strong></p>
<dl class="docutils">
<dt>贪心算法实现简单速度快，但是 <strong>证明贪心的正确性往往是很困难的，所以说安全的（能够取得最优解的）贪心算法下面总有一个动态规划算法来证明其正确性</strong></dt>
<dd><p class="first last">所谓安全的贪心算法就是指一定能产生出全局最优解的贪心算法</p>
</dd>
</dl>
</li>
<li><p class="first">贪心算法的一般步骤（定义）</p>
<ul class="simple">
<li>将优化问题转化成这样的一个问题，即 <strong>先做出选择（对应于动态规划的先解决子问题再选择）</strong> ，再解决剩下的一个子问题。</li>
<li>证明原问题总是有一个最优解是做贪心选择得到的，从而说明贪心选择的安全。</li>
<li>说明在做出贪心选择后，剩余的子问题具有这样的一个性质。即如果将子问题的最优解和我们所做的贪心选择联合起来，就可以得出原问题的一个最优解。</li>
</ul>
</li>
<li><p class="first">正确使用贪心算法的2个关键要素： <strong>贪心选择性质和最优子结构:</strong></p>
<ul class="simple">
<li>贪心选择性质：一个全局最优解可以通过局部最优（贪心）选择来达到；这也是使用贪心算法中最难的一点，即证明贪心策略得能出最优解。</li>
<li>最优子结构：一个问题的最优解包含了其子问题的最优解。</li>
</ul>
</li>
<li><p class="first">要使用贪心算法就必须先证明以下两个性质：</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>每一步所做的贪心选择最终能产生一个全局最优解。</dt>
<dd>在证明中先考察一个全局最优解，然后证明对该解加以修改，使其采用贪心选择，这个选择将原问题变为一个相似的、但更小的问题。</dd>
</dl>
</li>
<li>子问题的最优解与所做的贪心选择合并后，的确可以得到原问题的一个最优解。</li>
</ul>
</li>
<li><p class="first">贪心算法所做的当前选择可能要依赖于已经做出的所有选择，但不依赖于有待于做出的选择或子问题的解。</p>
</li>
<li><p class="first">前缀编码：在所有的编码方案中，没有一个编码是另一个编码的前缀。</p>
</li>
<li><p class="first"><strong>一般地，就算证明不出来贪心算法能给出最优解，但是它一般都至少能给出次优解。所以贪心算法在实际的应用中是非常的普及的。</strong></p>
</li>
</ul>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     huffman_code.cpp</span>
<span class="cm"> * @brief    贪心算法：Huffman编码问题</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="p">{</span>
<span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
  <span class="n">Node</span> <span class="o">*</span><span class="n">Left</span><span class="p">,</span> <span class="o">*</span><span class="n">Right</span><span class="p">;</span>
  <span class="kt">char</span>  <span class="n">Char</span><span class="p">;</span>
  <span class="kt">double</span>  <span class="n">Value</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">ShowLeaf</span><span class="p">(</span> <span class="n">Node</span> <span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">code</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">root</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">Left</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">Right</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">//叶子结点了</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">Char</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; ===&gt; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">code</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">ShowLeaf</span><span class="p">(</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">Left</span><span class="p">,</span> <span class="n">code</span> <span class="o">+</span> <span class="s">&quot;0&quot;</span> <span class="p">);</span>
      <span class="n">ShowLeaf</span><span class="p">(</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">Right</span><span class="p">,</span> <span class="n">code</span> <span class="o">+</span> <span class="s">&quot;1&quot;</span> <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// @brief 使用贪心算法解决Huffman编码问题</span>
<span class="c1">///</span>
<span class="c1">/// 它的原理就是用不等长的编码来表示不同出现频率的字符。出现频率高的字符，就用比较短的编码来表示，出现频率低的，就是较长的编码来表示。</span>
<span class="kt">void</span> <span class="n">HuffmanCode</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">orgin_str</span> <span class="o">=</span> <span class="s">&quot;abcadbabacadbacdabadeabadabaewbadsafdsawebadsfasdfababadasdfabababcadb&quot;</span><span class="p">;</span>
  <span class="n">map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">frequency</span><span class="p">;</span>
  <span class="n">for_each</span><span class="p">(</span> <span class="n">orgin_str</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">orgin_str</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">c</span> <span class="p">)</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">frequency</span><span class="p">[</span><span class="n">c</span><span class="p">];</span>
  <span class="p">}</span> <span class="p">);</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span> <span class="o">*&gt;</span> <span class="n">nodes</span><span class="p">;</span>
  <span class="n">for_each</span><span class="p">(</span> <span class="n">frequency</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">frequency</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span> <span class="k">const</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">item</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">item</span><span class="p">.</span><span class="n">second</span> <span class="o">/=</span> <span class="n">orgin_str</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

    <span class="n">Node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">();</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">Value</span> <span class="o">=</span> <span class="n">item</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">Char</span> <span class="o">=</span> <span class="n">item</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
    <span class="n">nodes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">node</span> <span class="p">);</span>
  <span class="p">}</span> <span class="p">);</span>

  <span class="n">for_each</span><span class="p">(</span> <span class="n">frequency</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">frequency</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">char</span> <span class="k">const</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">item</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;:  &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">item</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span> <span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span> <span class="n">nodes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">//有超过一个结点，则循环</span>
    <span class="n">sort</span><span class="p">(</span> <span class="n">nodes</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nodes</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span> <span class="n">Node</span> <span class="o">*</span> <span class="n">n1</span><span class="p">,</span> <span class="n">Node</span> <span class="o">*</span> <span class="n">n2</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">n1</span><span class="o">-&gt;</span><span class="n">Value</span> <span class="o">&lt;</span> <span class="n">n2</span><span class="o">-&gt;</span><span class="n">Value</span><span class="p">;</span>
    <span class="p">}</span> <span class="p">);</span>

    <span class="n">Node</span> <span class="o">*</span><span class="n">new_node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">();</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">Left</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">Right</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">Value</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">Value</span> <span class="o">+</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">Value</span><span class="p">;</span>

    <span class="n">nodes</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span> <span class="n">nodes</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nodes</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">);</span>
    <span class="n">nodes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">new_node</span> <span class="p">);</span>
  <span class="p">}</span>

  <span class="n">ShowLeaf</span><span class="p">(</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;&quot;</span> <span class="p">);</span>
<span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">HuffmanCode</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="nl">a</span><span class="p">:</span>  <span class="mf">0.357143</span>
<span class="nl">b</span><span class="p">:</span>  <span class="mf">0.214286</span>
<span class="nl">c</span><span class="p">:</span>  <span class="mf">0.0571429</span>
<span class="nl">d</span><span class="p">:</span>  <span class="mf">0.171429</span>
<span class="nl">e</span><span class="p">:</span>  <span class="mf">0.0428571</span>
<span class="nl">f</span><span class="p">:</span>  <span class="mf">0.0571429</span>
<span class="nl">s</span><span class="p">:</span>  <span class="mf">0.0714286</span>
<span class="nl">w</span><span class="p">:</span>  <span class="mf">0.0285714</span>
<span class="n">d</span> <span class="o">===&gt;</span> <span class="mo">00</span>
<span class="n">b</span> <span class="o">===&gt;</span> <span class="mo">01</span>
<span class="n">c</span> <span class="o">===&gt;</span> <span class="mi">1000</span>
<span class="n">f</span> <span class="o">===&gt;</span> <span class="mi">1001</span>
<span class="n">s</span> <span class="o">===&gt;</span> <span class="mi">1010</span>
<span class="n">w</span> <span class="o">===&gt;</span> <span class="mi">10110</span>
<span class="n">e</span> <span class="o">===&gt;</span> <span class="mi">10111</span>
<span class="n">a</span> <span class="o">===&gt;</span> <span class="mi">11</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     neatly_print.cpp</span>
<span class="cm"> * @brief    整齐打印问题</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="p">{</span>
<span class="c1">/// @brief 整齐打印的贪心算法</span>
<span class="c1">///</span>
<span class="c1">/// 可以证明：以于整齐打印问题，贪心算法能够得到最优解！</span>
<span class="kt">int</span> <span class="n">NeatlyPrintViaGreedy</span><span class="p">(</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">words</span><span class="p">,</span> <span class="kt">int</span> <span class="k">const</span> <span class="n">max_length</span> <span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">cost</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">split_pos</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">current_line_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">add_char_num</span> <span class="o">=</span> <span class="p">(</span> <span class="n">current_line_length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">:</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">add_char_num</span> <span class="o">+</span> <span class="n">current_line_length</span> <span class="o">&lt;=</span> <span class="n">max_length</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">//当前行放得下</span>
      <span class="n">current_line_length</span> <span class="o">+=</span> <span class="n">add_char_num</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">//当前行已经放不下了，换行</span>
      <span class="n">split_pos</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">i</span> <span class="p">);</span>
      <span class="n">cost</span> <span class="o">+=</span> <span class="n">pow</span><span class="p">(</span> <span class="p">(</span> <span class="n">max_length</span> <span class="o">-</span> <span class="n">current_line_length</span> <span class="p">),</span> <span class="mf">1.0</span> <span class="p">);</span>
      <span class="n">current_line_length</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">current_line_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">split_pos</span><span class="p">.</span><span class="n">find</span><span class="p">(</span> <span class="n">i</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">split_pos</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">//换行</span>
      <span class="n">string</span> <span class="n">space</span><span class="p">(</span> <span class="n">max_length</span> <span class="o">-</span> <span class="n">current_line_length</span><span class="p">,</span> <span class="sc">&#39; &#39;</span> <span class="p">);</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">space</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;|&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="n">current_line_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">current_line_length</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="n">current_line_length</span> <span class="o">+=</span> <span class="p">(</span> <span class="n">current_line_length</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">:</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">cost</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// @brief 错误的整齐打印的动态规划算法</span>
<span class="c1">///</span>
<span class="c1">/// 这是网上流传的关于本题的解法，经验证是错误的、毫无道理的！\n</span>
<span class="c1">/// 动态规划得到的应该是最优解，而不是次优解。在这里动态规划的结果还没有贪心算法好，这个动态规划是完全错误的！\n</span>
<span class="c1">/// 而且这个所谓的动态规划所使用的解递推公式实在是不可理喻！毫无道理！\n</span>
<span class="kt">int</span> <span class="n">NeatlyPrintViaDyanmicProgrammingWrong</span><span class="p">(</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">words</span><span class="p">,</span> <span class="kt">int</span> <span class="k">const</span> <span class="n">max_length</span> <span class="p">)</span> <span class="p">{</span>
  <span class="c1">//cost[i]表示[0..i]单词的最小代价</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">cost</span><span class="p">(</span> <span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>

  <span class="c1">//w[i][j]表示把第[i,j]个单词放入到一行时，该行还剩下的空格的立方。</span>
  <span class="c1">//如果一行放不下这么多字符，则w[i][j]为正无穷；当i&gt;j时，w[i][j]为默认值0。</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">w</span><span class="p">(</span> <span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">)</span> <span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span> <span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">least_length</span> <span class="o">=</span> <span class="n">max_length</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">least_length</span> <span class="o">-=</span> <span class="n">words</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
      <span class="p">}</span>
      <span class="n">least_length</span> <span class="o">-=</span> <span class="p">(</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="p">);</span>  <span class="c1">//还有空格需要注意</span>

      <span class="k">if</span> <span class="p">(</span> <span class="n">least_length</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span> <span class="n">least_length</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vi</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">//从words[k]之后进行分行</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">w</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">vi</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">cost</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">w</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
      <span class="p">}</span>

    <span class="p">}</span>
    <span class="k">auto</span> <span class="n">min_iter</span> <span class="o">=</span> <span class="n">min_element</span><span class="p">(</span> <span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vi</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span>
    <span class="n">cost</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">min_iter</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">cost</span><span class="p">[</span><span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
<span class="p">}</span>



<span class="c1">/// @brief 正确的整齐打印的动态规划算法</span>
<span class="c1">///</span>
<span class="c1">/// 动态规划得到的应该是最优解，而不是次优解。\n</span>
<span class="c1">/// 这是本题的正确解法，该动态规划的结果与贪心算法的结果相同，同样也验证了对于本题来说：贪心算法能够给出最优解！\n</span>
<span class="kt">int</span> <span class="n">NeatlyPrintViaDyanmicProgramming</span><span class="p">(</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">words</span><span class="p">,</span> <span class="kt">int</span> <span class="k">const</span> <span class="n">max_length</span> <span class="p">)</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

  <span class="c1">//一个区间的信息</span>
  <span class="k">struct</span> <span class="n">Message</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">Cost</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">FirstLineCharNumber</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">LastLineCharNumber</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">LineNumber</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span> <span class="n">Message</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">other</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Cost</span> <span class="o">&lt;</span> <span class="n">other</span><span class="p">.</span><span class="n">Cost</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">};</span>
  <span class="c1">//c[i][j]表示[i,j]个单词之间的整齐打印信息</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;&gt;</span> <span class="n">c</span><span class="p">(</span> <span class="n">size</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">size</span> <span class="p">)</span> <span class="p">);</span>

  <span class="c1">//预处理长度为1（即单个点）的情况</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">Cost</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">FirstLineCharNumber</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
    <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">LastLineCharNumber</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
    <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">LineNumber</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">//递推长度&gt;1时的情况</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">length</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">-</span> <span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
      <span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

      <span class="n">vector</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span> <span class="n">vi</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">//将c[i][j]分为c[i][k]、c[k+1][j]两个部分</span>
        <span class="n">Message</span> <span class="n">a_message</span><span class="p">;</span>
        <span class="c1">//c[i][k]、c[k+1][j]两部分的首尾行是否能结合为一行</span>
        <span class="kt">bool</span>  <span class="n">can_link_2_parts</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">].</span><span class="n">LastLineCharNumber</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">FirstLineCharNumber</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">max_length</span><span class="p">;</span>

        <span class="c1">//LineNumber</span>
        <span class="n">a_message</span><span class="p">.</span><span class="n">LineNumber</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">].</span><span class="n">LineNumber</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">LineNumber</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">can_link_2_parts</span> <span class="p">)</span> <span class="p">{</span>
          <span class="c1">//首尾两行能结合为一行</span>
          <span class="o">--</span><span class="n">a_message</span><span class="p">.</span><span class="n">LineNumber</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">//FirstLineCharNumber</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">can_link_2_parts</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">].</span><span class="n">LineNumber</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
          <span class="c1">//首尾两行能结合为一行 且 前部分只有一行</span>
          <span class="n">a_message</span><span class="p">.</span><span class="n">FirstLineCharNumber</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">].</span><span class="n">FirstLineCharNumber</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">FirstLineCharNumber</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">a_message</span><span class="p">.</span><span class="n">FirstLineCharNumber</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">].</span><span class="n">FirstLineCharNumber</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">//LastLineCharNumber</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">can_link_2_parts</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">LineNumber</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
          <span class="c1">//首尾两行能结合为一行 且 后部分只有一行</span>
          <span class="n">a_message</span><span class="p">.</span><span class="n">LastLineCharNumber</span> <span class="o">=</span> <span class="p">(</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">].</span><span class="n">LastLineCharNumber</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">FirstLineCharNumber</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">a_message</span><span class="p">.</span><span class="n">LastLineCharNumber</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">LastLineCharNumber</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">//Cost</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">can_link_2_parts</span> <span class="p">)</span> <span class="p">{</span>
          <span class="c1">//首尾两行能结合为一行</span>
          <span class="n">a_message</span><span class="p">.</span><span class="n">Cost</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">].</span><span class="n">Cost</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">Cost</span> <span class="o">+</span> <span class="p">(</span> <span class="n">max_length</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">].</span><span class="n">LastLineCharNumber</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">FirstLineCharNumber</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">a_message</span><span class="p">.</span><span class="n">Cost</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">].</span><span class="n">Cost</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">].</span><span class="n">Cost</span> <span class="o">+</span> <span class="p">(</span> <span class="n">max_length</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">].</span><span class="n">LastLineCharNumber</span> <span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">a_message</span><span class="p">.</span><span class="n">LineNumber</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
          <span class="c1">//因为最后一行的空格不算作代价</span>
          <span class="n">a_message</span><span class="p">.</span><span class="n">Cost</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">vi</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">a_message</span> <span class="p">);</span>
      <span class="p">}</span>

      <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">min_element</span><span class="p">(</span> <span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vi</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">Cost</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// @brief 整齐打印</span>
<span class="c1">///</span>
<span class="c1">/// 题目描述：考虑在一个打印机上整齐地打印一段文章的问题。输入的正文是n个长度分别l[1], l[2], ..., l[n]（以字符个数度量）的单词构成的序列。</span>
<span class="c1">/// 我们希望将这个段落在一些行上整齐地打印出来，每行至多M个字符。“整齐度”的标准如下。如果某一行包含从i到j的单词，i&lt;j，且单词之间只留一个空，</span>
<span class="c1">/// 则在行末多余的空格字符个数为M-j+i-∑(k=i to j)l[k]，它必须是非负值才能让该行容纳这些单词。我们希望所有行（除了最后一行）的行末多余空格</span>
<span class="c1">/// 字符个数的立方的总和最小。请给出一个动态规划算法，来在打印机上整齐地打印出一段有n个单词的文章。</span>
<span class="kt">void</span> <span class="n">NeatlyPrint</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">//随机生成正文中字符串</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">words</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">//任意字符串长度为1..10</span>
    <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">string</span> <span class="n">a_word</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">a_word</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="sc">&#39;a&#39;</span> <span class="o">+</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">26</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">words</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">a_word</span> <span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">//一行的最大字符数，要保证k_MAX_LENGTH大于任意一个单词的长度，否则无法放下</span>
  <span class="kt">int</span> <span class="k">const</span> <span class="n">k_MAX_LEGNTH</span> <span class="o">=</span> <span class="mi">48</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;贪心算法得出的最小代价（除了最后一行）为：&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">NeatlyPrintViaGreedy</span><span class="p">(</span> <span class="n">words</span><span class="p">,</span> <span class="n">k_MAX_LEGNTH</span> <span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;动态规划得出的最小代价（除了最后一行）为：&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">NeatlyPrintViaDyanmicProgramming</span><span class="p">(</span> <span class="n">words</span><span class="p">,</span> <span class="n">k_MAX_LEGNTH</span> <span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;网上流传的错误的动态规划算法得出的最小代价（除了最后一行）为：&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">NeatlyPrintViaDyanmicProgrammingWrong</span><span class="p">(</span> <span class="n">words</span><span class="p">,</span> <span class="n">k_MAX_LEGNTH</span> <span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">NeatlyPrint</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>wlrb mqbhcd r owkk hiddqsc xrjm wfr sjyb dbef   |
arcbynecd ggx pklore lnmpapqfwk opkm oqhnwnkue  |
hsqmgbbuq ljjivswmd q bx xmvtr bljptnsn wzqf    |
mafadrrwso sbcnuv hffbsaq wp c cehch vf         |
kmlnozjkpq xrjxki zyxa bhhki q oendtomfg wdwf   |
gpxiq kuytdlcgde htaciohor tq vwcsgspqo msb agu |
nny xnzlgdgwp trwblnsade guumoqc rubetoky       |
hoachwdvmx rdryxl n qtukwa mleju kwcib ubumen   |
eyatdrmyd ajxlo h q mzhlvihjou suyoypayul eim   |
otehzri c skpggkbb p zrzu xamludf kgruowz i     |
oobpple lwphapjna qhdcnvwdtx bmyppp auxnspus d  |
iixqmbfjxj v djsuyib ebmws q oygyxym evypzvje   |
ebeocfu tsxdixtigs e hkchzdf ilrjqfnx tqrs bs   |
kyhsenbppk t ddbuotbb cwi rf ju jd nt e q
贪心算法得出的最小代价（除了最后一行）为：48
动态规划得出的最小代价（除了最后一行）为：48
网上流传的错误的动态规划算法得出的最小代价（除了最后一行）为：60
</pre></div>
</div>
</div>
<div class="section" id="id22">
<h3>第17章：平摊分析<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h3>
<ul>
<li><p class="first">平摊代价： <strong>N个操作的总平摊代价即为这N个操作的总实际代价的上界</strong></p>
</li>
<li><dl class="first docutils">
<dt>在平摊分析中，执行一系列数据结构操作所需要的时间是通过对执行所有操作所花费的时间求平均而得到的。</dt>
<dd><p class="first last">平摊分析与平均情况分析的不同之处在于它不牵涉到概率；平摊分析保证在最坏情况下，每个操作具有平均性能。</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>平摊分析表明： <strong>并不能总以最坏情况来衡量算法，因为最坏的情况并不总会发生，而且在绝大多数应用中最坏情况出现的次数一定是很少很少的。</strong></dt>
<dd><p class="first last">最明显的例子就是 <code class="docutils literal notranslate"><span class="pre">C++</span> <span class="pre">STL中vector.push_back</span></code> 操作。</p>
</dd>
</dl>
</li>
<li><p class="first">通过平摊分析，可以获得对某种特定数据结构的认识，这种认识有助于优化设计。</p>
</li>
<li><p class="first">三种方法进行平摊分析：</p>
<ul class="simple">
<li>聚集分析：就是指分析一系列操作的总时间</li>
<li>记账法：对每次操作的对象进行预先记账</li>
<li>势能方法：与记账法类似，但是将每次预留的势能视为是整个数据结构共享的</li>
</ul>
</li>
<li><dl class="first docutils">
<dt>聚集分析：由N个操作所构成的序列的总时间在最坏的情况下为T(n)，则每个操作的平均代价（平摊代价）为T(n)/n。</dt>
<dd><p class="first last">以前的时间复杂度分析都是以单次操作为对象的分析它的最坏时间复杂度，而聚集分析所分析的是N次操作的总时间的最坏情况。应注意其与平均情况分析的不同之处！</p>
</dd>
</dl>
<p>聚集分析：由序列的总最坏时间推导单次的平摊时间</p>
</li>
<li><p class="first">记账法：对序列操作中的每一个操作收取一定的费用，当所收取的费用比它实际应支付的费用多时就把多余的部分当作存款存起来，一个操作的平摊代价可以看作两部分：实际代价和存款（或被储蓄或被用完）。</p>
<ul class="simple">
<li>存款可以用来在以后补偿那些其平摊代价低于其实际代价的操作。</li>
<li>如果希望通过对平摊代价的分析来说明每次操作的最坏情况平均代价较小，则操作序列的总平摊代价就必须是该序列的总的实际代价的一个上界。因为平摊代价是最坏时的平均代价，这意味着：只能有存款而不能有欠账！</li>
<li>明白这个存款不能为负很重要，因为这种分析方法是不允许欠账的，否则就不能满足平摊代价是操作总时间的最坏情况的平均这个定义。</li>
<li>Eg: 对于栈的操作，当每次入栈时记账支付2元，1元支付该PUSH操作的实际代价，还有1元用于支付该元素被POP出来时的代价。则可以保证在任何时间内都不会有欠账，POP操作可以不收取任何费用。</li>
</ul>
</li>
<li><dl class="first docutils">
<dt>势能方法：将已预付的工作作为一种”势能”保存，它在需要时可以释放出来，以支付后面的操作。势能是与整个数据结构而不是其中的个别对象发生联系的。</dt>
<dd><p class="first last">（记账法中的账与个别对象发生联系，比如栈操作时支付的2元就记在入栈的那个元素上）</p>
</dd>
</dl>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">动态表：比如C++</span> <span class="pre">STL中的vector</span></code></p>
<ul>
<li><p class="first">可以通过平摊分析证明：插入和删除操作的平摊代价都仅为O(1)</p>
</li>
<li><p class="first">表扩张时：常用的启发式（启发信息就是容器原来的大小）方法是分配一个原表两倍大小的新表。</p>
</li>
<li><dl class="first docutils">
<dt>可以通过聚集分析来证明插入操作的平摊代价：</dt>
<dd><p class="first last"><span class="math notranslate nohighlight">\(\sum_{i=1}^N C_i \le N + \sum_{j=0}^{\llcorner lgN \lrcorner} 2^j &lt; n + 2n =3n\)</span></p>
</dd>
</dl>
<p>所以每次操作的平摊代价为O(1)=3</p>
</li>
<li><p class="first">通过记账法来证明插入、删除操作的平摊代价：</p>
<ul>
<li><p class="first">插入操作：每次插入操作需要支付3元的代价，分别是：将其自身插入到当前表中、当表扩张时其自身的移动、以及对另一个在扩张表时已经移动过的另一项的移动。于1+1+1=3元的代价</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="54%" />
<col width="46%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>原有的元素……</td>
<td>NewItem</td>
</tr>
<tr class="row-even"><td>在原有的元素里还要再支付一个可能移动的代价</td>
<td>支付自身以后可能的移动操作的代价</td>
</tr>
</tbody>
</table>
</div></blockquote>
</li>
<li><p class="first">并且可以证明：无论扩张时分配多少倍的新空间，每次插入操作的平摊代价都大于2。所以标准库中取每次扩张时进行翻倍，这是一个均衡的很好的选择。</p>
</li>
<li><p class="first">删除操作：</p>
<ul>
<li><dl class="first docutils">
<dt>C++STL的vector不会在删除元素时进行自动收缩。假设如果在元素不足1/2时进行收缩，最坏时会产生在这种情况（来回收缩和扩张）：</dt>
<dd><p class="first last">在一次扩张之后，还没有做足够的删除来支付一次收缩的代价。类似地，在一次收缩之后，也有可能没有做足够的插入来支付一次扩张的代价。
<strong>所以C++ vector选择了在删除元素时不自动收缩来回避这个问题</strong> 。如果要进行收缩，应该是元素减少为1/4时进行自动收缩，这样才能保证在表收缩之后有足够的存款进行支付一次收缩的代价。</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>当删除至1/4个元素时进行自动收缩的平摊代价分析：</dt>
<dd><p class="first">每次删除操作需要支付的代价为：其自身的删除操作代价和剩下的元素可能进行的移动操作的代价。
即最坏为：1 + 1 = 2元的代价，最好为1 + 0.33333 = 1.3333元的代价，取最坏情况为2元。</p>
<table border="1" class="last docutils">
<colgroup>
<col width="26%" />
<col width="24%" />
<col width="25%" />
<col width="24%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>剩下的元素……</td>
<td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>还要再支付一个可能移动的代价</td>
<td>&#160;</td>
<td>最早可能从这开始删除</td>
<td>最晚可能从这开始删除</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</li>
</ul>
</li>
<li><p class="first">因此： <strong>对于动态表的插入和删除操作而言，每个操作的平摊代价都有一个常数的上界。</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="id23">
<h2>第五部分：高级数据结构<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>B树是一种被设计成专门存储在磁盘上的平衡查找树。因为磁盘的速度远远慢于内存，所以B树被设计成尽量减少磁盘访问的次数，
知道了这一点之后就会很清楚明白B树的变形B+树了，B＋树通过将数据存储在叶子结点从而增大了一个结点所包含的信息进而更加的减少了磁盘的访问次数。</li>
<li>可合并堆：这种堆支持Insert,Mininum,Extract-Min,union,delete,decrease-key操作。</li>
<li>二项堆能够在O(lgn)的最坏情况时间内支持以上的各种操作。当必须支持union操作时，二项堆优越于二叉堆，因为后者在最坏情况下，合并两个二叉堆要花O(n)的时间。</li>
<li>斐波那契堆对于以上各种除了extract-min,delete的操作外都只需要O(1)的实际时间，而extract-min,delete也只需要O(lgn)的平摊时间。它的重要优点在于decrease-key也只需要O(1)的平摊时间。
注意斐波那契堆的一些操作都只是平摊时间，并非最坏情况时间。现代的快速图算法中，很多是使用斐波那契堆作为其核心数据结构的。</li>
<li>不相交集合（查并集）：通过用一棵简单的有根树来表示每个集合，就可以得到惊人的快速操作：一个由m个操作构成的序列的运行时间为O(n α(n) )，而对于宇宙中的原子数总和n，α(n)也&lt;=4，所以可以认为实际时间是O(n)。</li>
</ul>
<div class="section" id="b">
<h3>第18章：B树<a class="headerlink" href="#b" title="永久链接至标题">¶</a></h3>
<ul>
<li><p class="first">B树与红黑树类似，但是在 <strong>降低磁盘的I/O次数</strong> 方面要更好一些。所以B树一般都是应用于磁盘操作的系统中。</p>
</li>
<li><p class="first">B树思想产生在背景：就是大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的（如果元素数量非常多的话，查找就退化成节点内部的线性查找了），这样导致二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下（因为读取一次磁盘相当于访问了无数次内存！），那么如何减少树的深度（当然是不能减少查询的数据量），一个基本的、很自然的想法就是：采用多叉树结构（由于树节点元素数量是有限的，自然该节点的子树数量也就是有限的） <a class="footnote-reference" href="#id39" id="id24">[5]</a></p>
</li>
<li><p class="first">在大多数系统中，B树算法的运行时间主要由它所执行的disk-read和disk-write操作的次数所决定，因而应该有效地使用这两种操作，即让它们读取更多的信息更少的次数。
由于这个原因，在B树中，一个结点的大小通常相当于一个完整的磁盘页。因此，一个B树结点可以拥有的子女数就由磁盘页的大小所决定。</p>
</li>
<li><p class="first">很明显：B树的分支因子越大越好，因为这样运行时间的绝大部分都是由磁盘存取次数决定的。分支因子越大，需要进行的磁盘存取次数就越少。
但是这个分支因子是有限制的，一个结点的总大小不能大于磁盘中一个页的大小，否则在一个结点内操作时还要来回访问内存，反而会拖慢效率。</p>
</li>
<li><p class="first">一个常见的B树的变形，称作为B＋树，所有的附属数据都保存在叶结点中，只将关键字和子女指针保存于内结点里，因此最大化了内结点的分支因子。</p>
</li>
<li><p class="first">B 树又叫平衡多路查找树。一棵t（t&gt;=2，t是B树的最小度数）阶的B 树的特性如下：</p>
<img alt="../../_images/btree.jpg" src="../../_images/btree.jpg" />
<ul class="simple">
<li>每个叶子结点具有相同的深度，即树的高度h。</li>
<li>每一个结点能包含的关键字数有一个上界和下界，这些界可用B树的最小度数t来表示（t-1 &lt;= n &lt;= 2t-1）：<ul>
<li>每个非根的结点必须至少含有t-1个关键字。每个非根的内结点至少有t个子女。如果树是非空的，则根结点至少包含一个关键字（同时意味着2个子女，根结点的下限永远是1个关键字，2个女子）；</li>
<li>每个结点可包含至多2t-1个关键字。所以一个内结点至多可有2t个子女。如果一个结点恰好有2t-1个关键字，我们就说这个结点是满的；</li>
</ul>
</li>
<li>每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，……，Kn，Pn)。其中：<ul>
<li>Ki (i=1…n)为关键字，且关键字按顺序升序排序K(i-1)&lt; Ki。</li>
<li>Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。</li>
<li>关键字的个数n必须满足：t-1 &lt;= n &lt;= 2t-1。</li>
</ul>
</li>
</ul>
</li>
<li><p class="first">当t=2时为最简单的B树，又称为2-3-4树，即每个结点的孩子数可能为2,3,4个；包含的关键字个数为1,2,3个。</p>
</li>
<li><dl class="first docutils">
<dt>与红黑树相比，这里我们看到了B树的能力，虽然两者的高度都以O(lgn)的速度增长，但对于B树来说底要大很多倍。对大多数的树的操作来说，要查找的结点数在B树中要比红黑树中少大约lgt的因子。因为在树中查找任意一个结点通常需要一次磁盘存取，所以磁盘存取的次数大大的减少了。</dt>
<dd><p class="first last">如果让我来实现一个数据库系统，我肯定也会选取类似B树的数据结构作为基本。</p>
</dd>
</dl>
</li>
<li><p class="first">B树首先一是棵查找树，所以它的查找操作将会非常简单和高效。</p>
</li>
<li><p class="first"><strong>B树的插入操作</strong> ：插入操作一定发生在叶子结点，因为B树首先必须是一棵查找树。</p>
<p>这是我的代码所使用的思路：因为插入操作肯定是在叶子结点上进行的,首先顺着书向下走直到要进行插入操作的叶子结点将新值插入到该叶子结点中去. 如果因为这个插入操作而使用该结点的值的个数&gt;2*t-1的上界，就需要递归向上进行分裂操作。如果分裂到了根结点，还要处理树长高的情况。这种思路简单，但不是很高效，因为经过了两趟，一趟向下；一趟向上。</p>
<p>《算法导论》上介绍的方法则比较好：边下行边分裂，当沿着树往下查找新关键字时所属位置时，就分裂沿途遇到的每个满结点（包含叶结点本身）。因此每当要分裂一个满结点时，就能确保它的双亲不是满的。这种方法只需要一趟就可以完成，极大的减少磁盘的读取次数，而这正是B树所设计追求的，因而这种一趟的方法是更优的！</p>
<p>但是我的代码只实现了我自己的简单方法，书上的方法实现起来应该也不难。</p>
</li>
<li><p class="first">插入操作时B树的分裂是B树升高的唯一途径！</p>
</li>
<li><p class="first"><strong>B树的删除操作</strong> ：删除操作稍微复杂一些，因为删除操作不仅仅会发生在叶子结点，还可能会发生在内结点，这与插入操作不同。但是可以通过一个技巧消除这一点，找到要删除结点的前驱，然后与要删除的结点的关键值进行对调，再删除这个前驱结点就可以保证每次要删除的都是叶子结点。</p>
<p>同样有可以进行边下行边合并的快速方法，而同样，我这里的代码也没有实现这种快速的方法，而是选用了传统的两趟的删除方法，具体如下：</p>
<p>任一关键字K的中序前趋(后继)必是K的左子树(右子树)中最右(左)下的结点中最后(最前)一个关键字。根据B树的性质：B树上每一个结点的Key的个数必须为[t-1, 2*t-1]之间，所以这里的Min = t - 1。若被删关键字K所在的结点非树叶，则用K的中序前趋(或后继)K’取代K，然后从叶子中删去K’。从叶子*x开始删去某关键字K的三种情形为：</p>
<ul class="simple">
<li>情形一：若x-&gt;keynum&gt;Min，则只需删去K及其右指针(*x是叶子，K的右指针为空)即可使删除操作结束。</li>
<li>情形二：若x-&gt;keynum=Min，该叶子中的关键字个数已是最小值，删K及其右指针后会破坏B-树的性质(3)。若*x的左(或右)邻兄弟结点*y中的关键字数目大于Min，则将*y中的最大(或最小)关键字上移至双亲结点*parent中，而将*parent中相应的关键字下移至x中。显然这种移动使得双亲中关键字数目不变；*y被移出一个关键字，故其keynum减1，因它原大于Min，故减少1个关键字后keynum仍大于等于Min；而*x中已移入一个关键字，故删K后*x中仍有Min个关键字。涉及移动关键字的三个结点均满足B-树的性质(3)。 请读者验证，上述操作后仍满足B-树的性质(1)。移动完成后，删除过程亦结束。</li>
<li>情形三：若*x及其相邻的左右兄弟(也可能只有一个兄弟)中的关键字数目均为最小值Min，则上述的移动操作就不奏效，此时须*x和左或右兄弟合并。不妨设*x有右邻兄弟*y(对左邻兄弟的讨论与此类似)，在*x中删去K及其右子树后，将双亲结点*parent中介于*x和*y之间的关键字K，作为中间关键字，与并x和*y中的关键字一起”合并”为一个新的结点取代*x和*y。因为*x和*y原各有Min个关键字，从双亲中移人的K’抵消了从*x中删除的K，故新结点中恰有2Min(即2「m/2」-2≤m-1)个关键字，没有破坏B-树的性质(3)。但由于K’从双亲中移到新结点后，相当于从*parent中删去了K’，若parent-&gt;keynum原大于Min，则删除操作到此结束；否则，同样要通过移动*parent的左右兄弟中的关键字或将*parent与其 左右兄弟合并的方法来维护B-树性质。最坏情况下，合并操作会向上传播至根，当根中只有一个关键字时，合并操作将会使根结点及其两个孩子合并成一个新的根，从而使整棵树的高度减少一层。</li>
</ul>
</li>
<li><p class="first">删除操作看似复杂，但是对一棵高度为h的B树，它只需要O(h)次磁盘操作，因为在递归调用的过程之间，仅需要O(1)次对disk-read,disk-write的调用，时间复杂度为O(th)=O(tlogtn).</p>
</li>
</ul>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     B_tree.cpp</span>
<span class="cm"> * @brief    B树</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;graphviz_shower.h&quot;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="c1">/// @brief B树</span>
<span class="c1">///</span>
<span class="c1">/// B-树是&lt;b&gt;二叉排序树&lt;/b&gt;的推广\n</span>
<span class="c1">/// 一棵t(t≥2，t为B树的最小度数)阶的B-树是满足如下性质的m叉树：\n</span>
<span class="c1">/// - 每个结点至少包含下列数据域：\n</span>
<span class="c1">///    (j，P0，Kl，P1，K2，…，Ki，Pi)\n</span>
<span class="c1">///    其中：\n</span>
<span class="c1">///    - j为关键字总数</span>
<span class="c1">///    - Ki(1≤i≤j)是关键字，关键字序列递增有序：K1 &lt;K2&lt;…&lt;Ki。</span>
<span class="c1">///    - Pi(0≤i≤j)是孩子指针。对于叶结点，每个Pi为空指针。</span>
<span class="c1">///    - 注意：</span>
<span class="c1">///      - 实用中为节省空间，叶结点中可省去指针域Pi，但必须在每个结点中增加一个标志域leaf，其值为真时表示叶结点，</span>
<span class="c1">///      否则为内部结点。</span>
<span class="c1">///      - 在每个内部结点中，假设用keys(Pi)来表示子树Pi中的所有关键字，则有：\n</span>
<span class="c1">///         　　　　　　　keys(P0)&lt;K1&lt;keys(P1)&lt;K2&lt;…&lt;Ki&lt;keys(Pi)\n</span>
<span class="c1">///        即关键字是分界点，任一关键字Ki左边子树中的所有关键字均小于Ki，右边子树中的所有关键字均大于Ki。</span>
<span class="c1">///</span>
<span class="c1">///  - 所有叶子是在同一层上，叶子的层数为树的高度h。</span>
<span class="c1">///  - 每个非根结点中所包含的关键字个数j满足：\n</span>
<span class="c1">///      t - 1 ≤ j ≤ 2*t - 1\n</span>
<span class="c1">///    即每个非根结点至少应有 t-1 个关键字，至多有 2*t-1 个关键字。\n</span>
<span class="c1">///    因为每个内部结点的度数正好是关键字总数加1，故每个非根的内部结点至少有t个子树，至多有2*t棵子树。\n</span>
<span class="c1">///  - 若树非空，则根至少有1个关键字，故若根不是叶子，则它至少有2棵子树。根至多有2*t-1个关键字，故至多有2*t棵子树。\n</span>
<span class="k">class</span> <span class="nc">BTree</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">/// B树中的一个结点</span>
  <span class="k">struct</span> <span class="n">BTreeNode</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>      <span class="n">Keys</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">BTreeNode</span> <span class="o">*&gt;</span>  <span class="n">Childs</span><span class="p">;</span>
    <span class="n">BTreeNode</span>      <span class="o">*</span><span class="n">Parent</span><span class="p">;</span>    <span class="c1">///&lt; 父结点。当该结点是树的根结点时，Parent结点为nullptr</span>
    <span class="kt">bool</span>        <span class="n">IsLeaf</span><span class="p">;</span>      <span class="c1">///&lt; 是否为叶子结点</span>

    <span class="n">BTreeNode</span><span class="p">()</span> <span class="o">:</span> <span class="n">Parent</span><span class="p">(</span> <span class="k">nullptr</span> <span class="p">),</span> <span class="n">IsLeaf</span><span class="p">(</span> <span class="nb">true</span> <span class="p">)</span> <span class="p">{}</span>

    <span class="kt">size_t</span> <span class="n">KeysSize</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">Keys</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="c1">/// 构造一棵最小度为t的B树(t&gt;=2)</span>
  <span class="n">BTree</span><span class="p">(</span> <span class="kt">int</span> <span class="n">t</span> <span class="p">)</span> <span class="o">:</span> <span class="n">_root</span><span class="p">(</span> <span class="k">nullptr</span> <span class="p">),</span> <span class="n">_t</span><span class="p">(</span> <span class="n">t</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="p">);</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">BTree</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">_ReleaseNode</span><span class="p">(</span> <span class="n">_root</span> <span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">/// @brief B树的查找操作</span>
  <span class="c1">///</span>
  <span class="c1">/// 在B-树中查找给定关键字的方法类似于二叉排序树上的查找。不同的是在每个结点上确定向下查找的路径不一定是二路而是</span>
  <span class="c1">/// keynum+1路的。\n</span>
  <span class="c1">/// 实现起来还是相当容易的!</span>
  <span class="n">pair</span><span class="o">&lt;</span><span class="n">BTreeNode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">Search</span><span class="p">(</span> <span class="kt">int</span> <span class="n">key</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_SearchInNode</span><span class="p">(</span> <span class="n">_root</span><span class="p">,</span> <span class="n">key</span> <span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">/// @brief 插入一个值的操作</span>
  <span class="c1">///</span>
  <span class="c1">/// 这里没有使用《算法导论》里介绍的一趟的方法，而是自己想象出来的二趟的方法</span>
  <span class="c1">/// 效率肯定不如书上介绍的一趟优美，但是能解决问题。\n</span>
  <span class="c1">/// 因为插入操作肯定是在叶子结点上进行的,首先顺着书向下走直到要进行插入操作的叶子结点将新值插入到该叶子结点中去.</span>
  <span class="c1">/// 如果因为这个插入操作而使用该结点的值的个数&gt;2*t-1的上界，就需要递归向上进行分裂操作。</span>
  <span class="c1">/// 如果分裂到了根结点，还要处理树长高的情况。\n</span>
  <span class="c1">/// 树只有在进行分裂操作时才会长高！</span>
  <span class="kt">bool</span> <span class="n">Insert</span><span class="p">(</span> <span class="kt">int</span> <span class="n">new_key</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">_root</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="p">)</span> <span class="p">{</span> <span class="c1">//空树</span>
      <span class="n">_root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BTreeNode</span><span class="p">();</span>
      <span class="n">_root</span><span class="o">-&gt;</span><span class="n">IsLeaf</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="n">_root</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">new_key</span> <span class="p">);</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">Search</span><span class="p">(</span> <span class="n">new_key</span> <span class="p">).</span><span class="n">first</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="p">)</span> <span class="p">{</span> <span class="c1">//是否已经存在该结点</span>
      <span class="n">BTreeNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">_root</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span> <span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">IsLeaf</span> <span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">new_key</span> <span class="o">&gt;=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">)</span> <span class="p">{</span>
          <span class="o">++</span><span class="n">index</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
      <span class="p">}</span>

      <span class="c1">//插入到Keys里去</span>
      <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">find_if</span><span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">bind2nd</span><span class="p">(</span> <span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">new_key</span> <span class="p">)</span> <span class="p">),</span> <span class="n">new_key</span> <span class="p">);</span>

      <span class="c1">//再递归向上处理结点太大的情况</span>
      <span class="k">while</span> <span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">KeysSize</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">_t</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">//=====开始分裂======</span>
        <span class="kt">int</span> <span class="n">prove_node_key</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">KeysSize</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>      <span class="c1">// 要提升的结点的key</span>

        <span class="c1">//后半部分成为一个新节点</span>
        <span class="n">BTreeNode</span> <span class="o">*</span><span class="n">new_node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BTreeNode</span><span class="p">();</span>
        <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">IsLeaf</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">IsLeaf</span><span class="p">;</span>
        <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">KeysSize</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span>
        <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span> <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">);</span>
        <span class="n">for_each</span><span class="p">(</span> <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="n">BTreeNode</span> <span class="o">*</span> <span class="n">c</span> <span class="p">)</span> <span class="p">{</span>
          <span class="n">c</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
        <span class="p">}</span> <span class="p">);</span>

        <span class="c1">//把后半部分从原来的节点中删除</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">KeysSize</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">);</span>

        <span class="n">BTreeNode</span> <span class="o">*</span><span class="n">parent_node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">parent_node</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="p">)</span> <span class="p">{</span> <span class="c1">//分裂到了根结点，树要长高了，需要NEW一个结点出来</span>
          <span class="n">parent_node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BTreeNode</span><span class="p">();</span>
          <span class="n">parent_node</span><span class="o">-&gt;</span><span class="n">IsLeaf</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
          <span class="n">parent_node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">node</span> <span class="p">);</span>
          <span class="n">_root</span> <span class="o">=</span> <span class="n">parent_node</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="o">=</span> <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="o">=</span> <span class="n">parent_node</span><span class="p">;</span>

        <span class="k">auto</span> <span class="n">insert_pos</span> <span class="o">=</span> <span class="n">find_if</span><span class="p">(</span> <span class="n">parent_node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span>
                                   <span class="p">,</span> <span class="n">parent_node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">end</span><span class="p">()</span>
                                   <span class="p">,</span> <span class="n">bind2nd</span><span class="p">(</span> <span class="n">greater</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">prove_node_key</span> <span class="p">)</span> <span class="p">)</span> <span class="o">-</span> <span class="n">parent_node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
        <span class="n">parent_node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">parent_node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">insert_pos</span><span class="p">,</span> <span class="n">prove_node_key</span> <span class="p">);</span>
        <span class="n">parent_node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">parent_node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">insert_pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">new_node</span> <span class="p">);</span>

        <span class="n">node</span> <span class="o">=</span> <span class="n">parent_node</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// @brief 删除一个结点的操作</span>
  <span class="c1">///</span>
  <span class="c1">/// 删除操作参考了这篇文章：http://student.zjzk.cn/course_ware/data_structure/web/chazhao/chazhao9.3.2.5.htm \n</span>
  <span class="c1">/// 任一关键字K的中序前趋(后继)必是K的左子树(右子树)中最右(左)下的结点中最后(最前)一个关键字。\n</span>
  <span class="c1">/// 根据B树的性质：B树上每一个结点的Key的个数必须为[t-1, 2*t-1]之间，所以这里的Min = t - 1\n</span>
  <span class="c1">/// 若被删关键字K所在的结点非树叶，则用K的中序前趋(或后继)K&#39;取代K，然后从叶子中删去K&#39;。\n</span>
  <span class="c1">/// 从叶子*x开始删去某关键字K的三种情形为：\n</span>
  <span class="c1">/// - 情形一：若x-&gt;keynum&gt;Min，则只需删去K及其右指针(*x是叶子，K的右指针为空)即可使删除操作结束。\n</span>
  <span class="c1">/// - 情形二：若x-&gt;keynum=Min，该叶子中的关键字个数已是最小值，删K及其右指针后会破坏B-树的性质(3)。\n</span>
  <span class="c1">///      若*x的左(或右)邻兄弟结点*y中的关键字数目大于Min，则将*y中的最大(或最小)关键字上移至双亲结点*parent中</span>
  <span class="c1">///      ，而将*parent中相应的关键字下移至x中。显然这种移动使得双亲中关键字数目不变；*y被移出一个关键字，故其</span>
  <span class="c1">///      keynum减1，因它原大于Min，故减少1个关键字后keynum仍大于等于Min；而*x中已移入一个关键字，故删K后*x中</span>
  <span class="c1">///      仍有Min个关键字。涉及移动关键字的三个结点均满足B-树的性质(3)。 上述操作后仍满足B树的性质(1)。</span>
  <span class="c1">///      移动完成后，删除过程亦结束。\n</span>
  <span class="c1">/// - 情形三：若*x及其相邻的左右兄弟(也可能只有一个兄弟)中的关键字数目均为最小值Min，则上述的移动操作就不奏效，</span>
  <span class="c1">///      此时须*x和左或右\n</span>
  <span class="c1">///      兄弟合并。不妨设*x有右邻兄弟*y(对左邻兄弟的讨论与此类似)，在*x中删去K及其右子树后，将双亲结点*parent</span>
  <span class="c1">///      中介于*x和*y之间的关键\n</span>
  <span class="c1">///      字K，作为中间关键字，与并x和*y中的关键字一起&quot;合并&quot;为一个新的结点取代*x和*y。因为*x和*y原各有Min个关</span>
  <span class="c1">///      键字，从双亲中移人的K&#39;抵\n</span>
  <span class="c1">///      消了从*x中删除的K，故新结点中恰有2Min(即2「m/2」-2≤m-1)个关键字，没有破坏B-树的性质(3)。但由于K&#39;从</span>
  <span class="c1">///      双亲中移到新结点后，相当\n</span>
  <span class="c1">///      于从*parent中删去了K&#39;，若parent-&gt;keynum原大于Min，则删除操作到此结束；否则，同样要通过移动*parent的</span>
  <span class="c1">///      左右兄弟中的关键字或将\n</span>
  <span class="c1">///      *parent与其 左右兄弟合并的方法来维护B-树性质。最坏情况下，合并操作会向上传播至根，当根中只有一个关键</span>
  <span class="c1">///      字时，合并操作将会使根结\n</span>
  <span class="c1">///      点及其两个孩子合并成一个新的根，从而使整棵树的高度减少一层。&lt;br/&gt;</span>
  <span class="c1">///  @note    现在回头看来，这种分二趟的方法也就只适合于学院派，在内存中操作操作还行，真正的系统中决不可能用这</span>
  <span class="c1">///        样的方法，减少磁盘的访问次数是一切工作的重心。其实书上描述的一趟方法也并不难以实现，一定要找机会</span>
  <span class="c1">///        来实现它！</span>
  <span class="kt">bool</span> <span class="n">Delete</span><span class="p">(</span> <span class="kt">int</span> <span class="n">key_to_del</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">found_node</span> <span class="o">=</span> <span class="n">Search</span><span class="p">(</span> <span class="n">key_to_del</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">found_node</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="p">)</span> <span class="p">{</span>  <span class="c1">//找不到值为key_to_del的结点</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">found_node</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">IsLeaf</span> <span class="p">)</span> <span class="p">{</span>  <span class="c1">//当要删除的结点不是叶子结点时用它的前驱来替换，再删除它的前驱</span>
      <span class="c1">//前驱</span>
      <span class="n">BTreeNode</span> <span class="o">*</span><span class="n">previous_node</span> <span class="o">=</span> <span class="n">found_node</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">[</span><span class="n">found_node</span><span class="p">.</span><span class="n">second</span><span class="p">];</span>
      <span class="k">while</span> <span class="p">(</span> <span class="o">!</span><span class="n">previous_node</span><span class="o">-&gt;</span><span class="n">IsLeaf</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">previous_node</span> <span class="o">=</span> <span class="n">previous_node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">[</span><span class="n">previous_node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
      <span class="p">}</span>

      <span class="c1">//替换</span>
      <span class="n">found_node</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="n">found_node</span><span class="p">.</span><span class="n">second</span><span class="p">]</span> <span class="o">=</span> <span class="n">previous_node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="n">previous_node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
      <span class="n">found_node</span><span class="p">.</span><span class="n">first</span> <span class="o">=</span> <span class="n">previous_node</span><span class="p">;</span>
      <span class="n">found_node</span><span class="p">.</span><span class="n">second</span> <span class="o">=</span> <span class="n">previous_node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//到这里，found_node一定是叶子结点</span>
    <span class="n">assert</span><span class="p">(</span> <span class="n">found_node</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">IsLeaf</span> <span class="p">);</span>
    <span class="n">_DeleteLeafNode</span><span class="p">(</span> <span class="n">found_node</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">found_node</span><span class="p">.</span><span class="n">second</span> <span class="p">);</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// 使用Graphiviz显示当前B树的内部结构</span>
  <span class="kt">void</span> <span class="n">Display</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">stringstream</span> <span class="n">ss</span><span class="p">;</span>

    <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;digraph graphname&quot;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">1000</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;{&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span>
    <span class="o">&lt;&lt;</span> <span class="s">&quot;    node [shape = record,height = .1];&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">_GetDotLanguageViaNodeAndEdge</span><span class="p">(</span> <span class="n">ss</span><span class="p">,</span> <span class="n">_root</span> <span class="p">);</span>
    <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;}&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="n">qi</span><span class="o">::</span><span class="n">ShowGraphvizViaDot</span><span class="p">(</span> <span class="n">ss</span><span class="p">.</span><span class="n">str</span><span class="p">()</span> <span class="p">);</span>
  <span class="p">}</span>


<span class="k">private</span><span class="o">:</span>
  <span class="kt">void</span> <span class="n">_ReleaseNode</span><span class="p">(</span> <span class="n">BTreeNode</span> <span class="o">*</span><span class="n">node</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">for_each</span><span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="n">BTreeNode</span> <span class="o">*</span> <span class="n">c</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">_ReleaseNode</span><span class="p">(</span> <span class="n">c</span> <span class="p">);</span>
    <span class="p">}</span> <span class="p">);</span>
    <span class="k">delete</span> <span class="n">node</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// @brief 删除B树中的一个叶子结点</span>
  <span class="c1">///</span>
  <span class="c1">/// @param  node  要删除的叶子结点！</span>
  <span class="c1">/// @param  index  要删除的叶子结点上的第几个值</span>
  <span class="c1">/// @note      必须保证传入的node结点为叶子结点</span>
  <span class="kt">void</span> <span class="n">_DeleteLeafNode</span><span class="p">(</span> <span class="n">BTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">index</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span> <span class="n">node</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">IsLeaf</span> <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">node</span> <span class="o">==</span> <span class="n">_root</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">//要删除的值在根结点上，并且此时根结点也是叶子结点，因为本方法被调用时要保证node参数是叶子结点</span>
      <span class="n">_root</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span> <span class="n">_root</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">index</span> <span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">_root</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">//成为了一棵空B树</span>
        <span class="k">delete</span> <span class="n">_root</span><span class="p">;</span>
        <span class="n">_root</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//以下是非根结点的情况</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">_t</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">//要删除的结点中Key的数目&gt;t-1，因此再-1也不会打破B树的性质</span>
      <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">index</span> <span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">//会打破平衡</span>
      <span class="c1">//是否借到了一个顶点</span>
      <span class="kt">bool</span>    <span class="n">borrowed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

      <span class="c1">//试着从左兄弟借一个结点</span>
      <span class="n">BTreeNode</span>  <span class="o">*</span><span class="n">left_brother</span> <span class="o">=</span> <span class="n">_GetLeftBrother</span><span class="p">(</span> <span class="n">node</span> <span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">left_brother</span> <span class="o">&amp;&amp;</span> <span class="n">left_brother</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">_t</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">index_in_parent</span> <span class="o">=</span> <span class="n">_GetIndexInParent</span><span class="p">(</span> <span class="n">left_brother</span> <span class="p">);</span>
        <span class="n">BTreeNode</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="p">;</span>

        <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="n">index_in_parent</span><span class="p">]</span> <span class="p">);</span>
        <span class="n">parent</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="n">index_in_parent</span><span class="p">]</span> <span class="o">=</span> <span class="n">left_brother</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="n">left_brother</span><span class="o">-&gt;</span><span class="n">KeysSize</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="n">left_brother</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span> <span class="n">left_brother</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">);</span>

        <span class="o">++</span><span class="n">index</span><span class="p">;</span>
        <span class="n">borrowed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">//当左兄弟借不到时，试着从右兄弟借一个结点</span>
        <span class="n">BTreeNode</span>  <span class="o">*</span><span class="n">right_brother</span> <span class="o">=</span> <span class="n">_GetRightBrother</span><span class="p">(</span> <span class="n">node</span> <span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">right_brother</span> <span class="o">&amp;&amp;</span> <span class="n">right_brother</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">_t</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
          <span class="kt">int</span> <span class="n">index_in_parent</span> <span class="o">=</span> <span class="n">_GetIndexInParent</span><span class="p">(</span> <span class="n">node</span> <span class="p">);</span>
          <span class="n">BTreeNode</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="p">;</span>

          <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="n">index_in_parent</span><span class="p">]</span> <span class="p">);</span>
          <span class="n">parent</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="n">index_in_parent</span><span class="p">]</span> <span class="o">=</span> <span class="n">right_brother</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
          <span class="n">right_brother</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span> <span class="n">right_brother</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="p">);</span>

          <span class="n">borrowed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span> <span class="n">borrowed</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">//因为借到了结点，所以可以直接删除结点</span>
        <span class="n">_DeleteLeafNode</span><span class="p">(</span> <span class="n">node</span><span class="p">,</span> <span class="n">index</span> <span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">//左右都借不到时先删除再合并</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">index</span> <span class="p">);</span>
        <span class="n">_UnionNodes</span><span class="p">(</span> <span class="n">node</span> <span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">/// @brief node找一个相邻的结点进行合并</span>
  <span class="c1">///</span>
  <span class="c1">/// 优先选取左兄弟结点，再次就选择右兄弟结点</span>
  <span class="kt">void</span> <span class="n">_UnionNodes</span><span class="p">(</span> <span class="n">BTreeNode</span> <span class="o">*</span> <span class="n">node</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">node</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">node</span> <span class="o">==</span> <span class="n">_root</span> <span class="p">)</span> <span class="p">{</span> <span class="c1">//node是头结点</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">_root</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
          <span class="c1">//头结点向下移动一级，此时树的高度-1</span>
          <span class="n">_root</span> <span class="o">=</span> <span class="n">_root</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
          <span class="n">_root</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>

          <span class="k">delete</span> <span class="n">node</span><span class="p">;</span>
          <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">KeysSize</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">_t</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
          <span class="n">BTreeNode</span> <span class="o">*</span><span class="n">left_brother</span> <span class="o">=</span> <span class="n">_GetLeftBrother</span><span class="p">(</span> <span class="n">node</span> <span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span> <span class="n">left_brother</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">left_brother</span> <span class="o">=</span> <span class="n">_GetRightBrother</span><span class="p">(</span> <span class="n">node</span> <span class="p">);</span>
            <span class="n">swap</span><span class="p">(</span> <span class="n">node</span><span class="p">,</span> <span class="n">left_brother</span> <span class="p">);</span>
          <span class="p">}</span>

          <span class="c1">//与左兄弟进行合并</span>
          <span class="kt">int</span> <span class="n">index_in_parent</span> <span class="o">=</span> <span class="n">_GetIndexInParent</span><span class="p">(</span> <span class="n">left_brother</span> <span class="p">);</span>
          <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="n">index_in_parent</span><span class="p">]</span> <span class="p">);</span>
          <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">index_in_parent</span> <span class="p">);</span>
          <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">index_in_parent</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">);</span>
          <span class="n">left_brother</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">left_brother</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span>
          <span class="n">left_brother</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">left_brother</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span>
          <span class="n">for_each</span><span class="p">(</span> <span class="n">left_brother</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">left_brother</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="n">BTreeNode</span> <span class="o">*</span> <span class="n">c</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">c</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="o">=</span> <span class="n">left_brother</span><span class="p">;</span>
          <span class="p">}</span> <span class="p">);</span>

          <span class="k">delete</span> <span class="n">node</span><span class="p">;</span>
          <span class="n">_UnionNodes</span><span class="p">(</span> <span class="n">left_brother</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">pair</span><span class="o">&lt;</span><span class="n">BTreeNode</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">_SearchInNode</span><span class="p">(</span> <span class="n">BTreeNode</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">node</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">//未找到，树为空的情况</span>
      <span class="k">return</span> <span class="n">make_pair</span><span class="p">(</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">BTreeNode</span> <span class="o">*&gt;</span><span class="p">(</span> <span class="k">nullptr</span> <span class="p">),</span> <span class="mi">0</span> <span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">key</span> <span class="o">&gt;=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">key</span> <span class="o">==</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="n">make_pair</span><span class="p">(</span> <span class="n">node</span><span class="p">,</span> <span class="n">index</span> <span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="o">++</span><span class="n">index</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">IsLeaf</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">//已经找到根了，不能再向下了未找到</span>
        <span class="k">return</span> <span class="n">make_pair</span><span class="p">(</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">BTreeNode</span> <span class="o">*&gt;</span><span class="p">(</span> <span class="k">nullptr</span> <span class="p">),</span> <span class="mi">0</span> <span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">_SearchInNode</span><span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">key</span> <span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">_GetDotLanguageViaNodeAndEdge</span><span class="p">(</span> <span class="n">stringstream</span> <span class="o">&amp;</span><span class="n">ss</span><span class="p">,</span> <span class="n">BTreeNode</span> <span class="o">*</span><span class="n">node</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">node</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    node&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[label = </span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&lt;f&quot;</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&gt;|&quot;</span><span class="p">;</span>
        <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&lt;f&quot;</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&gt;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;|&quot;</span><span class="p">;</span>
        <span class="o">++</span><span class="n">index</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&lt;f&quot;</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&gt;</span><span class="se">\&quot;</span><span class="s">];&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;;</span>

      <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">IsLeaf</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
          <span class="n">BTreeNode</span> <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
          <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    </span><span class="se">\&quot;</span><span class="s">node&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">:f&quot;</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; -&gt; </span><span class="se">\&quot;</span><span class="s">node&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">:f&quot;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">Keys</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>

      <span class="n">for_each</span><span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="n">BTreeNode</span> <span class="o">*</span> <span class="n">c</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">_GetDotLanguageViaNodeAndEdge</span><span class="p">(</span> <span class="n">ss</span><span class="p">,</span> <span class="n">c</span> <span class="p">);</span>
      <span class="p">}</span> <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">/// 得到一个结点的左兄弟结点，如果不存在左兄弟结点则返回nullptr</span>
  <span class="n">BTreeNode</span> <span class="o">*</span> <span class="n">_GetLeftBrother</span><span class="p">(</span> <span class="n">BTreeNode</span> <span class="o">*</span><span class="n">node</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">node</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">BTreeNode</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">node</span> <span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// 得到一个结点的右兄弟结点，如果不存在右兄弟结点则返回nullptr</span>
  <span class="n">BTreeNode</span> <span class="o">*</span> <span class="n">_GetRightBrother</span><span class="p">(</span> <span class="n">BTreeNode</span> <span class="o">*</span><span class="n">node</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">node</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">BTreeNode</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">node</span> <span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// 得到一个结点在其父结点中属于第几个子结点</span>
  <span class="c1">/// @return  返回-1时表示错误</span>
  <span class="kt">int</span> <span class="n">_GetIndexInParent</span><span class="p">(</span> <span class="n">BTreeNode</span> <span class="o">*</span><span class="n">node</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span> <span class="n">node</span> <span class="o">&amp;&amp;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="o">-&gt;</span><span class="n">Childs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">node</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>


  <span class="n">BTreeNode</span>  <span class="o">*</span><span class="n">_root</span><span class="p">;</span>      <span class="c1">///&lt; B树的根结点指针</span>
  <span class="kt">int</span>      <span class="n">_t</span><span class="p">;</span>        <span class="c1">///&lt; B树的 最小度数。即所有的结点的Keys的个数应该t-1 &lt;= n &lt;= 2t-1，除了根结点可以最少为1个Key</span>
<span class="p">};</span>


<span class="c1">/// B树</span>
<span class="kt">void</span> <span class="nf">testBTree</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">BTree</span> <span class="n">btree</span><span class="p">(</span> <span class="mi">3</span> <span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">btree</span><span class="p">.</span><span class="n">Insert</span><span class="p">(</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="n">btree</span><span class="p">.</span><span class="n">Display</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">btree</span><span class="p">.</span><span class="n">Delete</span><span class="p">(</span> <span class="n">i</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="n">btree</span><span class="p">.</span><span class="n">Display</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">btree</span><span class="p">.</span><span class="n">Delete</span><span class="p">(</span> <span class="n">i</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="n">btree</span><span class="p">.</span><span class="n">Display</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">30</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">btree</span><span class="p">.</span><span class="n">Insert</span><span class="p">(</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">1000</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">//btree.Delete(501);</span>
  <span class="c1">////btree.Display();</span>
  <span class="c1">//btree.Delete(869);</span>
  <span class="c1">//btree.Delete(896);</span>
  <span class="c1">//btree.Display();</span>
  <span class="c1">//btree.Delete(828);</span>
  <span class="n">btree</span><span class="p">.</span><span class="n">Display</span><span class="p">();</span>
<span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">testBTree</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<img alt="../../_images/B_tree_output1.png" src="../../_images/B_tree_output1.png" />
<img alt="../../_images/B_tree_output2.png" src="../../_images/B_tree_output2.png" />
<a class="reference internal image-reference" href="../../_images/B_tree_output4.png"><img alt="../../_images/B_tree_output4.png" src="../../_images/B_tree_output4.png" style="width: 1272.0px; height: 121.8px;" /></a>
</div>
<div class="section" id="id25">
<h3>第19章：二项堆<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h3>
<ul>
<li><p class="first">可合并堆就是普通的堆+支持decrease-key,union操作，但是应该高效的实现union操作是可合并堆最关键的部分。</p>
</li>
<li><p class="first">如果不需要高效的支持UNION操作，则普通的堆结构就很好了</p>
</li>
<li><dl class="first docutils">
<dt>对于 <strong>所有的堆结构：二叉堆、二项堆、斐波那契堆。它们的search操作都是很慢的</strong> ，不能高效的支持search操作！</dt>
<dd><p class="first last">因而在decrease-key和delete等涉及结点的操作时都需要一个指向结点的指针。</p>
</dd>
</dl>
</li>
<li><p class="first">一个二项<strong>堆</strong>是由一<strong>组</strong>二项<strong>树</strong>所构成的。</p>
</li>
<li><p class="first">二项树是一种递归的定义:</p>
<ul class="simple">
<li>二项树B[0]仅仅包含一个节点</li>
<li>B[k]是由两棵B[k-1]二项树组成，其中一颗树是另外一颗树的子树。</li>
</ul>
<p>下面是B0 - B4二项树：</p>
<img alt="../../_images/binary_tree1.png" src="../../_images/binary_tree1.png" />
</li>
<li><p class="first">显然二项树具有如下的性质：</p>
<ul class="simple">
<li>对于树B[k]该树含有2^k个节点；</li>
<li>树的高度是k；</li>
<li>在深度为i中含有Cik节点，其中i = 0， 1，2 … , k;</li>
</ul>
</li>
<li><p class="first">二项堆是由一组满足下面的二项树组成：</p>
<ol class="arabic simple">
<li>H中的每个二项树遵循最小堆性质：结点的关键字大于或等于其父结点的关键字。我们说这种树是最小堆有序的。</li>
<li>对于任意的整数k的话，在H不存在另外一个度数也是k的二项树；即至多（有0或1棵）有一棵二项树的根具有度数K。</li>
</ol>
<p>第一个性质保证了二项树的根结点包含了最小的关键字。第二个性质则说明结点数为n的二项堆最多只有logn&nbsp;+ 1棵二项树。</p>
</li>
<li><dl class="first docutils">
<dt>就像二进制的0、1可以表示出任意的数值，任意个结点数的堆也可以由二项堆来表示。</dt>
<dd><p class="first last">例如：13&lt;1101&gt;个结点的堆可由二项树B3,B2,B0来表示出来。</p>
</dd>
</dl>
</li>
<li><p class="first">根表：一个二项堆中的各二项树的根被组织成一个键表，我们称之为根表！</p>
<img alt="../../_images/binary_tree2.png" src="../../_images/binary_tree2.png" />
</li>
<li><p class="first">二项堆的最重要的一个操作就是UNION操作，其它的操作都可以在UNION操作的基础上轻松的实现。</p>
<p>大概思路为：将两个二项堆的根表连接起来组成一个大的二项树的连接，按”度”的单调递增顺序进行排序之后，从左至右来消除具有重复度的二项树。因为原本的每个二项堆中任意度K至多只有一个相应的二项树，所以这个消除重复的操作会非常容易。从小到大找到两个相同度K的二项树，然后连接成一个K+1度的二项树，直到链尾时合并完毕。</p>
<p>此时的二项堆就满足对任意度K至多只有一棵二项树。此操作的时间复杂度为O(logn)</p>
<img alt="../../_images/binary_tree3.png" src="../../_images/binary_tree3.png" />
</li>
<li><p class="first"><strong>其它的操作都可以通过将UNION操作作为基础操作来实现</strong> ：</p>
<ul>
<li><p class="first">插入：NEW一个一个结点的二项堆，然后调用UNION与原二项堆来进行合并</p>
</li>
<li><p class="first">抽取最小关键字的结点：</p>
<ul class="simple">
<li>从原二项堆的根键上取下最小关键字结点的二项树，独立出来；</li>
<li>将独立出来的二项树的根结点去掉（这就是整个二项堆的最小关键字），然后将它的子结点逆转并组合成为一个不含最小值的二项堆；</li>
<li>最后将这个新的二项堆与原来剩下的二项堆进行合并操作。</li>
</ul>
<img alt="../../_images/binary_tree4.jpg" src="../../_images/binary_tree4.jpg" />
</li>
<li><p class="first">减少关键字：将要减小的关键字与它的父结点进行比较，如果需要就进行交换操作直到根链。使得该关键字在堆中”冒泡上升”直到正确的位置。</p>
</li>
<li><p class="first">删除一个关键字（调用其它操作实现）:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">decrease</span><span class="o">-</span><span class="n">key</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">max</span><span class="p">)</span>
<span class="n">extract</span><span class="o">-</span><span class="n">min</span><span class="p">()</span>
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     binomial_heaps.cpp</span>
<span class="cm"> * @brief    二项堆</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;graphviz_shower.h&quot;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="c1">/// @brief 二项堆</span>
<span class="c1">///</span>
<span class="c1">/// 二项堆是由&lt;b&gt;一组&lt;/b&gt;满足下面的&lt;b&gt;二项树&lt;/b&gt;组成：\n</span>
<span class="c1">/// - H中的每个二项树遵循&lt;span style=&quot;color:#FF0000 &quot;&gt;最小堆性质：结点的关键字大于或等于其父结点的关键字&lt;/span&gt;。</span>
<span class="c1">/// 我们说这种树是最小堆有序的。</span>
<span class="c1">/// - 对于任意的整数k的话，在H不存在另外一个度数也是k的二项树；即&lt;span style=&quot;color:#FF0000 &quot;&gt;至多&lt;/span&gt;（有0或1棵）</span>
<span class="c1">/// 有一棵二项树的根具有度数K。（与二进制太类似了，估计是受二进制启发而来的）</span>
<span class="c1">///</span>
<span class="c1">/// 第一个性质保证了二项树的根结点包含了最小的关键字。第二个性质则说明结点数为n的二项堆最多只有logn + 1棵二项树。\n</span>
<span class="c1">/// 二项树是一种递归的定义:\n</span>
<span class="c1">/// - 二项树B[0]仅仅包含一个节点</span>
<span class="c1">/// - B[k]是由两棵B[k-1]二项树组成，其中一颗树是另外一颗树的子树。</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">KeyType</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">BinomialHeap</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">/// 二项堆中的一个结点</span>
  <span class="k">struct</span> <span class="n">BinomialHeapNode</span> <span class="p">{</span>
    <span class="n">BinomialHeapNode</span>  <span class="o">*</span><span class="n">Parent</span><span class="p">;</span>
    <span class="n">BinomialHeapNode</span>  <span class="o">*</span><span class="n">Child</span><span class="p">;</span>
    <span class="n">BinomialHeapNode</span>  <span class="o">*</span><span class="n">Sibling</span><span class="p">;</span>

    <span class="kt">unsigned</span> <span class="kt">int</span>     <span class="n">Degree</span><span class="p">;</span>
    <span class="n">KeyType</span>        <span class="n">Key</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="c1">/// 建立一个空的二项堆</span>
  <span class="n">BinomialHeap</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">_head_list</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// 析构</span>
  <span class="o">~</span><span class="n">BinomialHeap</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">BinomialHeapNode</span> <span class="o">*</span><span class="n">tree</span> <span class="o">=</span> <span class="n">_head_list</span><span class="p">;</span>

    <span class="c1">//遍历根链进行清理操作</span>
    <span class="k">while</span> <span class="p">(</span> <span class="n">tree</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">auto</span> <span class="n">next</span> <span class="o">=</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">Sibling</span><span class="p">;</span>
      <span class="n">_DeleteTree</span><span class="p">(</span> <span class="n">tree</span> <span class="p">);</span>
      <span class="n">tree</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">/// 在二项堆中插入一个新结点</span>
  <span class="kt">void</span> <span class="n">Insert</span><span class="p">(</span> <span class="n">KeyType</span> <span class="n">new_key</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">BinomialHeap</span> <span class="n">new_heap</span><span class="p">;</span>
    <span class="n">new_heap</span><span class="p">.</span><span class="n">_head_list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinomialHeapNode</span><span class="p">();</span>
    <span class="n">new_heap</span><span class="p">.</span><span class="n">_head_list</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="o">=</span> <span class="n">new_heap</span><span class="p">.</span><span class="n">_head_list</span><span class="o">-&gt;</span><span class="n">Child</span> <span class="o">=</span> <span class="n">new_heap</span><span class="p">.</span><span class="n">_head_list</span><span class="o">-&gt;</span><span class="n">Sibling</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">new_heap</span><span class="p">.</span><span class="n">_head_list</span><span class="o">-&gt;</span><span class="n">Degree</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">new_heap</span><span class="p">.</span><span class="n">_head_list</span><span class="o">-&gt;</span><span class="n">Key</span> <span class="o">=</span> <span class="n">new_key</span><span class="p">;</span>

    <span class="k">this</span><span class="o">-&gt;</span><span class="n">Union</span><span class="p">(</span> <span class="n">new_heap</span> <span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">/// 获取堆中的最小元素值</span>
  <span class="n">KeyType</span> <span class="n">Mininum</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">KeyType</span><span class="o">&gt;</span> <span class="n">values_in_head_list</span><span class="p">;</span>
    <span class="n">BinomialHeapNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">_head_list</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span> <span class="n">node</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">values_in_head_list</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Key</span> <span class="p">);</span>
      <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Sibling</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">min_element</span><span class="p">(</span> <span class="n">values_in_head_list</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">values_in_head_list</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">/// 弹出二项堆中的最小元素，并获取该最小元素的值</span>
  <span class="n">KeyType</span> <span class="n">ExtractMinium</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">BinomialHeapNode</span> <span class="o">*&gt;</span> <span class="n">head_nodes</span><span class="p">;</span>
    <span class="n">BinomialHeapNode</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">_head_list</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span> <span class="n">l</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">head_nodes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">l</span> <span class="p">);</span>
      <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">Sibling</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">auto</span> <span class="n">min_ele</span> <span class="o">=</span> <span class="n">min_element</span><span class="p">(</span> <span class="n">head_nodes</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">head_nodes</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span> <span class="n">BinomialHeapNode</span> <span class="o">*</span> <span class="n">left</span><span class="p">,</span> <span class="n">BinomialHeapNode</span> <span class="o">*</span> <span class="n">right</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">left</span><span class="o">-&gt;</span><span class="n">Key</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">Key</span><span class="p">;</span>
    <span class="p">}</span> <span class="p">);</span>
    <span class="kt">int</span> <span class="n">min_index</span> <span class="o">=</span> <span class="n">min_ele</span> <span class="o">-</span> <span class="n">head_nodes</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
    <span class="n">KeyType</span> <span class="n">min_value</span> <span class="o">=</span> <span class="p">(</span> <span class="o">*</span><span class="n">min_ele</span> <span class="p">)</span><span class="o">-&gt;</span><span class="n">Key</span><span class="p">;</span>
    <span class="n">BinomialHeapNode</span>  <span class="o">*</span><span class="n">min_node</span> <span class="o">=</span> <span class="n">head_nodes</span><span class="p">[</span><span class="n">min_index</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">min_index</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">head_nodes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">_head_list</span> <span class="o">=</span> <span class="n">head_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">//根链上只有一个元素</span>
        <span class="n">_head_list</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">min_index</span> <span class="o">==</span> <span class="n">head_nodes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">head_nodes</span><span class="p">[</span><span class="n">min_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">Sibling</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">head_nodes</span><span class="p">[</span><span class="n">min_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">Sibling</span> <span class="o">=</span> <span class="n">head_nodes</span><span class="p">[</span><span class="n">min_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">BinomialHeap</span> <span class="n">new_head</span><span class="p">;</span>
    <span class="n">new_head</span><span class="p">.</span><span class="n">_head_list</span> <span class="o">=</span> <span class="n">min_node</span><span class="o">-&gt;</span><span class="n">Child</span><span class="p">;</span>
    <span class="n">BinomialHeapNode</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="n">new_head</span><span class="p">.</span><span class="n">_head_list</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span> <span class="n">x</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">x</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
      <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">Sibling</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">Union</span><span class="p">(</span> <span class="n">new_head</span> <span class="p">);</span>

    <span class="k">delete</span> <span class="n">min_node</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">min_value</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// @brief 对一个结点的值进行缩小操作</span>
  <span class="c1">///</span>
  <span class="c1">/// @note    x结点的新值k必须比x结点的原值小</span>
  <span class="kt">void</span> <span class="n">Decrease</span><span class="p">(</span> <span class="n">BinomialHeapNode</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">KeyType</span> <span class="n">k</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">Key</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">throw</span> <span class="n">logic_error</span><span class="p">(</span> <span class="s">&quot;只能减小不能增大&quot;</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">x</span><span class="o">-&gt;</span><span class="n">Key</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
    <span class="n">BinomialHeapNode</span> <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">BinomialHeapNode</span> <span class="o">*</span><span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span> <span class="n">z</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">Key</span> <span class="o">&lt;</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">Key</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">swap</span><span class="p">(</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">Key</span><span class="p">,</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">Key</span> <span class="p">);</span>
      <span class="n">y</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>
      <span class="n">z</span> <span class="o">=</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">/// 删除一个结点</span>
  <span class="kt">void</span> <span class="n">Delete</span><span class="p">(</span> <span class="n">BinomialHeapNode</span> <span class="o">*</span><span class="n">node</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">node</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">Decrease</span><span class="p">(</span> <span class="n">node</span><span class="p">,</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">KeyType</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">()</span> <span class="p">);</span>
      <span class="n">ExtractMinium</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">/// @brief 联合另外一个二项堆</span>
  <span class="c1">///</span>
  <span class="c1">/// 将另外一个二项堆联合到本二项堆,当联合操作完成之后,other的二项堆中的数据将无效</span>
  <span class="kt">void</span> <span class="n">Union</span><span class="p">(</span> <span class="n">BinomialHeap</span> <span class="o">&amp;</span><span class="n">other</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">BinomialHeapNode</span> <span class="o">*&gt;</span> <span class="n">nodes</span><span class="p">;</span>
    <span class="n">BinomialHeapNode</span> <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">_head_list</span><span class="p">;</span>
    <span class="n">BinomialHeapNode</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">_head_list</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span> <span class="n">l</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">nodes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">l</span> <span class="p">);</span>
      <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">Sibling</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span> <span class="n">r</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">nodes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">r</span> <span class="p">);</span>
      <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">Sibling</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">nodes</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// sort and merge</span>
    <span class="n">sort</span><span class="p">(</span> <span class="n">nodes</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nodes</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span> <span class="n">BinomialHeapNode</span> <span class="o">*</span> <span class="n">left</span><span class="p">,</span> <span class="n">BinomialHeapNode</span> <span class="o">*</span> <span class="n">right</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">left</span><span class="o">-&gt;</span><span class="n">Degree</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">Degree</span><span class="p">;</span>
    <span class="p">}</span> <span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nodes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">Sibling</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">nodes</span><span class="p">[</span><span class="n">nodes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">Sibling</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>

    <span class="c1">// reset head list</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">_head_list</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">other</span><span class="p">.</span><span class="n">_head_list</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>    <span class="c1">//destory binomial heaps has been unioned</span>
    <span class="k">if</span> <span class="p">(</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_head_list</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// begin to merge nodes in head list with same degree</span>
    <span class="n">BinomialHeapNode</span> <span class="o">*</span><span class="n">prev_x</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="n">BinomialHeapNode</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="n">_head_list</span><span class="p">;</span>
    <span class="n">BinomialHeapNode</span> <span class="o">*</span><span class="n">next_x</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">Sibling</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span> <span class="n">next_x</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">Degree</span> <span class="o">!=</span> <span class="n">next_x</span><span class="o">-&gt;</span><span class="n">Degree</span> <span class="o">||</span> <span class="p">(</span> <span class="n">next_x</span><span class="o">-&gt;</span><span class="n">Sibling</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="o">&amp;&amp;</span> <span class="n">next_x</span><span class="o">-&gt;</span><span class="n">Sibling</span><span class="o">-&gt;</span><span class="n">Degree</span> <span class="o">==</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">Degree</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">prev_x</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">next_x</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">Key</span> <span class="o">&lt;</span> <span class="n">next_x</span><span class="o">-&gt;</span><span class="n">Key</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span><span class="o">-&gt;</span><span class="n">Sibling</span> <span class="o">=</span> <span class="n">next_x</span><span class="o">-&gt;</span><span class="n">Sibling</span><span class="p">;</span>
        <span class="n">_Link</span><span class="p">(</span> <span class="n">next_x</span><span class="p">,</span> <span class="n">x</span> <span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">prev_x</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="p">)</span> <span class="p">{</span>
          <span class="n">_head_list</span> <span class="o">=</span> <span class="n">next_x</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">prev_x</span><span class="o">-&gt;</span><span class="n">Sibling</span> <span class="o">=</span> <span class="n">next_x</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">_Link</span><span class="p">(</span> <span class="n">x</span><span class="p">,</span> <span class="n">next_x</span> <span class="p">);</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">next_x</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="n">next_x</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">Sibling</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">/// @brief 查找一个值为key的结点</span>
  <span class="c1">///</span>
  <span class="c1">/// @note    所有的堆对查找操作的支持都很差，时间复杂度为O(n)</span>
  <span class="n">BinomialHeapNode</span> <span class="o">*</span> <span class="n">Search</span><span class="p">(</span> <span class="n">KeyType</span> <span class="n">key</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">BinomialHeapNode</span> <span class="o">*</span><span class="n">tree</span> <span class="o">=</span> <span class="n">_head_list</span><span class="p">;</span>

    <span class="c1">//遍历根链</span>
    <span class="k">while</span> <span class="p">(</span> <span class="n">tree</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">BinomialHeapNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">_SearchInTree</span><span class="p">(</span> <span class="n">tree</span><span class="p">,</span> <span class="n">key</span> <span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">node</span> <span class="o">!=</span> <span class="k">nullptr</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">tree</span> <span class="o">=</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">Sibling</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// 二项堆的当前状态是否为空</span>
  <span class="kt">bool</span> <span class="n">IsEmpty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_head_list</span> <span class="o">==</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// 得到二项堆的根链表</span>
  <span class="n">BinomialHeapNode</span> <span class="o">*</span> <span class="n">GetHeadList</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_head_list</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// 使用Grpahviz显示当前二项堆</span>
  <span class="kt">void</span> <span class="n">Display</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">stringstream</span> <span class="n">ss</span><span class="p">;</span>

    <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;digraph graphname&quot;</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;{&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span>
    <span class="o">&lt;&lt;</span> <span class="s">&quot;    RootList [shape = box];&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="n">BinomialHeapNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">_head_list</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">node</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    RootList -&gt; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Key</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span> <span class="n">node</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">_DisplayTree</span><span class="p">(</span> <span class="n">ss</span><span class="p">,</span> <span class="n">node</span> <span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Sibling</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Key</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; -&gt; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Sibling</span><span class="o">-&gt;</span><span class="n">Key</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Sibling</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;}&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">qi</span><span class="o">::</span><span class="n">ShowGraphvizViaDot</span><span class="p">(</span> <span class="n">ss</span><span class="p">.</span><span class="n">str</span><span class="p">()</span> <span class="p">);</span>

  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="c1">/// 清理一棵“二项树”</span>
  <span class="kt">void</span> <span class="n">_DeleteTree</span><span class="p">(</span> <span class="n">BinomialHeapNode</span> <span class="o">*</span><span class="n">tree</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">tree</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">BinomialHeapNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">Child</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span> <span class="n">node</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">next</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Sibling</span><span class="p">;</span>
        <span class="n">_DeleteTree</span><span class="p">(</span> <span class="n">node</span> <span class="p">);</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">delete</span> <span class="n">tree</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">/// 将D(k-1)度的y结点连接到D(k-1)度的z接点上去，使得z成为一个D(k)度的结点</span>
  <span class="kt">void</span> <span class="n">_Link</span><span class="p">(</span> <span class="n">BinomialHeapNode</span> <span class="o">*</span><span class="n">y</span><span class="p">,</span> <span class="n">BinomialHeapNode</span> <span class="o">*</span><span class="n">z</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">y</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>
    <span class="n">y</span><span class="o">-&gt;</span><span class="n">Sibling</span> <span class="o">=</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">Child</span><span class="p">;</span>
    <span class="n">z</span><span class="o">-&gt;</span><span class="n">Child</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
    <span class="o">++</span><span class="n">z</span><span class="o">-&gt;</span><span class="n">Degree</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// 在一棵二项树中搜索某个结点</span>
  <span class="n">BinomialHeapNode</span> <span class="o">*</span> <span class="n">_SearchInTree</span><span class="p">(</span> <span class="n">BinomialHeapNode</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span> <span class="n">KeyType</span> <span class="n">key</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">Key</span> <span class="o">==</span> <span class="n">key</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">tree</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">BinomialHeapNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">Child</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span> <span class="n">node</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">BinomialHeapNode</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">_SearchInTree</span><span class="p">(</span> <span class="n">node</span><span class="p">,</span> <span class="n">key</span> <span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">n</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">Sibling</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// 画一棵二项树</span>
  <span class="kt">void</span> <span class="n">_DisplayTree</span><span class="p">(</span> <span class="n">stringstream</span> <span class="o">&amp;</span><span class="n">ss</span><span class="p">,</span> <span class="n">BinomialHeapNode</span> <span class="o">*</span><span class="n">tree</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">tree</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">BinomialHeapNode</span> <span class="o">*</span><span class="n">child</span> <span class="o">=</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">Child</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">child</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">BinomialHeapNode</span> <span class="o">*&gt;</span> <span class="n">childs</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span> <span class="n">child</span> <span class="p">)</span> <span class="p">{</span>
          <span class="n">childs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">child</span> <span class="p">);</span>
          <span class="n">child</span> <span class="o">=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">Sibling</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">for_each</span><span class="p">(</span> <span class="n">childs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">childs</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="n">BinomialHeapNode</span> <span class="o">*</span> <span class="n">c</span> <span class="p">)</span> <span class="p">{</span>
          <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;    &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">Key</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; -&gt; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">Key</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
          <span class="n">_DisplayTree</span><span class="p">(</span> <span class="n">ss</span><span class="p">,</span> <span class="n">c</span> <span class="p">);</span>
        <span class="p">}</span> <span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">BinomialHeapNode</span> <span class="o">*</span><span class="n">_head_list</span><span class="p">;</span>      <span class="c1">///&lt; 根链表</span>
<span class="p">};</span>

<span class="c1">/// 二项堆</span>
<span class="kt">void</span> <span class="nf">testBinomialHeaps</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;二项堆&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">BinomialHeap</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">bh</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">bh</span><span class="p">.</span><span class="n">Insert</span><span class="p">(</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="n">bh</span><span class="p">.</span><span class="n">Display</span><span class="p">();</span>

  <span class="k">while</span> <span class="p">(</span> <span class="o">!</span><span class="n">bh</span><span class="p">.</span><span class="n">IsEmpty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">bh</span><span class="p">.</span><span class="n">ExtractMinium</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">bh</span><span class="p">.</span><span class="n">Display</span><span class="p">();</span>

  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">bh</span><span class="p">.</span><span class="n">Search</span><span class="p">(</span> <span class="n">r</span> <span class="p">)</span> <span class="o">==</span> <span class="k">nullptr</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">bh</span><span class="p">.</span><span class="n">Insert</span><span class="p">(</span> <span class="n">r</span> <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">bh</span><span class="p">.</span><span class="n">Display</span><span class="p">();</span>

  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">bh</span><span class="p">.</span><span class="n">Delete</span><span class="p">(</span> <span class="n">bh</span><span class="p">.</span><span class="n">Search</span><span class="p">(</span> <span class="n">i</span> <span class="p">)</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="n">bh</span><span class="p">.</span><span class="n">Display</span><span class="p">();</span>
<span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">testBinomialHeaps</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>二项堆
15	21	35	49	77	83	86	86	92	93	
</pre></div>
</div>
<img alt="../../_images/binomial_heaps_output1.png" src="../../_images/binomial_heaps_output1.png" />
<img alt="../../_images/binomial_heaps_output2.png" src="../../_images/binomial_heaps_output2.png" />
<a class="reference internal image-reference" href="../../_images/binomial_heaps_output3.png"><img alt="../../_images/binomial_heaps_output3.png" src="../../_images/binomial_heaps_output3.png" style="width: 1276.0px; height: 431.20000000000005px;" /></a>
<img alt="../../_images/binomial_heaps_output4.png" src="../../_images/binomial_heaps_output4.png" />
</div>
<div class="section" id="id26">
<h3>第20章：斐波那契堆<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h3>
<ul>
<li><p class="first">斐波那契堆与二项堆相比，取消掉了2个限制，因而更加的松散了：</p>
<ul class="simple">
<li>斐波那契堆中的树不必要求是二项树</li>
<li>根链中的树必没有”每个度数至多只能有一棵树”的要求了</li>
</ul>
</li>
<li><p class="first">斐波那契堆首先也是一种堆，所以它也满足堆的性质：子结点比父结点大！</p>
</li>
<li><p class="first">斐波那契堆的特点：不涉及删除元素的操作有O(1)的平摊时间。 Extract-Min和Delete的数目和其它相比较小时效率更佳。</p>
</li>
<li><p class="first">斐波那契堆在优化加速图算法中有很大的用途。比如用于解决诸如最小生成树、寻找单源最短路径等问题的快速算法都要用到斐波那契堆。</p>
</li>
<li><p class="first">斐波那契堆由一组树（并不要求二项树）组成。但实际上，这种堆松散地基于二项堆。斐波那契堆的结构比二项堆更松散一些，从而可以改进渐近时间界。对结构的维护工作尽可能的拖延，直到方便时再做。</p>
</li>
<li><p class="first">同任何堆一样：斐波那契堆也不能很好地支持search操作。</p>
</li>
<li><p class="first">与二项堆中的树都是有序的不同，斐波那契堆中的树都是有根而无序的。每个节点包含一个指向其父节点的指针p[x]，以及一个指向其任一子女的指针child[x]（指向子女双链表），因为这些子结点本身就没有顺序关系（兄弟之间是无序的，所以更加松散），所以可以随意的指向。</p>
<img alt="../../_images/fibonacci_heap.jpg" src="../../_images/fibonacci_heap.jpg" />
<p>其中：mark[x]用于指示自从x上一次成为另一个结点子女以来，它是否失掉了一个孩子，在图中用黑色的结点来表示。</p>
</li>
<li><p class="first">如果仅支持”make-heap, insert, minimum, extract-min, union操作，那么每个斐波那契堆就只是一组”无序的”二项树。</p>
</li>
<li><dl class="first docutils">
<dt>对斐波那契堆上的各种可合并堆操作来说，其关键思想就是尽可能久地将工作推后。</dt>
<dd><p class="first last">这种lazy-compute很可能会大大的改善性质，但是也会造成后面真正进行维护时的算法执行时间的常数因子过大。</p>
</dd>
</dl>
</li>
<li><p class="first">斐波那契堆是通过指向根链上的最小结点的指针min[H]来进行访问的。</p>
</li>
<li><dl class="first docutils">
<dt>斐波那契堆的日常操作都非常简单，除了extract-min以外：</dt>
<dd><p class="first last">注：这里的时间复杂度均指的是平摊代价，而非一般使用的最坏情况时间。</p>
</dd>
</dl>
<ul>
<li><p class="first">插入操作O(1)：直接插入到根链上去，再与最小结点的min[H]进行一下比如，如果比min[H]还小，就将min[H]指针指向新插入的结点。</p>
</li>
<li><p class="first">寻找最小节点O(1)： min[x]指向的节点即为最小节点。</p>
</li>
<li><p class="first">合并两个斐波那契堆O(1)：分为3步： 1：合并根表；2：设置新的min[h]；3。重置n[x]。
斐波那契堆过于松散的性质使得连合并操作都只需要O(1)的时间，只需要合并两个根链就可以了。</p>
</li>
<li><p class="first">抽取最小节点O(lgn)：相对来说这是最复杂的工作。被延迟的对根表的调整工作最终由这个操作进行。</p>
<div class="line-block">
<div class="line">1：去掉根表上的最小值，将这个最小值的每个孩子都加入根表；2：将根表上相同度数树的合并。</div>
<div class="line">（一点都不复杂，代码与二项堆一样容易实现）</div>
</div>
<dl class="docutils">
<dt>这里的在根链上合并操作与二项树基本相同，就是按”度的递增”顺序排列所有的子树之后，合并具有相同度的子树，使得最后的根链上每一个度K都只有至多一棵子树。（这里又与二项堆神似了，所以说斐波那契堆是松散地基于二项堆）。形式化地描述为：</dt>
<dd><p class="first last">“调整根表的步骤 1：在根表中找出两个具有相同度数的根x和y，且key[x]&lt;key[y] 2：将y与x连接。将y从根表里去掉，成为x一个孩子，并增加degree[x]。同时，如果y上有标记的话也被清除掉。”</p>
</dd>
</dl>
</li>
<li><p class="first">减小一个节点的权值O(1)：</p>
<ul class="simple">
<li>若此减小不影响堆序，不作调整；</li>
<li>若影响堆序，则从堆中删除该节点，将其加入根表，并检查其父亲的mark位；若为false，则停止，并将其置为true；若为true，则删除其父亲，继续递归向上执行；直到一个节点mark域为false或该节点为根节点为止。</li>
</ul>
</li>
<li><p class="first">删除一个节点O(lgn)：1：将该节点权值调整至最小；2：抽取最小值。</p>
</li>
</ul>
</li>
<li><p class="first">总结：斐波那契堆之所以高效，就是因为它松散了，将很多二项堆要维护的工作都推迟到了extract-min和delete操作之中去了。而它之所以可以这样进行偷懒，就是因为它的限制非常的少，并没有像二项堆一样的要求子树全部必须是二项树，而且根表上的任意度数的子树至多只能有一个。没有了这些限制，斐波那契堆就可以实现的非常的松散以至少将日常工作的维护时间都平摊给extract-min和delete操作。</p>
<p>但是，正如斐波那契堆现在更多的应用于理论中，实践中使用的并不多的现象所映射的，在大部分的应用中斐波那契堆并不能带来大幅度的效率的提升。因为它并不是减少了要做的工作，只是将很多要做的工作都进行了推迟，可能出现这样的情况：</p>
<ul class="simple">
<li>合并操作O(lgn)=&gt;O(1)</li>
<li>插入操作O(lgn)=&gt;O(1)</li>
<li>减少权值操作O(lgn)=&gt;O(1)</li>
<li>但是extract-min操作O(lgn)=&gt;O(3*lgn)≈O(lgn)</li>
</ul>
<p>这使得在理论分析时，它的所有操作的渐近时间都至少不变坏，但是在实际使用中却没有任何的改善。
当然这是最坏的情况了，一般对于规模足够大的输入，斐波那契堆是能够很大改善算法的性能的，尤其是对于一些extract-min和delete操作少的情况。比如斐波那契堆的使用能加快 Prime 和 Djikstra 算法的执行速度。</p>
</li>
</ul>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>
<span class="cm">/**</span>
<span class="cm"> * @file     fibonacci_heap.cpp</span>
<span class="cm"> * @brief    Fibonacci Heap</span>
<span class="cm"> *</span>
<span class="cm"> * @ref http://en.wikipedia.org/wiki/Fibonacci_heap</span>
<span class="cm"> * @ref http://www.cse.yorku.ca/~aaw/Jason/FibonacciHeapAlgorithm.html</span>
<span class="cm"> * @author Erel Segal http://tora.us.fm/rentabrain</span>
<span class="cm"> * @date 2010-11-11</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * chuanqi.tan(at)gmail.com  引用说明</span>
<span class="cm"> *</span>
<span class="cm"> * 斐波那契堆与二项堆非常类似，就不再自己重新写了。</span>
<span class="cm"> * 这里的代码转载自：http://ideone.com/9jYnv 这种代码的风格非常现代化我非常喜欢，故引用了这份代码</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uint</span><span class="p">;</span>


<span class="cm">/**</span>
<span class="cm"> * The heap is a min-heap sorted by Key.</span>
<span class="cm"> */</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Data</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Key</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">FibonacciHeapNode</span> <span class="p">{</span>
  <span class="n">Key</span> <span class="n">myKey</span><span class="p">;</span>
  <span class="n">Data</span> <span class="n">myData</span><span class="p">;</span>

  <span class="n">uint</span> <span class="n">degree</span><span class="p">;</span> <span class="c1">// number of childern. used in the removeMinimum algorithm.</span>
  <span class="kt">bool</span> <span class="n">mark</span><span class="p">;</span>   <span class="c1">// mark used in the decreaseKey algorithm.</span>

  <span class="c1">//uint count; // total number of elements in tree, including this. For debug only</span>

  <span class="n">FibonacciHeapNode</span><span class="o">&lt;</span><span class="n">Data</span><span class="p">,</span> <span class="n">Key</span><span class="o">&gt;*</span> <span class="n">previous</span><span class="p">;</span> <span class="c1">// pointers in a circular doubly linked list</span>
  <span class="n">FibonacciHeapNode</span><span class="o">&lt;</span><span class="n">Data</span><span class="p">,</span> <span class="n">Key</span><span class="o">&gt;*</span> <span class="n">next</span><span class="p">;</span>
  <span class="n">FibonacciHeapNode</span><span class="o">&lt;</span><span class="n">Data</span><span class="p">,</span> <span class="n">Key</span><span class="o">&gt;*</span> <span class="n">child</span><span class="p">;</span> <span class="c1">// pointer to the first child in the list of children</span>
  <span class="n">FibonacciHeapNode</span><span class="o">&lt;</span><span class="n">Data</span><span class="p">,</span> <span class="n">Key</span><span class="o">&gt;*</span> <span class="n">parent</span><span class="p">;</span>

  <span class="n">FibonacciHeapNode</span><span class="p">()</span> <span class="p">{}</span>
  <span class="n">FibonacciHeapNode</span><span class="p">(</span> <span class="n">Data</span> <span class="n">d</span><span class="p">,</span> <span class="n">Key</span> <span class="n">k</span> <span class="p">)</span><span class="o">:</span>
      <span class="n">myKey</span><span class="p">(</span> <span class="n">k</span> <span class="p">),</span>
      <span class="n">myData</span><span class="p">(</span> <span class="n">d</span> <span class="p">),</span>
      <span class="n">degree</span><span class="p">(</span> <span class="mi">0</span> <span class="p">),</span>
      <span class="n">mark</span><span class="p">(</span> <span class="nb">false</span> <span class="p">),</span>
      <span class="n">child</span><span class="p">(</span> <span class="nb">NULL</span> <span class="p">),</span>
      <span class="n">parent</span><span class="p">(</span> <span class="nb">NULL</span> <span class="p">)</span>
      <span class="c1">//,count(1)</span>
  <span class="p">{</span>
    <span class="n">previous</span> <span class="o">=</span> <span class="n">next</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span> <span class="c1">// doubly linked circular list</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">isSingle</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span> <span class="k">this</span> <span class="o">==</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">next</span> <span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// inserts a new node after this node</span>
  <span class="kt">void</span> <span class="n">insert</span><span class="p">(</span> <span class="n">FibonacciHeapNode</span><span class="o">&lt;</span><span class="n">Data</span><span class="p">,</span> <span class="n">Key</span><span class="o">&gt;*</span> <span class="n">other</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">other</span> <span class="p">)</span>
      <span class="k">return</span><span class="p">;</span>

    <span class="c1">// For example: given 1-&gt;2-&gt;3-&gt;4-&gt;1, insert a-&gt;b-&gt;c-&gt;d-&gt;a after node 3:</span>
    <span class="c1">//      result: 1-&gt;2-&gt;3-&gt;a-&gt;b-&gt;c-&gt;d-&gt;4-&gt;1</span>

    <span class="k">this</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">previous</span> <span class="o">=</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">previous</span><span class="p">;</span>
    <span class="n">other</span><span class="o">-&gt;</span><span class="n">previous</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

    <span class="k">this</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">other</span><span class="p">;</span>
    <span class="n">other</span><span class="o">-&gt;</span><span class="n">previous</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">remove</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">previous</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">previous</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">previous</span><span class="p">;</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">previous</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">addChild</span><span class="p">(</span> <span class="n">FibonacciHeapNode</span><span class="o">&lt;</span><span class="n">Data</span><span class="p">,</span> <span class="n">Key</span><span class="o">&gt;*</span> <span class="n">other</span> <span class="p">)</span> <span class="p">{</span> <span class="c1">// Fibonacci-Heap-Link(other,current)</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">child</span> <span class="p">)</span>
      <span class="n">child</span> <span class="o">=</span> <span class="n">other</span><span class="p">;</span>
    <span class="k">else</span>
      <span class="n">child</span><span class="o">-&gt;</span><span class="n">insert</span><span class="p">(</span> <span class="n">other</span> <span class="p">);</span>
    <span class="n">other</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="n">other</span><span class="o">-&gt;</span><span class="n">mark</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">degree</span><span class="o">++</span><span class="p">;</span>
    <span class="c1">//count += other-&gt;count;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">removeChild</span><span class="p">(</span> <span class="n">FibonacciHeapNode</span><span class="o">&lt;</span><span class="n">Data</span><span class="p">,</span> <span class="n">Key</span><span class="o">&gt;*</span> <span class="n">other</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">!=</span> <span class="k">this</span> <span class="p">)</span>
      <span class="k">throw</span> <span class="n">string</span> <span class="p">(</span> <span class="s">&quot;Trying to remove a child from a non-parent&quot;</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">isSingle</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">child</span> <span class="o">!=</span> <span class="n">other</span> <span class="p">)</span>
        <span class="k">throw</span> <span class="n">string</span> <span class="p">(</span> <span class="s">&quot;Trying to remove a non-child&quot;</span> <span class="p">);</span>
      <span class="n">child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">child</span> <span class="o">==</span> <span class="n">other</span> <span class="p">)</span>
        <span class="n">child</span> <span class="o">=</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
      <span class="n">other</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">();</span> <span class="c1">// from list of children</span>
    <span class="p">}</span>
    <span class="n">other</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">other</span><span class="o">-&gt;</span><span class="n">mark</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">degree</span><span class="o">--</span><span class="p">;</span>
    <span class="c1">//count -= other-&gt;count;</span>
  <span class="p">}</span>


  <span class="k">friend</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span> <span class="p">(</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="n">FibonacciHeapNode</span><span class="o">&amp;</span> <span class="n">n</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span> <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">.</span><span class="n">myData</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">.</span><span class="n">myKey</span> <span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">printTree</span><span class="p">(</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">myData</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">myKey</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">degree</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">mark</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">child</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;(&quot;</span><span class="p">;</span>
      <span class="k">const</span> <span class="n">FibonacciHeapNode</span><span class="o">&lt;</span><span class="n">Data</span><span class="p">,</span> <span class="n">Key</span><span class="o">&gt;*</span> <span class="n">n</span> <span class="o">=</span> <span class="n">child</span><span class="p">;</span>
      <span class="k">do</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">n</span> <span class="o">==</span> <span class="k">this</span> <span class="p">)</span>
          <span class="k">throw</span> <span class="n">string</span><span class="p">(</span> <span class="s">&quot;Illegal pointer - node is child of itself&quot;</span> <span class="p">);</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">printTree</span><span class="p">(</span> <span class="n">out</span> <span class="p">);</span>
        <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">while</span> <span class="p">(</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">child</span> <span class="p">);</span>
      <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;)&quot;</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">printAll</span><span class="p">(</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">FibonacciHeapNode</span><span class="o">&lt;</span><span class="n">Data</span><span class="p">,</span> <span class="n">Key</span><span class="o">&gt;*</span> <span class="n">n</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
      <span class="n">n</span><span class="o">-&gt;</span><span class="n">printTree</span><span class="p">(</span> <span class="n">out</span> <span class="p">);</span>
      <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
      <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span> <span class="n">n</span> <span class="o">!=</span> <span class="k">this</span> <span class="p">);</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">Key</span> <span class="n">key</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">myKey</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">Data</span> <span class="n">data</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">myData</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">D</span><span class="p">,</span> <span class="k">typename</span> <span class="n">K</span><span class="o">&gt;</span> <span class="k">friend</span> <span class="k">class</span> <span class="nc">FibonacciHeap</span><span class="p">;</span>
<span class="p">};</span> <span class="c1">// FibonacciHeapNode</span>



<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Data</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Key</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">FibonacciHeap</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">FibonacciHeapNode</span><span class="o">&lt;</span><span class="n">Data</span><span class="p">,</span> <span class="n">Key</span><span class="o">&gt;*</span> <span class="n">PNode</span><span class="p">;</span>
  <span class="n">PNode</span> <span class="n">rootWithMinKey</span><span class="p">;</span> <span class="c1">// a circular d-list of nodes</span>
  <span class="n">uint</span> <span class="n">count</span><span class="p">;</span>      <span class="c1">// total number of elements in heap</span>
  <span class="n">uint</span> <span class="n">maxDegree</span><span class="p">;</span>  <span class="c1">// maximum degree (=child count) of a root in the  circular d-list</span>

<span class="k">protected</span><span class="o">:</span>
  <span class="n">PNode</span> <span class="n">insertNode</span><span class="p">(</span> <span class="n">PNode</span> <span class="n">newNode</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">//if (debug) cout &lt;&lt; &quot;insert &quot; &lt;&lt; (*newNode) &lt;&lt; endl;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">rootWithMinKey</span> <span class="p">)</span> <span class="p">{</span> <span class="c1">// insert the first myKey to the heap:</span>
      <span class="n">rootWithMinKey</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">rootWithMinKey</span><span class="o">-&gt;</span><span class="n">insert</span><span class="p">(</span> <span class="n">newNode</span> <span class="p">);</span> <span class="c1">// insert the root of new tree to the list of roots</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">newNode</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">rootWithMinKey</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">()</span> <span class="p">)</span>
        <span class="n">rootWithMinKey</span> <span class="o">=</span> <span class="n">newNode</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">newNode</span><span class="p">;</span>
  <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
  <span class="kt">bool</span> <span class="n">debug</span><span class="p">,</span> <span class="n">debugRemoveMin</span><span class="p">,</span> <span class="n">debugDecreaseKey</span><span class="p">;</span>

  <span class="n">FibonacciHeap</span><span class="p">()</span><span class="o">:</span>
      <span class="n">rootWithMinKey</span><span class="p">(</span> <span class="nb">NULL</span> <span class="p">),</span> <span class="n">count</span><span class="p">(</span> <span class="mi">0</span> <span class="p">),</span> <span class="n">maxDegree</span><span class="p">(</span> <span class="mi">0</span> <span class="p">),</span> <span class="n">debug</span><span class="p">(</span> <span class="nb">false</span> <span class="p">),</span> <span class="n">debugRemoveMin</span><span class="p">(</span> <span class="nb">false</span> <span class="p">)</span> <span class="p">{}</span>

  <span class="o">~</span><span class="n">FibonacciHeap</span><span class="p">()</span> <span class="p">{</span>
    <span class="cm">/* TODO: remove all nodes */</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">PNode</span> <span class="n">minimum</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">rootWithMinKey</span> <span class="p">)</span>
      <span class="k">throw</span> <span class="n">string</span><span class="p">(</span> <span class="s">&quot;no minimum element&quot;</span> <span class="p">);</span>
    <span class="k">return</span> <span class="n">rootWithMinKey</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">printRoots</span><span class="p">(</span> <span class="n">ostream</span><span class="o">&amp;</span> <span class="n">out</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;maxDegree=&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">maxDegree</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  count=&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">count</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  roots=&quot;</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">rootWithMinKey</span> <span class="p">)</span>
      <span class="n">rootWithMinKey</span><span class="o">-&gt;</span><span class="n">printAll</span><span class="p">(</span> <span class="n">out</span> <span class="p">);</span>
    <span class="k">else</span>
      <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">merge</span> <span class="p">(</span> <span class="k">const</span> <span class="n">FibonacciHeap</span><span class="o">&amp;</span> <span class="n">other</span> <span class="p">)</span> <span class="p">{</span> <span class="c1">// Fibonacci-Heap-Union</span>
    <span class="n">rootWithMinKey</span><span class="o">-&gt;</span><span class="n">insert</span><span class="p">(</span> <span class="n">other</span><span class="p">.</span><span class="n">rootWithMinKey</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">rootWithMinKey</span> <span class="o">||</span> <span class="p">(</span> <span class="n">other</span><span class="p">.</span><span class="n">rootWithMinKey</span> <span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">.</span><span class="n">rootWithMinKey</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">rootWithMinKey</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span>
      <span class="k">this</span><span class="o">-&gt;</span><span class="n">rootWithMinKey</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">rootWithMinKey</span><span class="p">;</span>
    <span class="n">count</span> <span class="o">+=</span> <span class="n">other</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">PNode</span> <span class="n">insert</span> <span class="p">(</span> <span class="n">Data</span> <span class="n">d</span><span class="p">,</span> <span class="n">Key</span> <span class="n">k</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">debug</span> <span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;insert &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">k</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">count</span><span class="o">++</span><span class="p">;</span>
    <span class="c1">// create a new tree with a single myKey:</span>
    <span class="k">return</span> <span class="nf">insertNode</span><span class="p">(</span> <span class="k">new</span> <span class="n">FibonacciHeapNode</span><span class="o">&lt;</span><span class="n">Data</span><span class="p">,</span> <span class="n">Key</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">d</span><span class="p">,</span> <span class="n">k</span> <span class="p">)</span> <span class="p">);</span>
  <span class="p">}</span>


  <span class="kt">void</span> <span class="n">removeMinimum</span><span class="p">()</span> <span class="p">{</span>  <span class="c1">// Fibonacci-Heap-Extract-Min, CONSOLIDATE</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">rootWithMinKey</span> <span class="p">)</span>
      <span class="k">throw</span> <span class="n">string</span><span class="p">(</span> <span class="s">&quot;trying to remove from an empty heap&quot;</span> <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">debug</span> <span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;removeMinimum&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">count</span><span class="o">--</span><span class="p">;</span>

    <span class="c1">/// Phase 1: Make all the removed root&#39;s children new roots:</span>
    <span class="c1">// Make all children of root new roots:</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">rootWithMinKey</span><span class="o">-&gt;</span><span class="n">child</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">debugRemoveMin</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  root&#39;s children: &quot;</span><span class="p">;</span>
        <span class="n">rootWithMinKey</span><span class="o">-&gt;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">printAll</span><span class="p">(</span> <span class="n">cout</span> <span class="p">);</span>
      <span class="p">}</span>
      <span class="n">PNode</span> <span class="n">c</span> <span class="o">=</span> <span class="n">rootWithMinKey</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">;</span>
      <span class="k">do</span> <span class="p">{</span>
        <span class="n">c</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">while</span> <span class="p">(</span> <span class="n">c</span> <span class="o">!=</span> <span class="n">rootWithMinKey</span><span class="o">-&gt;</span><span class="n">child</span> <span class="p">);</span>
      <span class="n">rootWithMinKey</span><span class="o">-&gt;</span><span class="n">child</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// removed all children</span>
      <span class="n">rootWithMinKey</span><span class="o">-&gt;</span><span class="n">insert</span><span class="p">(</span> <span class="n">c</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">debugRemoveMin</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  roots after inserting children: &quot;</span><span class="p">;</span>
      <span class="n">printRoots</span><span class="p">(</span> <span class="n">cout</span> <span class="p">);</span>
    <span class="p">}</span>


    <span class="c1">/// Phase 2-a: handle the case where we delete the last myKey:</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">rootWithMinKey</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="n">rootWithMinKey</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">debugRemoveMin</span> <span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  removed the last&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">count</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
        <span class="k">throw</span> <span class="n">string</span> <span class="p">(</span> <span class="s">&quot;Internal error: should have 0 keys&quot;</span> <span class="p">);</span>
      <span class="n">rootWithMinKey</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">/// Phase 2: merge roots with the same degree:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">PNode</span><span class="o">&gt;</span> <span class="n">degreeRoots</span> <span class="p">(</span> <span class="n">maxDegree</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">);</span> <span class="c1">// make room for a new degree</span>
    <span class="n">fill</span> <span class="p">(</span> <span class="n">degreeRoots</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">degreeRoots</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">(</span> <span class="n">PNode</span> <span class="p">)</span><span class="nb">NULL</span> <span class="p">);</span>
    <span class="n">maxDegree</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">PNode</span> <span class="n">currentPointer</span> <span class="o">=</span> <span class="n">rootWithMinKey</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">currentDegree</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
      <span class="n">currentDegree</span> <span class="o">=</span> <span class="n">currentPointer</span><span class="o">-&gt;</span><span class="n">degree</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">debugRemoveMin</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  roots starting from currentPointer: &quot;</span><span class="p">;</span>
        <span class="n">currentPointer</span><span class="o">-&gt;</span><span class="n">printAll</span><span class="p">(</span> <span class="n">cout</span> <span class="p">);</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  checking root &quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">currentPointer</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; with degree &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">currentDegree</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="n">PNode</span> <span class="n">current</span> <span class="o">=</span> <span class="n">currentPointer</span><span class="p">;</span>
      <span class="n">currentPointer</span> <span class="o">=</span> <span class="n">currentPointer</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span> <span class="n">degreeRoots</span><span class="p">[</span><span class="n">currentDegree</span><span class="p">]</span> <span class="p">)</span> <span class="p">{</span> <span class="c1">// merge the two roots with the same degree:</span>
        <span class="n">PNode</span> <span class="n">other</span> <span class="o">=</span> <span class="n">degreeRoots</span><span class="p">[</span><span class="n">currentDegree</span><span class="p">];</span> <span class="c1">// another root with the same degree</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">()</span> <span class="p">)</span>
          <span class="n">swap</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">current</span> <span class="p">);</span>
        <span class="c1">// now current-&gt;key() &lt;= other-&gt;key() - make other a child of current:</span>
        <span class="n">other</span><span class="o">-&gt;</span><span class="n">remove</span><span class="p">();</span> <span class="c1">// remove from list of roots</span>
        <span class="n">current</span><span class="o">-&gt;</span><span class="n">addChild</span><span class="p">(</span> <span class="n">other</span> <span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">debugRemoveMin</span> <span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  added &quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">other</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; as child of &quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">current</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">degreeRoots</span><span class="p">[</span><span class="n">currentDegree</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">currentDegree</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">currentDegree</span> <span class="o">&gt;=</span> <span class="n">degreeRoots</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">)</span>
          <span class="n">degreeRoots</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="p">(</span> <span class="n">PNode</span> <span class="p">)</span><span class="nb">NULL</span> <span class="p">);</span>
      <span class="p">}</span>
      <span class="c1">// keep the current root as the first of its degree in the degrees array:</span>
      <span class="n">degreeRoots</span><span class="p">[</span><span class="n">currentDegree</span><span class="p">]</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span> <span class="n">currentPointer</span> <span class="o">!=</span> <span class="n">rootWithMinKey</span> <span class="p">);</span>

    <span class="c1">/// Phase 3: remove the current root, and calcualte the new rootWithMinKey:</span>
    <span class="k">delete</span> <span class="n">rootWithMinKey</span><span class="p">;</span>
    <span class="n">rootWithMinKey</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">uint</span> <span class="n">newMaxDegree</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="n">uint</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">degreeRoots</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">d</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">debugRemoveMin</span> <span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  degree &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;: &quot;</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">degreeRoots</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">debugRemoveMin</span> <span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">degreeRoots</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">degreeRoots</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">degreeRoots</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">previous</span> <span class="o">=</span> <span class="n">degreeRoots</span><span class="p">[</span><span class="n">d</span><span class="p">];</span>
        <span class="n">insertNode</span><span class="p">(</span> <span class="n">degreeRoots</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="n">newMaxDegree</span> <span class="p">)</span>
          <span class="n">newMaxDegree</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">debugRemoveMin</span> <span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  no node&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">maxDegree</span> <span class="o">=</span> <span class="n">newMaxDegree</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">decreaseKey</span><span class="p">(</span> <span class="n">PNode</span> <span class="n">node</span><span class="p">,</span> <span class="n">Key</span> <span class="n">newKey</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">newKey</span> <span class="o">&gt;=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">myKey</span> <span class="p">)</span>
      <span class="k">throw</span> <span class="n">string</span><span class="p">(</span> <span class="s">&quot;Trying to decrease key to a greater key&quot;</span> <span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">debug</span> <span class="p">)</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;decrease key of &quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">node</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; to &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">newKey</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="c1">// Update the key and possibly the min key:</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">myKey</span> <span class="o">=</span> <span class="n">newKey</span><span class="p">;</span>

    <span class="c1">// Check if the new key violates the heap invariant:</span>
    <span class="n">PNode</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">parent</span> <span class="p">)</span> <span class="p">{</span> <span class="c1">// root node - just make sure the minimum is correct</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">newKey</span> <span class="o">&lt;</span> <span class="n">rootWithMinKey</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">()</span> <span class="p">)</span>
        <span class="n">rootWithMinKey</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span> <span class="c1">// heap invariant not violated - nothing more to do</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">newKey</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span><span class="p">;</span> <span class="c1">// heap invariant not violated - nothing more to do</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span> <span class="p">;;</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">parent</span><span class="o">-&gt;</span><span class="n">removeChild</span><span class="p">(</span> <span class="n">node</span> <span class="p">);</span>
      <span class="n">insertNode</span><span class="p">(</span> <span class="n">node</span> <span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">debugDecreaseKey</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  removed &quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">node</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; as child of &quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">parent</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  roots after remove: &quot;</span><span class="p">;</span>
        <span class="n">rootWithMinKey</span><span class="o">-&gt;</span><span class="n">printAll</span><span class="p">(</span> <span class="n">cout</span> <span class="p">);</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="p">)</span> <span class="p">{</span> <span class="c1">// parent is a root - nothing more to do</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">mark</span> <span class="p">)</span> <span class="p">{</span> <span class="c1">// parent is not a root and is not marked - just mark it</span>
        <span class="n">parent</span><span class="o">-&gt;</span><span class="n">mark</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">remove</span><span class="p">(</span> <span class="n">PNode</span> <span class="n">node</span><span class="p">,</span> <span class="n">Key</span> <span class="n">minusInfinity</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">minusInfinity</span> <span class="o">&gt;=</span> <span class="n">minimum</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">()</span> <span class="p">)</span>
      <span class="k">throw</span> <span class="n">string</span><span class="p">(</span> <span class="s">&quot;2nd argument to remove must be a key that is smaller than all other keys&quot;</span> <span class="p">);</span>
    <span class="n">decreaseKey</span><span class="p">(</span> <span class="n">node</span><span class="p">,</span> <span class="n">minusInfinity</span> <span class="p">);</span>
    <span class="n">removeMinimum</span><span class="p">();</span>
  <span class="p">}</span>

<span class="p">};</span>  <span class="c1">// FibonacciHeap</span>


<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     fibonacci_heap.h</span>
<span class="cm"> * @brief    Fibonacci Heap</span>
<span class="cm"> *</span>
<span class="cm"> * @ref http://en.wikipedia.org/wiki/Fibonacci_heap</span>
<span class="cm"> * @ref http://www.cse.yorku.ca/~aaw/Jason/FibonacciHeapAlgorithm.html</span>
<span class="cm"> * @author Erel Segal http://tora.us.fm/rentabrain</span>
<span class="cm"> * @date 2010-11-11</span>
<span class="cm"> */</span>

<span class="cm">/**</span>
<span class="cm"> * chuanqi.tan(at)gmail.com  引用说明</span>
<span class="cm"> *</span>
<span class="cm"> * 斐波那契堆与二项堆非常类似，就不再自己重新写了。</span>
<span class="cm"> * 这里的代码转载自：http://ideone.com/9jYnv 这种代码的风格非常现代化我非常喜欢，故引用了这份代码</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;fibonacci_heap.h&quot;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>

<span class="c1">/// 斐波那契堆</span>
<span class="kt">int</span> <span class="n">testFibonacciHeap</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="n">FibonacciHeap</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">uint</span><span class="o">&gt;</span> <span class="n">h</span><span class="p">;</span>
    <span class="n">h</span><span class="p">.</span><span class="n">debug</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">h</span><span class="p">.</span><span class="n">debugRemoveMin</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">h</span><span class="p">.</span><span class="n">debugDecreaseKey</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="n">h</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>
    <span class="n">h</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
    <span class="n">h</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="mi">7</span> <span class="p">);</span>
    <span class="n">h</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="s">&quot;d&quot;</span><span class="p">,</span> <span class="mi">5</span> <span class="p">);</span>
    <span class="n">h</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
    <span class="n">h</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="mi">8</span> <span class="p">);</span>
    <span class="n">h</span><span class="p">.</span><span class="n">printRoots</span><span class="p">(</span> <span class="n">cout</span> <span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span> <span class="o">!</span><span class="n">h</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;min=&quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">h</span><span class="p">.</span><span class="n">minimum</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="n">h</span><span class="p">.</span><span class="n">removeMinimum</span><span class="p">();</span>
      <span class="n">h</span><span class="p">.</span><span class="n">printRoots</span><span class="p">(</span> <span class="n">cout</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="n">vector</span> <span class="o">&lt;</span><span class="n">FibonacciHeapNode</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">uint</span><span class="o">&gt;*&gt;</span> <span class="n">nodes</span><span class="p">(</span> <span class="mi">6</span> <span class="p">);</span>
    <span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">400</span> <span class="p">);</span>
    <span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="mi">200</span> <span class="p">);</span>
    <span class="n">nodes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="mi">70</span> <span class="p">);</span>
    <span class="n">nodes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="s">&quot;d&quot;</span><span class="p">,</span> <span class="mi">50</span> <span class="p">);</span>
    <span class="n">nodes</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="s">&quot;e&quot;</span><span class="p">,</span> <span class="mi">10</span> <span class="p">);</span>
    <span class="n">nodes</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="s">&quot;f&quot;</span><span class="p">,</span> <span class="mi">80</span> <span class="p">);</span>
    <span class="n">h</span><span class="p">.</span><span class="n">printRoots</span><span class="p">(</span> <span class="n">cout</span> <span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;min=&quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">h</span><span class="p">.</span><span class="n">minimum</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="n">h</span><span class="p">.</span><span class="n">removeMinimum</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;min=&quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">h</span><span class="p">.</span><span class="n">minimum</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">nodes</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">h</span><span class="p">.</span><span class="n">printRoots</span><span class="p">(</span> <span class="n">cout</span> <span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span> <span class="n">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nodes</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span> <span class="c1">// minimum - already removed</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="n">h</span><span class="p">.</span><span class="n">decreaseKey</span><span class="p">(</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">()</span> <span class="o">/</span> <span class="mi">10</span> <span class="p">);</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;min=&quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">h</span><span class="p">.</span><span class="n">minimum</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="n">h</span><span class="p">.</span><span class="n">printRoots</span><span class="p">(</span> <span class="n">cout</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="n">h</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="s">&quot;AA&quot;</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>
    <span class="n">h</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="s">&quot;BB&quot;</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
    <span class="n">h</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="s">&quot;CC&quot;</span><span class="p">,</span> <span class="mi">7</span> <span class="p">);</span>
    <span class="n">h</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="s">&quot;DD&quot;</span><span class="p">,</span> <span class="mi">5</span> <span class="p">);</span>
    <span class="n">h</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="s">&quot;EE&quot;</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
    <span class="n">h</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="s">&quot;FF&quot;</span><span class="p">,</span> <span class="mi">8</span> <span class="p">);</span>
    <span class="n">h</span><span class="p">.</span><span class="n">printRoots</span><span class="p">(</span> <span class="n">cout</span> <span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span> <span class="o">!</span><span class="n">h</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;min=&quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">h</span><span class="p">.</span><span class="n">minimum</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="n">h</span><span class="p">.</span><span class="n">removeMinimum</span><span class="p">();</span>
      <span class="n">h</span><span class="p">.</span><span class="n">printRoots</span><span class="p">(</span> <span class="n">cout</span> <span class="p">);</span>
    <span class="p">}</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span> <span class="n">string</span> <span class="n">s</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;ERROR: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">testFibonacciHeap</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">insert</span> <span class="nl">a</span><span class="p">:</span><span class="mi">4</span>
<span class="n">insert</span> <span class="nl">b</span><span class="p">:</span><span class="mi">2</span>
<span class="n">insert</span> <span class="nl">c</span><span class="p">:</span><span class="mi">7</span>
<span class="n">insert</span> <span class="nl">d</span><span class="p">:</span><span class="mi">5</span>
<span class="n">insert</span> <span class="nl">e</span><span class="p">:</span><span class="mi">1</span>
<span class="n">insert</span> <span class="nl">f</span><span class="p">:</span><span class="mi">8</span>
<span class="n">maxDegree</span><span class="o">=</span><span class="mi">0</span>  <span class="n">count</span><span class="o">=</span><span class="mi">6</span>  <span class="n">roots</span><span class="o">=</span><span class="nl">e</span><span class="p">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">f</span><span class="p">:</span><span class="mi">8</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">d</span><span class="p">:</span><span class="mi">5</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">c</span><span class="p">:</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">a</span><span class="p">:</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">b</span><span class="p">:</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> 
<span class="n">min</span><span class="o">=</span><span class="nl">e</span><span class="p">:</span><span class="mi">1</span>
<span class="n">removeMinimum</span>
<span class="n">maxDegree</span><span class="o">=</span><span class="mi">2</span>  <span class="n">count</span><span class="o">=</span><span class="mi">5</span>  <span class="n">roots</span><span class="o">=</span><span class="nl">b</span><span class="p">:</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">a</span><span class="p">:</span><span class="mi">4</span><span class="o">:</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">c</span><span class="p">:</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">d</span><span class="p">:</span><span class="mi">5</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">f</span><span class="p">:</span><span class="mi">8</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="p">)</span> <span class="p">)</span> 
<span class="n">min</span><span class="o">=</span><span class="nl">b</span><span class="p">:</span><span class="mi">2</span>
<span class="n">removeMinimum</span>
<span class="n">maxDegree</span><span class="o">=</span><span class="mi">2</span>  <span class="n">count</span><span class="o">=</span><span class="mi">4</span>  <span class="n">roots</span><span class="o">=</span><span class="nl">a</span><span class="p">:</span><span class="mi">4</span><span class="o">:</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">c</span><span class="p">:</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">d</span><span class="p">:</span><span class="mi">5</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">f</span><span class="p">:</span><span class="mi">8</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="p">)</span> <span class="p">)</span> 
<span class="n">min</span><span class="o">=</span><span class="nl">a</span><span class="p">:</span><span class="mi">4</span>
<span class="n">removeMinimum</span>
<span class="n">maxDegree</span><span class="o">=</span><span class="mi">1</span>  <span class="n">count</span><span class="o">=</span><span class="mi">3</span>  <span class="n">roots</span><span class="o">=</span><span class="nl">d</span><span class="p">:</span><span class="mi">5</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">f</span><span class="p">:</span><span class="mi">8</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="p">)</span> <span class="nl">c</span><span class="p">:</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> 
<span class="n">min</span><span class="o">=</span><span class="nl">d</span><span class="p">:</span><span class="mi">5</span>
<span class="n">removeMinimum</span>
<span class="n">maxDegree</span><span class="o">=</span><span class="mi">1</span>  <span class="n">count</span><span class="o">=</span><span class="mi">2</span>  <span class="n">roots</span><span class="o">=</span><span class="nl">c</span><span class="p">:</span><span class="mi">7</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">f</span><span class="p">:</span><span class="mi">8</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="p">)</span> 
<span class="n">min</span><span class="o">=</span><span class="nl">c</span><span class="p">:</span><span class="mi">7</span>
<span class="n">removeMinimum</span>
<span class="n">maxDegree</span><span class="o">=</span><span class="mi">0</span>  <span class="n">count</span><span class="o">=</span><span class="mi">1</span>  <span class="n">roots</span><span class="o">=</span><span class="nl">f</span><span class="p">:</span><span class="mi">8</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> 
<span class="n">min</span><span class="o">=</span><span class="nl">f</span><span class="p">:</span><span class="mi">8</span>
<span class="n">removeMinimum</span>
<span class="n">maxDegree</span><span class="o">=</span><span class="mi">0</span>  <span class="n">count</span><span class="o">=</span><span class="mi">0</span>  <span class="n">roots</span><span class="o">=</span>


<span class="n">insert</span> <span class="nl">a</span><span class="p">:</span><span class="mi">400</span>
<span class="n">insert</span> <span class="nl">b</span><span class="p">:</span><span class="mi">200</span>
<span class="n">insert</span> <span class="nl">c</span><span class="p">:</span><span class="mi">70</span>
<span class="n">insert</span> <span class="nl">d</span><span class="p">:</span><span class="mi">50</span>
<span class="n">insert</span> <span class="nl">e</span><span class="p">:</span><span class="mi">10</span>
<span class="n">insert</span> <span class="nl">f</span><span class="p">:</span><span class="mi">80</span>
<span class="n">maxDegree</span><span class="o">=</span><span class="mi">0</span>  <span class="n">count</span><span class="o">=</span><span class="mi">6</span>  <span class="n">roots</span><span class="o">=</span><span class="nl">e</span><span class="p">:</span><span class="mi">10</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">f</span><span class="p">:</span><span class="mi">80</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">a</span><span class="p">:</span><span class="mi">400</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">b</span><span class="p">:</span><span class="mi">200</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">c</span><span class="p">:</span><span class="mi">70</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">d</span><span class="p">:</span><span class="mi">50</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> 
<span class="n">min</span><span class="o">=</span><span class="nl">e</span><span class="p">:</span><span class="mi">10</span>
<span class="n">removeMinimum</span>
<span class="n">min</span><span class="o">=</span><span class="nl">d</span><span class="p">:</span><span class="mi">50</span>
<span class="n">maxDegree</span><span class="o">=</span><span class="mi">2</span>  <span class="n">count</span><span class="o">=</span><span class="mi">5</span>  <span class="n">roots</span><span class="o">=</span><span class="nl">d</span><span class="p">:</span><span class="mi">50</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">c</span><span class="p">:</span><span class="mi">70</span><span class="o">:</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">b</span><span class="p">:</span><span class="mi">200</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">f</span><span class="p">:</span><span class="mi">80</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span><span class="mi">400</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="p">)</span> <span class="p">)</span> 
<span class="n">decrease</span> <span class="n">key</span> <span class="n">of</span> <span class="nl">a</span><span class="p">:</span><span class="mi">400</span> <span class="n">to</span> <span class="mi">40</span>
<span class="n">min</span><span class="o">=</span><span class="nl">a</span><span class="p">:</span><span class="mi">40</span>
<span class="n">maxDegree</span><span class="o">=</span><span class="mi">2</span>  <span class="n">count</span><span class="o">=</span><span class="mi">5</span>  <span class="n">roots</span><span class="o">=</span><span class="nl">a</span><span class="p">:</span><span class="mi">40</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">c</span><span class="p">:</span><span class="mi">70</span><span class="o">:</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">b</span><span class="p">:</span><span class="mi">200</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">f</span><span class="p">:</span><span class="mi">80</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span> <span class="p">)</span> <span class="nl">d</span><span class="p">:</span><span class="mi">50</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> 
<span class="n">decrease</span> <span class="n">key</span> <span class="n">of</span> <span class="nl">b</span><span class="p">:</span><span class="mi">200</span> <span class="n">to</span> <span class="mi">20</span>
<span class="n">min</span><span class="o">=</span><span class="nl">b</span><span class="p">:</span><span class="mi">20</span>
<span class="n">maxDegree</span><span class="o">=</span><span class="mi">2</span>  <span class="n">count</span><span class="o">=</span><span class="mi">5</span>  <span class="n">roots</span><span class="o">=</span><span class="nl">b</span><span class="p">:</span><span class="mi">20</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">c</span><span class="p">:</span><span class="mi">70</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">f</span><span class="p">:</span><span class="mi">80</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span> <span class="p">)</span> <span class="nl">d</span><span class="p">:</span><span class="mi">50</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">a</span><span class="p">:</span><span class="mi">40</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> 
<span class="n">decrease</span> <span class="n">key</span> <span class="n">of</span> <span class="nl">c</span><span class="p">:</span><span class="mi">70</span> <span class="n">to</span> <span class="mi">7</span>
<span class="n">min</span><span class="o">=</span><span class="nl">c</span><span class="p">:</span><span class="mi">7</span>
<span class="n">maxDegree</span><span class="o">=</span><span class="mi">2</span>  <span class="n">count</span><span class="o">=</span><span class="mi">5</span>  <span class="n">roots</span><span class="o">=</span><span class="nl">c</span><span class="p">:</span><span class="mi">7</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">f</span><span class="p">:</span><span class="mi">80</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span> <span class="p">)</span> <span class="nl">d</span><span class="p">:</span><span class="mi">50</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">a</span><span class="p">:</span><span class="mi">40</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">b</span><span class="p">:</span><span class="mi">20</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> 
<span class="n">decrease</span> <span class="n">key</span> <span class="n">of</span> <span class="nl">d</span><span class="p">:</span><span class="mi">50</span> <span class="n">to</span> <span class="mi">5</span>
<span class="n">min</span><span class="o">=</span><span class="nl">d</span><span class="p">:</span><span class="mi">5</span>
<span class="n">maxDegree</span><span class="o">=</span><span class="mi">2</span>  <span class="n">count</span><span class="o">=</span><span class="mi">5</span>  <span class="n">roots</span><span class="o">=</span><span class="nl">d</span><span class="p">:</span><span class="mi">5</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">a</span><span class="p">:</span><span class="mi">40</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">b</span><span class="p">:</span><span class="mi">20</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">c</span><span class="p">:</span><span class="mi">7</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">f</span><span class="p">:</span><span class="mi">80</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span> <span class="p">)</span> 
<span class="n">decrease</span> <span class="n">key</span> <span class="n">of</span> <span class="nl">f</span><span class="p">:</span><span class="mi">80</span> <span class="n">to</span> <span class="mi">8</span>
<span class="n">min</span><span class="o">=</span><span class="nl">d</span><span class="p">:</span><span class="mi">5</span>
<span class="n">maxDegree</span><span class="o">=</span><span class="mi">2</span>  <span class="n">count</span><span class="o">=</span><span class="mi">5</span>  <span class="n">roots</span><span class="o">=</span><span class="nl">d</span><span class="p">:</span><span class="mi">5</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">a</span><span class="p">:</span><span class="mi">40</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">b</span><span class="p">:</span><span class="mi">20</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">c</span><span class="p">:</span><span class="mi">7</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">f</span><span class="p">:</span><span class="mi">8</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span> <span class="p">)</span> 


<span class="n">insert</span> <span class="nl">AA</span><span class="p">:</span><span class="mi">4</span>
<span class="n">insert</span> <span class="nl">BB</span><span class="p">:</span><span class="mi">2</span>
<span class="n">insert</span> <span class="nl">CC</span><span class="p">:</span><span class="mi">7</span>
<span class="n">insert</span> <span class="nl">DD</span><span class="p">:</span><span class="mi">5</span>
<span class="n">insert</span> <span class="nl">EE</span><span class="p">:</span><span class="mi">1</span>
<span class="n">insert</span> <span class="nl">FF</span><span class="p">:</span><span class="mi">8</span>
<span class="n">maxDegree</span><span class="o">=</span><span class="mi">2</span>  <span class="n">count</span><span class="o">=</span><span class="mi">11</span>  <span class="n">roots</span><span class="o">=</span><span class="nl">EE</span><span class="p">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">FF</span><span class="p">:</span><span class="mi">8</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">DD</span><span class="p">:</span><span class="mi">5</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">CC</span><span class="p">:</span><span class="mi">7</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">a</span><span class="p">:</span><span class="mi">40</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">b</span><span class="p">:</span><span class="mi">20</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">c</span><span class="p">:</span><span class="mi">7</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">f</span><span class="p">:</span><span class="mi">8</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span> <span class="p">)</span> <span class="nl">d</span><span class="p">:</span><span class="mi">5</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">AA</span><span class="p">:</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">BB</span><span class="p">:</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> 
<span class="n">min</span><span class="o">=</span><span class="nl">EE</span><span class="p">:</span><span class="mi">1</span>
<span class="n">removeMinimum</span>
<span class="n">maxDegree</span><span class="o">=</span><span class="mi">3</span>  <span class="n">count</span><span class="o">=</span><span class="mi">10</span>  <span class="n">roots</span><span class="o">=</span><span class="nl">BB</span><span class="p">:</span><span class="mi">2</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">AA</span><span class="p">:</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="p">)</span> <span class="nl">d</span><span class="p">:</span><span class="mi">5</span><span class="o">:</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">b</span><span class="p">:</span><span class="mi">20</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">DD</span><span class="p">:</span><span class="mi">5</span><span class="o">:</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">FF</span><span class="p">:</span><span class="mi">8</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">CC</span><span class="p">:</span><span class="mi">7</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span><span class="mi">40</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="p">)</span> <span class="p">)</span> <span class="nl">c</span><span class="p">:</span><span class="mi">7</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">f</span><span class="p">:</span><span class="mi">8</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> 
<span class="n">min</span><span class="o">=</span><span class="nl">BB</span><span class="p">:</span><span class="mi">2</span>
<span class="n">removeMinimum</span>
<span class="n">maxDegree</span><span class="o">=</span><span class="mi">3</span>  <span class="n">count</span><span class="o">=</span><span class="mi">9</span>  <span class="n">roots</span><span class="o">=</span><span class="nl">AA</span><span class="p">:</span><span class="mi">4</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">d</span><span class="p">:</span><span class="mi">5</span><span class="o">:</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">b</span><span class="p">:</span><span class="mi">20</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">DD</span><span class="p">:</span><span class="mi">5</span><span class="o">:</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">FF</span><span class="p">:</span><span class="mi">8</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">CC</span><span class="p">:</span><span class="mi">7</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span><span class="mi">40</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="p">)</span> <span class="p">)</span> <span class="nl">c</span><span class="p">:</span><span class="mi">7</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">f</span><span class="p">:</span><span class="mi">8</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> 
<span class="n">min</span><span class="o">=</span><span class="nl">AA</span><span class="p">:</span><span class="mi">4</span>
<span class="n">removeMinimum</span>
<span class="n">maxDegree</span><span class="o">=</span><span class="mi">3</span>  <span class="n">count</span><span class="o">=</span><span class="mi">8</span>  <span class="n">roots</span><span class="o">=</span><span class="nl">d</span><span class="p">:</span><span class="mi">5</span><span class="o">:</span><span class="mi">3</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">b</span><span class="p">:</span><span class="mi">20</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">DD</span><span class="p">:</span><span class="mi">5</span><span class="o">:</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">FF</span><span class="p">:</span><span class="mi">8</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">CC</span><span class="p">:</span><span class="mi">7</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span><span class="mi">40</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="p">)</span> <span class="p">)</span> <span class="nl">c</span><span class="p">:</span><span class="mi">7</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">f</span><span class="p">:</span><span class="mi">8</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> 
<span class="n">min</span><span class="o">=</span><span class="nl">d</span><span class="p">:</span><span class="mi">5</span>
<span class="n">removeMinimum</span>
<span class="n">maxDegree</span><span class="o">=</span><span class="mi">2</span>  <span class="n">count</span><span class="o">=</span><span class="mi">7</span>  <span class="n">roots</span><span class="o">=</span><span class="nl">DD</span><span class="p">:</span><span class="mi">5</span><span class="o">:</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">FF</span><span class="p">:</span><span class="mi">8</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">CC</span><span class="p">:</span><span class="mi">7</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span><span class="mi">40</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="p">)</span> <span class="p">)</span> <span class="nl">b</span><span class="p">:</span><span class="mi">20</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">c</span><span class="p">:</span><span class="mi">7</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">f</span><span class="p">:</span><span class="mi">8</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span> <span class="p">)</span> 
<span class="n">min</span><span class="o">=</span><span class="nl">DD</span><span class="p">:</span><span class="mi">5</span>
<span class="n">removeMinimum</span>
<span class="n">maxDegree</span><span class="o">=</span><span class="mi">2</span>  <span class="n">count</span><span class="o">=</span><span class="mi">6</span>  <span class="n">roots</span><span class="o">=</span><span class="nl">c</span><span class="p">:</span><span class="mi">7</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">f</span><span class="p">:</span><span class="mi">8</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span> <span class="p">)</span> <span class="nl">CC</span><span class="p">:</span><span class="mi">7</span><span class="o">:</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span><span class="mi">40</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">FF</span><span class="p">:</span><span class="mi">8</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">b</span><span class="p">:</span><span class="mi">20</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="p">)</span> <span class="p">)</span> 
<span class="n">min</span><span class="o">=</span><span class="nl">c</span><span class="p">:</span><span class="mi">7</span>
<span class="n">removeMinimum</span>
<span class="n">maxDegree</span><span class="o">=</span><span class="mi">2</span>  <span class="n">count</span><span class="o">=</span><span class="mi">5</span>  <span class="n">roots</span><span class="o">=</span><span class="nl">CC</span><span class="p">:</span><span class="mi">7</span><span class="o">:</span><span class="mi">2</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span><span class="mi">40</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">FF</span><span class="p">:</span><span class="mi">8</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">b</span><span class="p">:</span><span class="mi">20</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="p">)</span> <span class="p">)</span> <span class="nl">f</span><span class="p">:</span><span class="mi">8</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span> 
<span class="n">min</span><span class="o">=</span><span class="nl">CC</span><span class="p">:</span><span class="mi">7</span>
<span class="n">removeMinimum</span>
<span class="n">maxDegree</span><span class="o">=</span><span class="mi">2</span>  <span class="n">count</span><span class="o">=</span><span class="mi">4</span>  <span class="n">roots</span><span class="o">=</span><span class="nl">f</span><span class="p">:</span><span class="mi">8</span><span class="o">:</span><span class="mi">2</span><span class="o">:</span><span class="mi">1</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span><span class="mi">40</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="nl">FF</span><span class="p">:</span><span class="mi">8</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">b</span><span class="p">:</span><span class="mi">20</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="p">)</span> <span class="p">)</span> 
<span class="n">min</span><span class="o">=</span><span class="nl">f</span><span class="p">:</span><span class="mi">8</span>
<span class="n">removeMinimum</span>
<span class="n">maxDegree</span><span class="o">=</span><span class="mi">1</span>  <span class="n">count</span><span class="o">=</span><span class="mi">3</span>  <span class="n">roots</span><span class="o">=</span><span class="nl">FF</span><span class="p">:</span><span class="mi">8</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">b</span><span class="p">:</span><span class="mi">20</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="p">)</span> <span class="nl">a</span><span class="p">:</span><span class="mi">40</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> 
<span class="n">min</span><span class="o">=</span><span class="nl">FF</span><span class="p">:</span><span class="mi">8</span>
<span class="n">removeMinimum</span>
<span class="n">maxDegree</span><span class="o">=</span><span class="mi">1</span>  <span class="n">count</span><span class="o">=</span><span class="mi">2</span>  <span class="n">roots</span><span class="o">=</span><span class="nl">b</span><span class="p">:</span><span class="mi">20</span><span class="o">:</span><span class="mi">1</span><span class="o">:</span><span class="mi">0</span><span class="p">(</span><span class="nl">a</span><span class="p">:</span><span class="mi">40</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> <span class="p">)</span> 
<span class="n">min</span><span class="o">=</span><span class="nl">b</span><span class="p">:</span><span class="mi">20</span>
<span class="n">removeMinimum</span>
<span class="n">maxDegree</span><span class="o">=</span><span class="mi">0</span>  <span class="n">count</span><span class="o">=</span><span class="mi">1</span>  <span class="n">roots</span><span class="o">=</span><span class="nl">a</span><span class="p">:</span><span class="mi">40</span><span class="o">:</span><span class="mi">0</span><span class="o">:</span><span class="mi">0</span> 
<span class="n">min</span><span class="o">=</span><span class="nl">a</span><span class="p">:</span><span class="mi">40</span>
<span class="n">removeMinimum</span>
<span class="n">maxDegree</span><span class="o">=</span><span class="mi">0</span>  <span class="n">count</span><span class="o">=</span><span class="mi">0</span>  <span class="n">roots</span><span class="o">=</span>
</pre></div>
</div>
</div>
<div class="section" id="id27">
<h3>第21章：用于不相交集合的数据结构<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h3>
<ul>
<li><p class="first">用于不相交集合的数据结构又称为 <strong>查并集</strong> ：在很多的应用中（比如图的算法中经常使用，还有哈夫曼编码等），将N个不同的元素分成一组不相交的集合，不相交集合上有两个重要的操作：</p>
<ul class="simple">
<li><strong>找出给定元素所属的集合</strong></li>
<li><strong>合并两个集合</strong></li>
</ul>
</li>
<li><p class="first">常用的两种表示方法：一种为链表的实现；另一种是更有效的树的表示法。</p>
</li>
<li><dl class="first docutils">
<dt>采用树的表示法的运行时间在实践上是线性的，但从理论上来说是超线性的。</dt>
<dd><p class="first last">这句话的意思是：理论上分析的运行时间是大于（超过）线性的，但是在实践中证明它的运行时间却是线性的。</p>
</dd>
</dl>
</li>
<li><p class="first">每个集合通过一个代表来识别，代表即集合中的某个成员。在某些应用中，哪一个成员被选作代表是无所谓的，而关键的是在集合未被修改的前提下，两次寻找得到的答案应该是相同的。</p>
</li>
<li><p class="first">不相交集合的链表表示：</p>
<img alt="../../_images/cbj1.jpg" src="../../_images/cbj1.jpg" />
<ul class="simple">
<li>每个链表的第一个对象作为它所在集合的代表</li>
<li>链表上的第个结点都有指向它所在集合的代表的指针，从而使得找出所属集合的操作时间降为O(1)</li>
<li>但是因为每个结点都有指向代表的指针，使得在进行合并操作时，需要更新所有结点的指向代表的指针，从而时间复杂度为O(n)。这算是有利也有弊吧。</li>
<li><dl class="first docutils">
<dt>一种加权合并启发式策略：在进行合并操作时，总是把较短的表拼到较长的表上去。</dt>
<dd>这种简单的小技巧的正式的名字都可以叫做：启发式信息，启发式策略！以后涉及到这种情况的时候也可以这么叫。</dd>
</dl>
</li>
</ul>
</li>
<li><p class="first">不相交集合森林表示法：用有根树来表示集合，树中的每个结点都包含集合的一个成员，每棵树表示一个集合。每个成员仅指向其父结点，每棵树的根包含了代表，并且是它自己的父结点。</p>
<img alt="../../_images/cbj2.png" src="../../_images/cbj2.png" />
</li>
<li><p class="first">在引入了两种启发式策略（按秩合并、路径压缩）之后，不相交集合森林表示法就是目前已经的、渐近意义最快的不相交集合数据结构了。</p>
<ul>
<li><p class="first">接秩合并：便包含较少结点的树的根指向包含较多结点的树的根。秩表示的是结点高度的一个上界。
每个结点的秩是结点高度的一个上界，只有在进行UNION操作时，而且进行合并操作的两个集合的秩相同时，才会给最后的根结点的秩+1。代码如下:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">_Link</span><span class="p">(</span><span class="n">DisjointSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">DisjointSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">Rank</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">.</span><span class="n">Rank</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">y</span><span class="p">.</span><span class="n">Parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">.</span><span class="n">Parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">Rank</span> <span class="o">==</span> <span class="n">y</span><span class="p">.</span><span class="n">Rank</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//只有在秩相同时才会将最后的根结点的秩+1</span>
    <span class="o">++</span><span class="n">y</span><span class="p">.</span><span class="n">Rank</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p class="first">路径压缩：（查找路径：在查找一个结点所属的集合时的查找路径上访问过的所有的结点）在每次进行查找元素所属集合的操作时，使得查找路径上的每个结点都直接指向根结点。路径压缩并不改变结点的秩。
这种路径压缩使用了两趟的方法：一趟是沿查找路径向上升，直至找到根；第二趟时沿查找路径下降，以便更新查找路径上的每个结点，使之指向根。这种路径压缩的思想简直是太棒了！神奇啊！应该学习这种思想，碰到类似的问题也要想到类似的解决办法</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><img alt="../../_images/cbj3.jpg" class="first last" src="../../_images/cbj3.jpg" />
</td>
<td><p class="first">代码如下:</p>
<div class="last highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">static</span> <span class="n">DisjointSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">FindSet</span><span class="p">(</span><span class="n">DisjointSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a_set</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//路径压缩</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">a_set</span> <span class="o">!=</span> <span class="n">a_set</span><span class="p">.</span><span class="n">Parent</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//判断本身不是代表</span>
    <span class="n">a_set</span><span class="p">.</span><span class="n">Parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">FindSet</span><span class="p">(</span><span class="o">*</span><span class="n">a_set</span><span class="p">.</span><span class="n">Parent</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">*</span><span class="n">a_set</span><span class="p">.</span><span class="n">Parent</span><span class="p">;</span>
<span class="p">}</span><span class="o">*</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
</div></blockquote>
</li>
<li><p class="first">使用了这两种启发式策略之后，算法的最坏运行时间为O(m*alpha(n))，其中m是操作序列中所有的操作的个数总和。
对于宇宙中的所有原子数之和x, alpha(x)&lt;=4，所以说算法的实际时间是线性的。</p>
</li>
</ul>
</li>
</ul>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     disjoint_set_forest.h</span>
<span class="cm"> * @brief    用于不相交集合的数据结构（并查集）</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>

<span class="c1">/// @brief 采用树表示法实现的 用于不相交集合的数据结构（并查集）</span>
<span class="c1">///</span>
<span class="c1">/// 使用了“路径压缩”和“按秩合并”两种技术来加速并查集的运行时间。\n</span>
<span class="c1">/// 这种方法实现的并查集的运行时间在实践上是线性的，但从理论上来说是超线性的。\n</span>
<span class="c1">/// 用于不相交集合的数据结构又称为查并集：在很多的应用中（比如图的算法中经常使用，还有哈夫曼编码等），将N个不同的元素分成一组不相交的集合。\n</span>
<span class="c1">/// 不相交集合上有两个重要的操作：&lt;span style=&quot;color:#FF0000 &quot;&gt;找出给定元素所属的集合&lt;/span&gt; 和 &lt;span style=&quot;color:#FF0000 &quot;&gt;合并两个集合&lt;/span&gt;。</span>
<span class="k">class</span> <span class="nc">DisjointSetForest</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">/// 集合中的一个元素</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="k">struct</span> <span class="n">DisjointSet</span> <span class="p">{</span>
    <span class="n">T</span>           <span class="n">Item</span><span class="p">;</span>     <span class="c1">///&lt; 元素的值</span>
    <span class="kt">int</span>         <span class="n">Rank</span><span class="p">;</span>     <span class="c1">///&lt; 元素的秩</span>
    <span class="n">DisjointSet</span> <span class="o">*</span><span class="n">Parent</span><span class="p">;</span>  <span class="c1">///&lt; 元素的父元素</span>

    <span class="c1">/// 创建一个结点：对应MAKE-SET操作</span>
    <span class="n">DisjointSet</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">item</span> <span class="p">)</span> <span class="o">:</span> <span class="n">Item</span><span class="p">(</span> <span class="n">item</span> <span class="p">),</span> <span class="n">Rank</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">Parent</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">};</span>

<span class="cp">#pragma region 查并集的3个基本操作</span>

  <span class="c1">/// 创建一个集合的操作：MAKE-SET</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="k">static</span> <span class="n">DisjointSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span> <span class="n">MakeSet</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">item</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">DisjointSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">item</span> <span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">/// 查找所属集合的操作：FIND-SET</span>
  <span class="c1">/// @remarks  使用了路径压缩</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="k">static</span> <span class="n">DisjointSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span> <span class="n">FindSet</span><span class="p">(</span> <span class="n">DisjointSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">a_set</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">//路径压缩</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">a_set</span> <span class="o">!=</span> <span class="n">a_set</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="p">)</span> <span class="p">{</span>  <span class="c1">//判断本身不是代表</span>
      <span class="n">a_set</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="o">=</span> <span class="n">FindSet</span><span class="p">(</span> <span class="n">a_set</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">a_set</span><span class="o">-&gt;</span><span class="n">Parent</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// 合并操作：UNION</span>
  <span class="c1">/// @remarks  使用了按秩合并</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">Union</span><span class="p">(</span> <span class="n">DisjointSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">DisjointSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">y</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">_Link</span><span class="p">(</span> <span class="n">FindSet</span><span class="p">(</span> <span class="n">x</span> <span class="p">),</span> <span class="n">FindSet</span><span class="p">(</span> <span class="n">y</span> <span class="p">)</span> <span class="p">);</span>
  <span class="p">}</span>

<span class="cp">#pragma endregion</span>

<span class="k">private</span><span class="o">:</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
  <span class="k">static</span> <span class="kt">void</span> <span class="n">_Link</span><span class="p">(</span> <span class="n">DisjointSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">DisjointSet</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">y</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">Rank</span> <span class="o">&gt;</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">Rank</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">y</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">x</span><span class="o">-&gt;</span><span class="n">Parent</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
      <span class="c1">//按秩合并</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">Rank</span> <span class="o">==</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">Rank</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">//只有在秩相同时才会将最后的根结点的秩+1</span>
        <span class="o">++</span><span class="p">(</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">Rank</span> <span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     disjoint_set_forest.cpp</span>
<span class="cm"> * @brief    用于不相交集合的数据结构（并查集）</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="cp">#include</span> <span class="cpf">&quot;disjoint_set_forest.h&quot;</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="c1">/// 用于不相交集合的数据结构（并查集）</span>
<span class="kt">void</span> <span class="n">testDisjointSetForest</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">DisjointSetForest</span><span class="o">::</span><span class="n">DisjointSet</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*&gt;</span> <span class="n">nodes</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">nodes</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">DisjointSetForest</span><span class="o">::</span><span class="n">MakeSet</span><span class="p">(</span> <span class="n">i</span> <span class="p">)</span> <span class="p">);</span>
  <span class="p">}</span>


  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">index1</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">index2</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">DisjointSetForest</span><span class="o">::</span><span class="n">Union</span><span class="p">(</span> <span class="n">nodes</span><span class="p">[</span><span class="n">index1</span><span class="p">],</span> <span class="n">nodes</span><span class="p">[</span><span class="n">index2</span><span class="p">]</span> <span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Union : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">index1</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;---&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">index2</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;--------------&gt;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">DisjointSetForest</span><span class="o">::</span><span class="n">FindSet</span><span class="p">(</span> <span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span><span class="o">-&gt;</span><span class="n">Item</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">//for (int i = 0; i &lt; nodes.size(); ++i)</span>
  <span class="c1">//{</span>
  <span class="c1">//  FindSet(nodes[i]);</span>
  <span class="c1">//  cout &lt;&lt; FindSet(nodes[i])-&gt;Item &lt;&lt; endl;</span>
  <span class="c1">//}</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">testDisjointSetForest</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="nl">Union</span> <span class="p">:</span> <span class="mi">3</span><span class="o">---</span><span class="mi">6</span>
<span class="nl">Union</span> <span class="p">:</span> <span class="mi">7</span><span class="o">---</span><span class="mi">5</span>
<span class="nl">Union</span> <span class="p">:</span> <span class="mi">3</span><span class="o">---</span><span class="mi">5</span>
<span class="nl">Union</span> <span class="p">:</span> <span class="mi">6</span><span class="o">---</span><span class="mi">2</span>
<span class="nl">Union</span> <span class="p">:</span> <span class="mi">9</span><span class="o">---</span><span class="mi">1</span>
<span class="mi">0</span><span class="o">--------------&gt;</span><span class="mi">0</span>
<span class="mi">1</span><span class="o">--------------&gt;</span><span class="mi">1</span>
<span class="mi">2</span><span class="o">--------------&gt;</span><span class="mi">5</span>
<span class="mi">3</span><span class="o">--------------&gt;</span><span class="mi">5</span>
<span class="mi">4</span><span class="o">--------------&gt;</span><span class="mi">4</span>
<span class="mi">5</span><span class="o">--------------&gt;</span><span class="mi">5</span>
<span class="mi">6</span><span class="o">--------------&gt;</span><span class="mi">5</span>
<span class="mi">7</span><span class="o">--------------&gt;</span><span class="mi">5</span>
<span class="mi">8</span><span class="o">--------------&gt;</span><span class="mi">8</span>
<span class="mi">9</span><span class="o">--------------&gt;</span><span class="mi">1</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id28">
<h2>第六部分：图算法<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>图是计算机科学中常用的一类数据结构。</li>
<li>两种图的遍历方法：广度优先遍历（求每条边都是单位权值的图的最短路径）和深度优先遍历（拓扑排序、将有向图分解为强连通子图）。</li>
<li>最小权生成树：由连接了图中所有顶点的、且权值最小的路径所构成。</li>
<li>有向图中的最大流问题：这是个一般性的问题，会以多种形式出现；一个好的计算最大流量的算法可以用来有效地解决多种相关的问题。</li>
</ul>
<div class="section" id="id29">
<h3>第22章：图的基本算法<a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h3>
<ul>
<li><p class="first">图的搜索技术是图算法领域的核心</p>
</li>
<li><dl class="first docutils">
<dt>两种最普通的图的表示方法：邻接表法（节省空间）和邻接矩阵法（查询高效）</dt>
<dd><p class="first last">稀疏图多用邻接表法来表示；而稠密图则用邻接矩阵法来表示比较好。</p>
</dd>
</dl>
</li>
<li><p class="first">不论是有向图还是无向图，邻接表法都有一个很好的特性，即它所需要的存储空间为O(V+E)；邻接表表示法稍作修改就能支持其它多种图的变体，因而有着很强的适应性。</p>
</li>
<li><p class="first">无向图的邻接矩阵A就是它的转置矩阵：A=A<sup>T</sup> 。在某些应用中，可以只存储邻接矩阵的对角线及对角线以上的部分，这样一来，图所占用的存储空间几乎可以减少一半</p>
</li>
<li><p class="first">邻接表表示和邻接矩阵表示在渐近意义上至少是一样有效的，但由于邻接矩阵简单明了，因而当图较小时，更多多地采用邻接矩阵来表示。另外，如果一个图不是加权的，采用邻接矩阵的存储形式还有一个优越性：在存储邻接矩阵的每个元素时，可以只用一个二进位，而不必有一个字的空间。</p>
<p>这样，当采用了二进位以及表示无向图的技巧时，邻接矩阵法的占用空间大的缺点就可以得到一定程度上的改善！</p>
</li>
<li><dl class="first docutils">
<dt>广度优先搜索能够得到这种意义上的最短路径：每条边的权值都为1，即所有的边都具有单位权值。</dt>
<dd><p class="first last">广度优先所产生的广度优先树是每个顶点到s的最短距离。</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>深度优先搜索除了创建一个深度优先森林外，深度优先搜索同时为每个顶点加盖时间戳。每个顶点v有两个时间戳：当顶点v第一次被发现时，记录下第一个时间戳d[v]，当结束检查v的邻接表时，记录下第二个时间戳f[v]。</dt>
<dd><p class="first last">许多基于深度优先搜索的图算法都用到了时间戳，它们对推算深度优先搜索的时行情况有很大的帮助。</p>
</dd>
</dl>
</li>
<li><p class="first">这次重新复习深度优先算法，得到的最大的启示就是使用了这2个时间戳，真的是很有用很好的创新啊。当记录下这2个时间戳之后，很多东西都可以由这对时间戳来推导出来了（比如拓扑排序、深度遍历的次序等）。</p>
</li>
<li><p class="first">广度搜索通常用于从某个源顶点开始，寻找最短路径距离（以及相关的先辈子图）。深度优先搜索通常作为另一个算法中的一个子程序。</p>
</li>
<li><p class="first">后裔区间的嵌套：在一个（有向或无向）图G中的深度优先森林中，顶点v是顶点u的后裔，当且仅当d[u]&lt;d[v]&lt;f[v]&lt;d[u]，由这关系可以推导出大部分的与时间戳相关的性质。</p>
</li>
<li><p class="first">边的分类：树边、反向边、正向边、交叉边。</p>
</li>
<li><dl class="first docutils">
<dt>拓扑排序：在很多应用中，有向无回路图说明事件发生的先后次序。</dt>
<dd><p class="first last">在深度优先遍历的基础上，对有向无回路图进行拓扑排序简直是小菜一蹀。根据遍历所得到的时间戳f[i]逆向排序就好了。</p>
</dd>
</dl>
</li>
<li><p class="first">拓扑排序的顶点以与其完成时间时间相反的顺序出现。这种新方法真是长见识啊，比我以前使用的方法好多了，这种方法在遍历完只需要一个简单的sort就完成了拓扑排序，时间复杂度也降低为O(V+E)。</p>
</li>
<li><p class="first">这种新的拓扑排序的方法的理论基础是：对于任一对不同的顶点u,v，如果存在一条从u -&gt; v的边，那么u在拓扑排序的结果中一定在v的前面。而又根据后裔区间嵌套的定理：如果存在u -&gt; v，那么f[v]&lt;f[u]，所以得证根据f逆向排序得到的顺序一定为拓扑排序。</p>
</li>
<li><p class="first">强连通分支：有向图G=(V, E)的一个强连通分支就是一个最大的顶点集合C，对于C中的每一对顶点u,v，都有u -&gt; v及v -&gt; u；亦即顶点u和v是互相可达的。</p>
</li>
<li><p class="first">寻找强连通分支的简明算法：</p>
<img alt="../../_images/graphic_base.jpg" src="../../_images/graphic_base.jpg" />
<ul class="simple">
<li>对G进行深度优先遍历得到每个顶点的时间戳f[x]；</li>
<li>求得G的返回图GT；</li>
<li>按照f[x]的逆向顺序为顶点顺序对GT进行深度优先遍历，即按照G的拓扑排序的顺序对GT再进行深度优先遍历；</li>
<li>步骤c得到的各棵子树就是原图G的各强连通分支。</li>
</ul>
</li>
<li><p class="first">寻找强连通分支的算法的时间复杂度为O(V+E)。</p>
</li>
</ul>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     deapth_first_search.h</span>
<span class="cm"> * @brief    深度优先搜索核心递归程序</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>
<span class="cp">#pragma once</span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;bitset&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;graphics.h&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="c1">/// @brief 深度优先遍历的递归函数</span>
<span class="c1">///</span>
<span class="c1">/// 从顶点index开始，按照深度优先的规则依次遍历。只会遍历从index顶点可以访问的结果，对于index不可到达的结点不会访问。</span>
<span class="c1">/// @param  g           要遍历的图，使用邻接表的表示方法</span>
<span class="c1">/// @param  index       从index顶点开始进行遍历</span>
<span class="c1">/// @param  d           时间戳d</span>
<span class="c1">/// @param  f           时间戳f</span>
<span class="c1">/// @param  traversed   标识顶点是否已经被遍历</span>
<span class="c1">/// @param  time        全局时间，用于设置时间戳d和f</span>
<span class="c1">/// @return             返回本次深度优先遍历得到的子树依次所遍历过的结点的编号</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">DFS_Visit</span><span class="p">(</span> <span class="n">GraphicsViaAdjacencyList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">g</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">index</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">traversed</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">time</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">this_time_traversed</span><span class="p">;</span>
  <span class="n">this_time_traversed</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">index</span> <span class="p">);</span>
  <span class="n">traversed</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="o">++</span><span class="n">time</span><span class="p">;</span>
  <span class="n">d</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">traversed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">g</span><span class="p">.</span><span class="n">IsLinked</span><span class="p">(</span> <span class="n">index</span><span class="p">,</span> <span class="n">i</span> <span class="p">).</span><span class="n">first</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">DFS_Visit</span><span class="p">(</span> <span class="n">g</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">traversed</span><span class="p">,</span> <span class="n">time</span> <span class="p">);</span>
      <span class="n">this_time_traversed</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">this_time_traversed</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="o">++</span><span class="n">time</span><span class="p">;</span>
  <span class="n">f</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">this_time_traversed</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     deapth_first_search.cpp</span>
<span class="cm"> * @brief    深度优先搜索</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;bitset&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;graphics.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;deapth_first_search.h&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="c1">/// @brief 深度优先遍历主函数</span>
<span class="c1">///</span>
<span class="c1">/// 深度优先搜索除了创建一个深度优先森林外，深度优先搜索同时为每个顶点加盖时间戳。每个顶点v有两个时间戳：\n</span>
<span class="c1">/// 当顶点v第一次被发现时，记录下第一个时间戳d[v]，当结束检查v的邻接表时，记录下第二个时间戳f[v]。\n</span>
<span class="c1">/// 许多基于深度优先搜索的图算法都用到了时间戳，它们对推算深度优先搜索的时行情况有很大的帮助。\n</span>
<span class="c1">/// 这次重新复习深度优先算法，得到的最大的启示就是使用了这2个时间戳，真的是很有用很好的创新啊。当记录下这2个时间戳之后，很多东西都可以由这对时间戳来推导出来了（比如拓扑排序、深度遍历的次序等）。\n</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">DeapthFirstSearch</span><span class="p">(</span> <span class="n">GraphicsViaAdjacencyList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">g</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>    <span class="n">d</span><span class="p">(</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>        <span class="c1">//时间戳d</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>    <span class="n">f</span><span class="p">(</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>        <span class="c1">//时间戳f</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span>  <span class="n">traversed</span><span class="p">(</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">(),</span> <span class="nb">false</span> <span class="p">);</span>  <span class="c1">//标识顶点是否已经被遍历</span>
  <span class="kt">int</span>        <span class="n">time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;深度优先遍历：&quot;</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">traversed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ids</span> <span class="o">=</span> <span class="n">DFS_Visit</span><span class="p">(</span> <span class="n">g</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">traversed</span><span class="p">,</span> <span class="n">time</span> <span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">ids</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">k</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">()[</span><span class="n">ids</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="p">[</span><span class="n">ids</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;,&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">f</span><span class="p">[</span><span class="n">ids</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;] &quot;</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;深度优先遍历：&quot;</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&gt;</span> <span class="n">r</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">r</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">make_pair</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="n">make_pair</span><span class="p">(</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span> <span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// 根据时间戳d来排序好好序之后就是深度优先遍历的结果</span>
  <span class="c1">// 这是我自己推导出来的，证明思路是：根据深度优先的“括号定理”，时间戳d排在前面的结点总是位于前面的括号内，</span>
  <span class="c1">// 也就是位于深度优先搜索结果的前列所以说这种同时计算时间界的深度优先真有用啊，根据d排序就可以得出深度优先的次序</span>
  <span class="c1">// ，根据f排序又可以得出拓扑排序的顺序</span>
  <span class="n">sort</span><span class="p">(</span> <span class="n">r</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">r</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">p1</span><span class="p">,</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">p2</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">p1</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">p2</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
  <span class="p">}</span> <span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">()[</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;,&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;] &quot;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// 测试深度优先搜索</span>
<span class="kt">void</span> <span class="n">testDeapthFirstSearch</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="sc">&#39;r&#39;</span> <span class="o">+</span> <span class="n">i</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="n">GraphicsViaAdjacencyList</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">(</span> <span class="n">v</span><span class="p">,</span> <span class="n">Undigraph</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span> <span class="p">);</span>

  <span class="n">DeapthFirstSearch</span><span class="p">(</span> <span class="n">g</span> <span class="p">);</span>
<span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">testDeapthFirstSearch</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>
深度优先遍历：r[1,16] s[2,13] w[3,12] t[4,11] u[5,10] x[6,9] y[7,8] v[14,15] 
深度优先遍历：r[1,16] s[2,13] w[3,12] t[4,11] u[5,10] x[6,9] y[7,8] v[14,15] 
</pre></div>
</div>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     breadth_first_search.cpp</span>
<span class="cm"> * @brief    广度优先搜索</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;bitset&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;graphics.h&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="c1">/// @brief 广度优先遍历</span>
<span class="c1">///</span>
<span class="c1">/// @param  g        使用邻接表表示的图</span>
<span class="c1">/// @param  start_index    从这个顶点开始进行广度优先遍历</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">BreadthFirstSearch</span><span class="p">(</span> <span class="n">GraphicsViaAdjacencyList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">g</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">start_index</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">queue</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span>  <span class="n">q</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span>  <span class="n">trivaled</span><span class="p">(</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">(),</span> <span class="nb">false</span> <span class="p">);</span>
  <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span> <span class="n">start_index</span> <span class="p">);</span>
  <span class="n">trivaled</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;广度优先遍历：&quot;</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span> <span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">//如果没有遍历完所有的结点</span>
    <span class="kt">char</span> <span class="n">current</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
    <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">()[</span><span class="n">current</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  &quot;</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">trivaled</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">g</span><span class="p">.</span><span class="n">IsLinked</span><span class="p">(</span> <span class="n">current</span><span class="p">,</span> <span class="n">i</span> <span class="p">).</span><span class="n">first</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">//没有被遍历过 且 与当前遍历的元素邻接</span>
        <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span> <span class="n">i</span> <span class="p">);</span>
        <span class="n">trivaled</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// 广度优先遍历</span>
<span class="kt">void</span> <span class="n">testBreadthFirstSearch</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="sc">&#39;r&#39;</span> <span class="o">+</span> <span class="n">i</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="n">GraphicsViaAdjacencyList</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">(</span> <span class="n">v</span><span class="p">,</span> <span class="n">Undigraph</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span> <span class="p">);</span>

  <span class="n">BreadthFirstSearch</span><span class="p">(</span> <span class="n">g</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">testBreadthFirstSearch</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>广度优先遍历：s  r  w  v  t  x  u  y  
</pre></div>
</div>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     topological_sort.cpp</span>
<span class="cm"> * @brief    拓扑排序</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;bitset&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;graphics.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;deapth_first_search.h&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="c1">/// @breif 拓扑排序</span>
<span class="c1">///</span>
<span class="c1">/// 拓扑排序：在深度优先遍历的基础上，对有向无回路图进行拓扑排序简直是小菜一蹀。根据遍历所得到的时间戳f[i]逆向排序就好了。\n</span>
<span class="c1">/// 拓扑排序的顶点以与其完成时间时间相反的顺序出现。这种新方法真是长见识啊，比我以前使用的方法好多了，这种方法在遍历完只需要一个简单的sort就完成了拓扑排序，时间复杂度也降低为O(V+E)。\n</span>
<span class="c1">/// 这种新的拓扑排序的方法的理论基础是：对于任一对不同的顶点u,v，如果存在一条从u -&gt; v的边，那么u在拓扑排序的结果中一定在v的前面。\n</span>
<span class="c1">/// 而又根据后裔区间嵌套的定理：如果存在u -&gt; v，那么f[v]&lt;f[u]，所以得证根据f逆向排序得到的顺序一定为拓扑排序。</span>
<span class="kt">void</span> <span class="n">TopologicalSort</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="s">&quot;undershorts&quot;</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="s">&quot;socks&quot;</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="s">&quot;watch&quot;</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="s">&quot;pants&quot;</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="s">&quot;shoes&quot;</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="s">&quot;shirt&quot;</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="s">&quot;belt&quot;</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="s">&quot;tie&quot;</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="s">&quot;jacket&quot;</span> <span class="p">);</span>
  <span class="n">GraphicsViaAdjacencyList</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">(</span> <span class="n">v</span><span class="p">,</span> <span class="n">Digraph</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span> <span class="p">);</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>    <span class="n">d</span><span class="p">(</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>        <span class="c1">//时间戳d</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>    <span class="n">f</span><span class="p">(</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>        <span class="c1">//时间戳f</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span>  <span class="n">traversed</span><span class="p">(</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">(),</span> <span class="nb">false</span> <span class="p">);</span>  <span class="c1">//标识顶点是否已经被遍历</span>
  <span class="kt">int</span>        <span class="n">time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">traversed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">DFS_Visit</span><span class="p">(</span> <span class="n">g</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">traversed</span><span class="p">,</span> <span class="n">time</span> <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;拓扑排序：&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&gt;</span> <span class="n">r</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">r</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">make_pair</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="n">make_pair</span><span class="p">(</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">//根据时间戳f来逆向排好序的结果就是拓扑排序的结果</span>
  <span class="n">sort</span><span class="p">(</span> <span class="n">r</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span> <span class="n">r</span><span class="p">.</span><span class="n">rend</span><span class="p">(),</span> <span class="p">[](</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">p1</span><span class="p">,</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">p2</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">p1</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="n">p2</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
  <span class="p">}</span> <span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">()[</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;,&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;]&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

<span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">TopologicalSort</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>拓扑排序：
shirt[15,18]
tie[16,17]
watch[13,14]
socks[11,12]
undershorts[1,10]
pants[2,9]
belt[5,8]
jacket[6,7]
shoes[3,4]
</pre></div>
</div>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     strongly_connected_component.cpp</span>
<span class="cm"> * @brief    强连通分支</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;bitset&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;graphics.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;deapth_first_search.h&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="c1">/// @brief 寻找强连通分支问题</span>
<span class="c1">///</span>
<span class="c1">/// 强连通分支：有向图G=(V, E)的一个强连通分支就是一个最大的顶点集合C，对于C中的每一对顶点u,v，都有u -&gt; v及v -&gt; u；亦即顶点u和v是互相可达的。\n</span>
<span class="c1">/// 寻找强连通分支的简明算法，寻找强连通分支的算法的时间复杂度为O(V+E)：</span>
<span class="c1">/// - 对G进行深度优先遍历得到每个顶点的时间戳f[x]；</span>
<span class="c1">/// - 求得G的逆向图G^T；</span>
<span class="c1">/// - 按照f[x]的逆向顺序为顶点顺序对G^T进行深度优先遍历，即按照G的拓扑排序的顺序对G^T再进行深度优先遍历；</span>
<span class="c1">/// - 步骤c得到的各棵子树就是原图G的各强连通分支。</span>
<span class="kt">void</span> <span class="n">StronglyConnectedComponent</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;强连接分支&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="sc">&#39;a&#39;</span> <span class="o">+</span> <span class="n">i</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="n">GraphicsViaAdjacencyList</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">(</span> <span class="n">v</span><span class="p">,</span> <span class="n">Digraph</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">7</span> <span class="p">);</span>

  <span class="c1">//step1:对g进行深度优先遍历</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>    <span class="n">d</span><span class="p">(</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>        <span class="c1">//时间戳d</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>    <span class="n">f</span><span class="p">(</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>        <span class="c1">//时间戳f</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span>  <span class="n">traversed</span><span class="p">(</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">(),</span> <span class="nb">false</span> <span class="p">);</span>  <span class="c1">//标识顶点是否已经被遍历</span>
  <span class="kt">int</span>        <span class="n">time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">traversed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">DFS_Visit</span><span class="p">(</span> <span class="n">g</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">traversed</span><span class="p">,</span> <span class="n">time</span> <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">//step2:得到gT并得到按时间戳f逆向排序</span>
  <span class="n">GraphicsViaAdjacencyList</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">gT</span><span class="p">(</span> <span class="n">g</span> <span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">gT</span><span class="p">.</span><span class="n">GetEdges</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">gT</span><span class="p">.</span><span class="n">GetEdges</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">g</span><span class="p">.</span><span class="n">IsLinked</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="p">).</span><span class="n">first</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">gT</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span> <span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&gt;</span> <span class="n">r</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">r</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">make_pair</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="n">make_pair</span><span class="p">(</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">//根据时间戳f来逆向排好序的结果</span>
  <span class="n">sort</span><span class="p">(</span> <span class="n">r</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span> <span class="n">r</span><span class="p">.</span><span class="n">rend</span><span class="p">(),</span> <span class="p">[](</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">p1</span><span class="p">,</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">p2</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">p1</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="n">p2</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
  <span class="p">}</span> <span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">()[</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;[&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;,&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;] &quot;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

  <span class="c1">//step3：对gT以以时间戳的逆序来重新进行深度优先遍历，所得到的各子树就是g的强连通分支</span>
  <span class="n">traversed</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span> <span class="n">gT</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">(),</span> <span class="nb">false</span> <span class="p">);</span>
  <span class="n">time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">traversed</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">]</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ids</span> <span class="o">=</span> <span class="n">DFS_Visit</span><span class="p">(</span> <span class="n">gT</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">traversed</span><span class="p">,</span> <span class="n">time</span> <span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">ids</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">k</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">gT</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">()[</span><span class="n">ids</span><span class="p">[</span><span class="n">k</span><span class="p">]];</span>
      <span class="p">}</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="p">}</span>

<span class="p">}</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">StronglyConnectedComponent</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>强连接分支
a[1,16] b[2,15] e[13,14] c[3,12] g[8,11] f[9,10] d[4,7] h[5,6] 
aeb
cd
gf
h
</pre></div>
</div>
</div>
<div class="section" id="id30">
<h3>第23章：最小生成树<a class="headerlink" href="#id30" title="永久链接至标题">¶</a></h3>
<ul>
<li><p class="first">最小（权值）生成树：由n-1条边，连接了所有的n个顶点，并且所有边上的权值和最小。</p>
</li>
<li><p class="first">Kruskal算法和Prim算法：这两种算法中都使用普通的二叉堆就可以很容易地达到O(ElgV)的运行时间。通过采用斐波那契堆，Prim算法的运行时间可以减少到O(E +VlgV)，这对于稠密图来说是个很大的改进。</p>
</li>
<li><p class="first">贪心策略可以在最小生成树问题中得到最优解，事实上这里的Kruskal、Prim方法都是贪心算法。它们也都是可以被证明的一定能够得到最优解！</p>
</li>
<li><p class="first">在Kruskal算法中，集合A是一个森林，加入集合A中的安全边总是图中连接两个不同连通分支的最小权边；</p>
<img alt="../../_images/min_generate_tree1.png" src="../../_images/min_generate_tree1.png" />
<p>在Prim算法中，集合A仅形成单棵树，添入集合A中的安全边总是连接树与一个不在树中的顶点的最小权边。</p>
<img alt="../../_images/min_generate_tree2.png" src="../../_images/min_generate_tree2.png" />
</li>
<li><p class="first">为什么说Prim算法有着更好的实际效率：</p>
<ul class="simple">
<li>Prim算法在执行的过程中，将不在树中的所有顶点都放在一个基于key域的最小优先队列Q中；</li>
<li>每次在选取安全边时，只需要从Q中弹出最小key值的顶点即可，而不需要像Kruskal一样为对所有的边的权值进行一次排序；</li>
<li>Prim算法使用了用于快速或者最小权值边的技巧（二叉堆、二项堆、斐波那契堆）来加速算法的运行。在最朴素的选取安全边的算法中，需要遍历剩下的所有的边，所需要的时间复杂度为O(EV)，而采用堆来优化后只需要O(ElgV)，大大地改善了算法的执行时间（堆的好处）。</li>
<li>不过Kruskal算法实现简单，所以对于一般的应用Kruskal算法很常见。</li>
</ul>
</li>
<li><p class="first">Prim算法的性能取决于优先队列Q是如何实现的，因此如果使用斐波那契堆来实现最小优先队列，就可以将Prim算法的运行时间改进为O(E+VlgV)。</p>
</li>
</ul>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     kruskal.cpp</span>
<span class="cm"> * @brief    Kruskal最小生成树算法</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;bitset&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;graphics.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;disjoint_set_forest.h&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="c1">/// @brief Kruskal最小生成树算法</span>
<span class="c1">///</span>
<span class="c1">/// &lt;b&gt;最小（权值）生成树：由n-1条边，连接了所有的n个顶点，并且所有边上的权值和最小。&lt;/b&gt;\n\n</span>
<span class="c1">/// Kruskal算法中，集合A是一个森林，加入集合A中的安全边总是图中连接两个不同连通分支的最小权边；</span>
<span class="kt">void</span> <span class="n">Kruskal</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="sc">&#39;a&#39;</span> <span class="o">+</span> <span class="n">i</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="n">GrpahicsViaAdjacencyMatrix</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">(</span> <span class="n">v</span><span class="p">,</span> <span class="n">Undigraph</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">14</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">6</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span> <span class="p">);</span>
  <span class="kt">int</span> <span class="k">const</span> <span class="n">n</span> <span class="o">=</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">();</span>

  <span class="c1">//建立这些查并集</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">DisjointSetForest</span><span class="o">::</span><span class="n">DisjointSet</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="o">*&gt;</span> <span class="n">dsf</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">dsf</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">DisjointSetForest</span><span class="o">::</span><span class="n">MakeSet</span><span class="p">(</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span> <span class="p">)</span> <span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">//取得边的集合</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">edges</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">g</span><span class="p">.</span><span class="n">IsLinked</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">edges</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">make_pair</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="p">)</span> <span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">//将边的集合按权值进行排序</span>
  <span class="n">sort</span><span class="p">(</span> <span class="n">edges</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">edges</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">g</span><span class="p">](</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">p1</span><span class="p">,</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">p2</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">g</span><span class="p">.</span><span class="n">GetEdge</span><span class="p">()[</span><span class="n">p1</span><span class="p">.</span><span class="n">first</span><span class="p">][</span><span class="n">p1</span><span class="p">.</span><span class="n">second</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetEdge</span><span class="p">()[</span><span class="n">p2</span><span class="p">.</span><span class="n">first</span><span class="p">][</span><span class="n">p2</span><span class="p">.</span><span class="n">second</span><span class="p">];</span>
  <span class="p">}</span> <span class="p">);</span>

  <span class="c1">//依次检查这些边</span>
  <span class="n">for_each</span><span class="p">(</span> <span class="n">edges</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">edges</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">edge</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">DisjointSetForest</span><span class="o">::</span><span class="n">FindSet</span><span class="p">(</span> <span class="n">dsf</span><span class="p">[</span><span class="n">edge</span><span class="p">.</span><span class="n">first</span><span class="p">]</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">DisjointSetForest</span><span class="o">::</span><span class="n">FindSet</span><span class="p">(</span> <span class="n">dsf</span><span class="p">[</span><span class="n">edge</span><span class="p">.</span><span class="n">second</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">DisjointSetForest</span><span class="o">::</span><span class="n">Union</span><span class="p">(</span> <span class="n">dsf</span><span class="p">[</span><span class="n">edge</span><span class="p">.</span><span class="n">first</span><span class="p">],</span> <span class="n">dsf</span><span class="p">[</span><span class="n">edge</span><span class="p">.</span><span class="n">second</span><span class="p">]</span> <span class="p">);</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">edge</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  --&gt;  &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">edge</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="p">);</span>

  <span class="n">for_each</span><span class="p">(</span> <span class="n">dsf</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">dsf</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span> <span class="n">DisjointSetForest</span><span class="o">::</span><span class="n">DisjointSet</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">adsf</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="n">adsf</span><span class="p">;</span>
  <span class="p">}</span> <span class="p">);</span>
<span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">Kruskal</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="mi">7</span>  <span class="o">--&gt;</span>  <span class="mi">6</span>
<span class="mi">8</span>  <span class="o">--&gt;</span>  <span class="mi">2</span>
<span class="mi">6</span>  <span class="o">--&gt;</span>  <span class="mi">5</span>
<span class="mi">0</span>  <span class="o">--&gt;</span>  <span class="mi">1</span>
<span class="mi">5</span>  <span class="o">--&gt;</span>  <span class="mi">2</span>
<span class="mi">2</span>  <span class="o">--&gt;</span>  <span class="mi">3</span>
<span class="mi">2</span>  <span class="o">--&gt;</span>  <span class="mi">1</span>
<span class="mi">4</span>  <span class="o">--&gt;</span>  <span class="mi">3</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     prim.cpp</span>
<span class="cm"> * @brief    Prim最小生成树算法</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;bitset&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;graphics.h&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="c1">/// @brief Prim最小生成树算法</span>
<span class="c1">///</span>
<span class="c1">/// &lt;b&gt;最小（权值）生成树：由n-1条边，连接了所有的n个顶点，并且所有边上的权值和最小。&lt;/b&gt;\n\n</span>
<span class="c1">/// Prim算法中，集合A仅形成单棵树，添入集合A中的安全边总是连接树与一个不在树中的顶点的最小权边。\n</span>
<span class="c1">/// Prim算法的性能取决于优先队列Q是如何实现的，因此如果使用斐波那契堆来实现最小优先队列，就可以将Prim算法的运行时间改进为O(E+VlgV)。</span>
<span class="kt">void</span> <span class="n">Prim</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Prim最小生成树&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="sc">&#39;a&#39;</span> <span class="o">+</span> <span class="n">i</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="n">GrpahicsViaAdjacencyMatrix</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">(</span> <span class="n">v</span><span class="p">,</span> <span class="n">Undigraph</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">14</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">6</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">7</span> <span class="p">);</span>
  <span class="kt">int</span> <span class="n">start_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">//parent[i] = j代表在选取最小生成树时第i个结点的上一个结点是j</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">(</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="o">-</span><span class="mi">1</span> <span class="p">);</span>
  <span class="c1">//不在最小生成树中的顶点的集合</span>
  <span class="c1">//pair&lt;顶点的编号，该顶点与任意已经在最小生成树中的顶点的最短距离&gt;</span>
  <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">key</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">key</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">make_pair</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span> <span class="p">)</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="n">key</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span> <span class="o">!</span><span class="n">key</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">//得到与最小生成树中任意顶点距离最小的元素</span>
    <span class="k">auto</span> <span class="n">min_ele</span> <span class="o">=</span> <span class="n">min_element</span><span class="p">(</span> <span class="n">key</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">key</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span> <span class="k">const</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">p1</span><span class="p">,</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span> <span class="k">const</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">p2</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">p1</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;</span> <span class="n">p2</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
    <span class="p">}</span> <span class="p">);</span>
    <span class="kt">int</span> <span class="n">min_index</span> <span class="o">=</span> <span class="n">min_ele</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span> <span class="n">parent</span><span class="p">[</span><span class="n">min_index</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">?</span> <span class="o">*</span><span class="s">&quot;&amp;&quot;</span> <span class="o">:</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">()[</span><span class="n">parent</span><span class="p">[</span><span class="n">min_index</span><span class="p">]]</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; -- &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">()[</span><span class="n">min_index</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">key</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span> <span class="n">min_ele</span> <span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">key</span><span class="p">.</span><span class="n">find</span><span class="p">(</span> <span class="n">i</span> <span class="p">)</span> <span class="o">!=</span> <span class="n">key</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">g</span><span class="p">.</span><span class="n">IsLinked</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="n">min_index</span> <span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetEdge</span><span class="p">()[</span><span class="n">i</span><span class="p">][</span><span class="n">min_index</span><span class="p">]</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">.</span><span class="n">GetEdge</span><span class="p">()[</span><span class="n">i</span><span class="p">][</span><span class="n">min_index</span><span class="p">];</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_index</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">Prim</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Prim最小生成树</span>
<span class="o">&amp;</span> <span class="o">--</span> <span class="n">a</span>
<span class="n">a</span> <span class="o">--</span> <span class="n">b</span>
<span class="n">b</span> <span class="o">--</span> <span class="n">c</span>
<span class="n">c</span> <span class="o">--</span> <span class="n">i</span>
<span class="n">c</span> <span class="o">--</span> <span class="n">f</span>
<span class="n">f</span> <span class="o">--</span> <span class="n">g</span>
<span class="n">g</span> <span class="o">--</span> <span class="n">h</span>
<span class="n">c</span> <span class="o">--</span> <span class="n">d</span>
<span class="n">d</span> <span class="o">--</span> <span class="n">e</span>
</pre></div>
</div>
</div>
<div class="section" id="id31">
<h3>第24章：单源最短路径<a class="headerlink" href="#id31" title="永久链接至标题">¶</a></h3>
<ul>
<li><p class="first">最短路径：一个顶点到另一个顶点的最短权值路径。广度优先搜索算法就是一种在无权（单位权值）图上执行的最短路径算法。</p>
</li>
<li><p class="first">从渐近意义上来说，解决一对顶点的最短路径问题的复杂度与单源最短路径的复杂度相同。</p>
</li>
<li><dl class="first docutils">
<dt>最短路径算法通常依赖于一种性质，也就是一条两顶点间的最短路径包含路径上其它的最短路径。这里动态规划和贪心算法的特征之一：最优子结构。</dt>
<dd><p class="first last">Dijkstra算法是一个贪心算法。DIJKSTRA算法假定输入图中的所有边的权值都是非负的，而floyd算法允许输入边存在负权边，只要不存在从源点可达的负权回路。而且如果存在着负权回路，它还能检测出来。</p>
</dd>
</dl>
</li>
<li><p class="first">Bellman-Ford算法非常简单：对所有的边进行|v|-1遍循环，在每次循环中对每一条边进行松弛的操作。</p>
<img alt="../../_images/single_min_road1.jpg" src="../../_images/single_min_road1.jpg" />
</li>
<li><p class="first">按顶点的拓扑顺序对某加权有向无回路图的边进行松弛后，就可以在O(V+E)时间内计算出单源最短路径。在一个有向无回路图中最短路径总是存在的，因为即使图中有权值为负的边，也不可能存在负权回路（因为它根本没有任何回路）。</p>
</li>
<li><p class="first">Dijkstra算法是一种贪心策略的算法，它的运行时间一般比Bellman-Ford算法要好:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>DIJKSTRA(G, w, s)
1  INITIALIZE-SINGLE-SOURCE(G, s)
2  S ← Ø
3  Q ← V[G]
4  while Q ≠ Ø
5      do u ← EXTRACT-MIN(Q)
6         S ← S ∪{u}
7         for each vertex v ∈ Adj[u]
8             do RELAX(u, v, w)
</pre></div>
</div>
<img alt="../../_images/single_min_road2.jpg" src="../../_images/single_min_road2.jpg" />
<p>Dijkstra算法在每次循环中，每次仅仅提取d值最小的顶点u是保证这个贪心策略正确性的关键核心所在。因为通过集合S中所有的元素都已经去试着松弛过u了，而非S中的点由于本身它的d值都比u要大，所以即使用它们中的任何一个去松弛u，也不可能达到比现在更小的d值了。因此，在每次循环中选取当前d值最小的顶点加入到S集合中去一定能保证最后得到全局最优解。</p>
</li>
<li><p class="first">很多问题都可以转换成图的问题，使用最短路径的算法来加以解决的。 <strong>要善于把一些看似不相干的问题转化为图的问题</strong></p>
</li>
</ul>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     bellman_ford.h</span>
<span class="cm"> * @brief    Bellman-Ford最短路径算法</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>
<span class="cp">#pragma once</span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;bitset&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;graphics.h&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="p">{</span>
<span class="c1">/// 初始化</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">InitializeSingleSource</span><span class="p">(</span> <span class="n">GraphicsViaAdjacencyList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">g</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">parent_index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start_index</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
    <span class="n">parent_index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">d</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// @brief 松弛</span>
<span class="c1">///</span>
<span class="c1">/// 前提条件是：index1-&gt;index2存在着一条边</span>
<span class="c1">/// 因此用index1的这条边来松弛index2的d值，并且设置parent[index2] = index1</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Relax</span><span class="p">(</span> <span class="n">GraphicsViaAdjacencyList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">g</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">parent_index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index2</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">d</span><span class="p">[</span><span class="n">index2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">[</span><span class="n">index1</span><span class="p">]</span> <span class="o">+</span> <span class="n">g</span><span class="p">.</span><span class="n">IsLinked</span><span class="p">(</span> <span class="n">index1</span><span class="p">,</span> <span class="n">index2</span> <span class="p">).</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">Weight</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">d</span><span class="p">[</span><span class="n">index2</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">index1</span><span class="p">]</span> <span class="o">+</span> <span class="n">g</span><span class="p">.</span><span class="n">IsLinked</span><span class="p">(</span> <span class="n">index1</span><span class="p">,</span> <span class="n">index2</span> <span class="p">).</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">Weight</span><span class="p">;</span>
    <span class="n">parent_index</span><span class="p">[</span><span class="n">index2</span><span class="p">]</span> <span class="o">=</span> <span class="n">index1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// @brief Bellman-Ford最短路径算法</span>
<span class="c1">///</span>
<span class="c1">/// &lt;b&gt;最短路径：一个顶点到另一个顶点的最短权值路径。广度优先搜索算法就是一种在无权（单位权值）图上执行的最短路径算法。&lt;/b&gt;\n</span>
<span class="c1">/// Bellman-Ford算法非常简单：对所有的边进行|v|-1遍循环，在每次循环中对每一条边进行松弛的操作。\n</span>
<span class="c1">/// @remarks    floyd算法允许输入边存在负权边，只要不存在从源点可达的负权回路。而且如果存在着负权回路，它还能检测出来。</span>
<span class="c1">/// @param  g        用邻接表法表示的图</span>
<span class="c1">/// @param  start_index    计算顶点start_index到其它所有点的最短路径</span>
<span class="c1">/// @param  d        算法结束后，d[i]存储从start_index到顶点i的最短路径</span>
<span class="c1">/// @parem  parent_index  记录算法在运行的进行中的选。算法结束后，parent_index[i]表示从start_index到顶点i的最短路径的倒数第二个结点的编号</span>
<span class="c1">/// @return      算法是否执行成功，取决于图中是否存在“负权回路”。</span>
<span class="c1">/// @retval  true  算法执行成功，图中不存在“负权回路</span>
<span class="c1">/// @retval  false  算法执行失败，图中存在“负权回路</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">BellmanFord</span><span class="p">(</span> <span class="n">GraphicsViaAdjacencyList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">g</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start_index</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">parent_index</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">g</span><span class="p">.</span><span class="n">GetAllEdges</span><span class="p">();</span>

  <span class="n">InitializeSingleSource</span><span class="p">(</span> <span class="n">g</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">parent_index</span><span class="p">,</span> <span class="n">start_index</span> <span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">for_each</span><span class="p">(</span> <span class="n">edges</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">edges</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">p</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">Relax</span><span class="p">(</span> <span class="n">g</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">parent_index</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span> <span class="p">);</span>
    <span class="p">}</span> <span class="p">);</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">edges</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">d</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">]</span> <span class="o">+</span> <span class="n">g</span><span class="p">.</span><span class="n">IsLinked</span><span class="p">(</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span> <span class="p">).</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">Weight</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     bellman_ford.cpp</span>
<span class="cm"> * @brief    Bellman-Ford最短路径算法</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;bitset&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;graphics.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;bellman_ford.h&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="c1">/// BellmanFord单源最短路径算法</span>
<span class="kt">bool</span> <span class="n">testBellmanFord</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Bellman-Ford最短路径&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="c1">//生成P362页的图24-4</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="sc">&#39;s&#39;</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="sc">&#39;t&#39;</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="sc">&#39;x&#39;</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="sc">&#39;z&#39;</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="sc">&#39;y&#39;</span> <span class="p">);</span>
  <span class="n">GraphicsViaAdjacencyList</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">(</span> <span class="n">v</span><span class="p">,</span> <span class="n">Digraph</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span> <span class="p">);</span>

  <span class="kt">int</span> <span class="n">start_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">d</span><span class="p">(</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">parent_index</span><span class="p">(</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">BellmanFord</span><span class="p">(</span> <span class="n">g</span><span class="p">,</span> <span class="n">start_index</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">parent_index</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;存在负值回路&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; | &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">testBellmanFord</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Bellman</span><span class="o">-</span><span class="n">Ford最短路径</span>
<span class="n">s</span> <span class="o">|</span> <span class="mi">0</span>
<span class="n">t</span> <span class="o">|</span> <span class="mi">2</span>
<span class="n">x</span> <span class="o">|</span> <span class="mi">4</span>
<span class="n">z</span> <span class="o">|</span> <span class="o">-</span><span class="mi">2</span>
<span class="n">y</span> <span class="o">|</span> <span class="mi">7</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     dijkstra.h</span>
<span class="cm"> * @brief    Dijstra最短路径</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>
<span class="cp">#pragma once</span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;bitset&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;graphics.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;bellman_ford.h&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="c1">/// @brief Dijstra最短路径</span>
<span class="c1">///</span>
<span class="c1">/// &lt;b&gt;最短路径：一个顶点到另一个顶点的最短权值路径。广度优先搜索算法就是一种在无权（单位权值）图上执行的最短路径算法。&lt;/b&gt;\n</span>
<span class="c1">/// Dijkstra算法是一种贪心策略的算法，它的运行时间一般比Bellman-Ford算法要好。\n</span>
<span class="c1">///  &lt;span style=&quot;color:#FF0000 &quot;&gt;Dijkstra算法在每次循环中，每次仅仅提取d值最小的顶点u是保证这个贪心策略正确性的关键核心所在。&lt;/span&gt;\n</span>
<span class="c1">///  因为通过集合S中所有的元素都已经去试着松弛过u了，而非S中的点由于本身它的d值都比u要大，所以即使用它们中的任何一个去松弛u，也不可能达到比现在更小的d值了。\n</span>
<span class="c1">///  因此，在每次循环中选取当前d值最小的顶点加入到S集合中去一定能保证最后得到全局最优解。\n\n</span>
<span class="c1">///  DIJKSTRA(G, w, s)\n</span>
<span class="c1">///   1  INITIALIZE-SINGLE-SOURCE(G, s)\n</span>
<span class="c1">///   2  S ← 空集\n</span>
<span class="c1">///   3  Q ← V[G]\n</span>
<span class="c1">///    4  while Q != 空集\n</span>
<span class="c1">///   5      do u ← EXTRACT-MIN(Q)\n</span>
<span class="c1">///   6         S ← S 并上 {u}\n</span>
<span class="c1">///    7         for each vertex v 属于 Adj[u]\n</span>
<span class="c1">///    8             do RELAX(u, v, w)\n</span>
<span class="c1">/// @remarks  Dijkstra算法假定输入图中的所有边的权值都是非负的</span>
<span class="c1">/// @param  g        用邻接表法表示的图</span>
<span class="c1">/// @param  start_index    计算顶点start_index到其它所有点的最短路径</span>
<span class="c1">/// @param  d        算法结束后，d[i]存储从start_index到顶点i的最短路径</span>
<span class="c1">/// @parem  parent_index  记录算法在运行的进行中的选。算法结束后，parent_index[i]表示从start_index到顶点i的最短路径的倒数第二个结点的编号</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Dijkstra</span><span class="p">(</span> <span class="n">GraphicsViaAdjacencyList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">g</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start_index</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">parent_index</span> <span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">g</span><span class="p">.</span><span class="n">GetAllEdges</span><span class="p">();</span>

  <span class="n">InitializeSingleSource</span><span class="p">(</span> <span class="n">g</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">parent_index</span><span class="p">,</span> <span class="n">start_index</span> <span class="p">);</span>

  <span class="k">auto</span> <span class="n">greater_pred</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="kt">int</span> <span class="n">index1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index2</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="n">index1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">[</span><span class="n">index2</span><span class="p">];</span>
  <span class="p">};</span>

  <span class="c1">//使用普通二叉堆来做这个优先队列。还可以考虑使用二项堆和斐波那契堆来进行加速</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Q</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">Q</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">i</span> <span class="p">);</span>
  <span class="p">}</span>
  <span class="n">make_heap</span><span class="p">(</span> <span class="n">Q</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">Q</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">greater_pred</span> <span class="p">);</span>


  <span class="k">while</span> <span class="p">(</span> <span class="o">!</span><span class="n">Q</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">for_each</span><span class="p">(</span> <span class="n">edges</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">edges</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">p</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span> <span class="o">==</span> <span class="n">Q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">//对所有从min_ele发出的边进行松弛操作</span>
        <span class="n">Relax</span><span class="p">(</span> <span class="n">g</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">parent_index</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span> <span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="p">);</span>

    <span class="c1">//这里d被Relax进行了改变，相当于改变了优先队列中若干项的优先值，因此要重建堆</span>
    <span class="n">swap</span><span class="p">(</span> <span class="n">Q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Q</span><span class="p">[</span><span class="n">Q</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="p">);</span>
    <span class="n">Q</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
    <span class="n">make_heap</span><span class="p">(</span> <span class="n">Q</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">Q</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">greater_pred</span> <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     dijkstra.cpp</span>
<span class="cm"> * @brief    Dijstra最短路径</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;bitset&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;graphics.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;dijkstra.h&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="c1">/// Dijkstra单源最短路径算法</span>
<span class="kt">void</span> <span class="n">testDijkstra</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Dijkstra最短路径&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="c1">//生成P367页的图24-6</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="sc">&#39;s&#39;</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="sc">&#39;t&#39;</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="sc">&#39;x&#39;</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="sc">&#39;z&#39;</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="sc">&#39;y&#39;</span> <span class="p">);</span>
  <span class="n">GraphicsViaAdjacencyList</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">(</span> <span class="n">v</span><span class="p">,</span> <span class="n">Digraph</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>

  <span class="kt">int</span> <span class="n">start_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">d</span><span class="p">(</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">parent_index</span><span class="p">(</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
  <span class="n">Dijkstra</span><span class="p">(</span> <span class="n">g</span><span class="p">,</span> <span class="n">start_index</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">parent_index</span> <span class="p">);</span>


  <span class="k">for</span> <span class="p">(</span> <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">()[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; | &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">testDijkstra</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Dijkstra最短路径</span>
<span class="n">s</span> <span class="o">|</span> <span class="mi">0</span>
<span class="n">t</span> <span class="o">|</span> <span class="mi">8</span>
<span class="n">x</span> <span class="o">|</span> <span class="mi">9</span>
<span class="n">z</span> <span class="o">|</span> <span class="mi">7</span>
<span class="n">y</span> <span class="o">|</span> <span class="mi">5</span>
</pre></div>
</div>
</div>
<div class="section" id="id32">
<h3>第25章：每对顶点间的最短路径<a class="headerlink" href="#id32" title="永久链接至标题">¶</a></h3>
<ul>
<li><p class="first">Folyd-Warshall是一个动态规划算法，运行时间为O(V^3)；Johnson算法使用了几种算法作为其子算法，运行时间为O(V^2 lgV+VE)，尤其适合对大型稀疏图。</p>
</li>
<li><p class="first">求每对顶点之间的最短路径问题很适合于动态规划算法来求解，因为它满足”最优子问题的结构”和”重叠子问题”两个特征。</p>
</li>
<li><p class="first">一个朴素的思路就是使用Lij(m)来表示从顶点i到顶点j的，中间包含至多m条路径的最短路径。这种思路是朴素的动态规划思想，效率比较好，时间复杂度为O(V3lgV)，但是后面提及的两种算法都对这个”最优子问题的结构”进行了更多的优化。</p>
</li>
<li><p class="first">Folyd-Warshall算法的运行时间为O(V3)，它允许权值为负的边，但是假定了不存在权值为负的回路。而且它的代码是紧凑的，而且不包含复杂的数据结构，隐含的常数因子很小。因此，即便对于中等规模的输入图来说Folyd-Warshall算法仍然相当的实用。</p>
</li>
<li><p class="first">Folyd-Warshall的核心在于：它改进了”最优子问题结构”，使用dij(k)来表示从顶点i到顶点j、且满足所有中间顶点皆属于集合{1,2,…,k}的一条最短路径的权值。这种限定了起始点的技巧大大的减少了实现的计算量。</p>
</li>
<li><p class="first">有向图的传递闭包：G的传递闭包定义为图G*=(V, E*)，其中E*={(i,j) : 图G中存在着一条从i到j的路径}。</p>
<p>对于一个大图，即使是只需要确定是否存在路径可达都不是一件很容易的事件。解决此问题的整体思路与Folyd-Warshall算法一样，只是把Folyd-Warshall算法中的min和+操作替换为相应的OR和AND逻辑运算来加快速度，本质并没有区别。</p>
</li>
<li><p class="first">Johnson算法可在O(V2lgV+VE)时间内，求出每对顶点间的最短路径。Johnson算法使用Dijkstra和Bellman-Ford算法作为其子程序。</p>
<p>Johnson算法是一个实际上非常好的算法，它使得所有的情况（可能存在负权值和负权回路）都可以使用最好的Dijkstra算法来达到最好的运行效率。</p>
</li>
<li><p class="first">Johnson算法在所有的边为非负时，把每对顶点依次作为源点来执行Dijkstra算法，就可以找到每对顶点间的最短路径；利用斐波那契最小优先队列，该算法的运行时间为O(V2lgV+VE)。</p>
<p>因此也可以总结出：对于确定无负权值的图，直接循环调用Dijkstra算法就是求每对顶点间最短路径的最佳算法。</p>
</li>
<li><p class="first">Johnson算法使用了重赋权技术，对每一条边的权值w赋予一个新的权值w’，使用新的边权值集合满足以下两个性质：</p>
<ul class="simple">
<li>对所有的顶点u,v，如果路径p是在权值函数w下从u到v的最短路径，当且仅当p也是在权值函数w’下从u到v的最短路径；</li>
<li>对于所有的边u,v，新的权值w’(u,v)是非负的（于是满足Dijkstra算法的要求）。</li>
</ul>
</li>
<li><p class="first">Johnson算法的简明步骤：</p>
<img alt="../../_images/double_min_road.jpg" src="../../_images/double_min_road.jpg" />
<ul class="simple">
<li>生成一个新图G’，G’是在G上扩展一个起始点后的结果；</li>
<li>在G’上调用Bellman-Ford算法。由于Bellman-Ford算法能够检测负权回路，如果存在负权回路则报告存在负权回路并结束整个算法；否则得到在G’上调用Bellman-Ford算法得到的h(x)函数；</li>
<li>根据h(x)函数对G中的每一条边进行重赋权，使得G中的每一条边都是非负的；</li>
<li>对重赋权后的G进行循环调用Dijkstra算法，得到每对顶点间的最短路径；</li>
<li>对得到的每对顶点间的最短路径再根据h(x)函数反向构造出原来权值下的最短路径值。</li>
</ul>
</li>
</ul>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     floyd_warshall.cpp</span>
<span class="cm"> * @brief    FloydWarshall每对顶点间的最短路径算法</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;bitset&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;graphics.h&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="c1">/// @brief FloydWarshall每对顶点间的最短路径算法</span>
<span class="c1">///</span>
<span class="c1">/// Folyd-Warshall是一个动态规划算法，运行时间为O(V&lt;sup&gt;3&lt;/sup&gt;)，它允许权值为负的边，但是假定了不存在权值为负的回路。\n</span>
<span class="c1">/// Folyd-Warshall的核心在于：相对于“朴素动态规划算法”，它改进了“最优子问题结构”，使用d&lt;sub&gt;ij&lt;/sub&gt;(k)来表示从顶点i到顶点j、</span>
<span class="c1">/// 且满足所有中间顶点皆属于集合{1,2,…,k}的一条最短路径的权值。这种限定了起始点的技巧大大的减少了实现的计算量。\n</span>
<span class="c1">/// @note    Floyd -Warshall算法本来是需要三维的空间复杂度，但在实际算法中，为了节约空间，可以直接在原来空间</span>
<span class="c1">///        上进行迭代，这样空间可降至二维。（相比上一个版本的代码，这里已有体现）</span>
<span class="kt">void</span> <span class="n">FloydWarshall</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;FloydWarshall最短路径&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="c1">//生成P384页的图25-1</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="mi">1</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="mi">2</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="mi">3</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="mi">4</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="mi">5</span> <span class="p">);</span>
  <span class="n">GrpahicsViaAdjacencyMatrix</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">(</span> <span class="n">v</span><span class="p">,</span> <span class="n">Digraph</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span> <span class="p">);</span>

  <span class="kt">int</span> <span class="k">const</span> <span class="n">n</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>  <span class="c1">//顶点的个数</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">D</span><span class="p">(</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">n</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">g</span><span class="p">.</span><span class="n">GetEdge</span><span class="p">()[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">.</span><span class="n">GetEdge</span><span class="p">()[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">//中间结点允许为[k]的情况</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                       <span class="p">,</span> <span class="p">(</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span> <span class="o">||</span> <span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span>
                           <span class="o">?</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span>
                           <span class="o">:</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">D</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="p">)</span> <span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  &quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">FloydWarshall</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">FloydWarshall最短路径</span>
<span class="mi">0</span>  <span class="mi">1</span>  <span class="o">-</span><span class="mi">3</span>  <span class="mi">2</span>  <span class="o">-</span><span class="mi">4</span>  
<span class="mi">3</span>  <span class="mi">0</span>  <span class="o">-</span><span class="mi">4</span>  <span class="mi">1</span>  <span class="o">-</span><span class="mi">1</span>  
<span class="mi">7</span>  <span class="mi">4</span>  <span class="mi">0</span>  <span class="mi">5</span>  <span class="mi">3</span>  
<span class="mi">2</span>  <span class="o">-</span><span class="mi">1</span>  <span class="o">-</span><span class="mi">5</span>  <span class="mi">0</span>  <span class="o">-</span><span class="mi">2</span>  
<span class="mi">8</span>  <span class="mi">5</span>  <span class="mi">1</span>  <span class="mi">6</span>  <span class="mi">0</span>  
</pre></div>
</div>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     johnson.cpp</span>
<span class="cm"> * @brief    Johnson每对顶点间的最短路径算法</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;bitset&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;graphics.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;bellman_ford.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;dijkstra.h&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>



<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="c1">/// @brief Johnson每对顶点间的最短路径算法</span>
<span class="c1">///</span>
<span class="c1">/// Johnson算法可在O(V&lt;sup&gt;2&lt;/sup&gt;lgV+VE)时间内，求出每对顶点间的最短路径。Johnson算法使用Dijkstra和Bellman-Ford算法作为其子程序。  \n</span>
<span class="c1">/// Johnson算法在所有的边为非负时，把每对顶点依次作为源点来执行Dijkstra算法，就可以找到每对顶点间的最短路径；利用斐波那契最小优先队列，该算法的运行时间为O(V&lt;sup&gt;2&lt;/sup&gt;lgV+VE)。\n</span>
<span class="c1">/// &lt;b&gt;因此也可以总结出：对于确定无负权值的图，直接循环调用Dijkstra算法就是求每对顶点间最短路径的最佳算法。&lt;/b&gt;\n</span>
<span class="c1">/// Johnson算法使用了重赋权技术来处理负边权值，对每一条边的权值w赋予一个新的权值w’，使用新的边权值集合满足以下两个性质：</span>
<span class="c1">/// - 对所有的顶点u,v，如果路径p是在权值函数w下从u到v的最短路径，当且仅当p也是在权值函数w’下从u到v的最短路径；</span>
<span class="c1">/// - 对于所有的边u,v，新的权值w’(u,v)是非负的（很明显，这样就满足Dijkstra算法的要求，因此又回到重复调用Dijkstra算法来实现求每对顶点间最短路径）。</span>
<span class="c1">///</span>
<span class="c1">/// Johnson算法的简明步骤：</span>
<span class="c1">/// - 生成一个新图G’，G’是在G上扩展一个起始点后的结果；</span>
<span class="c1">/// - 在G’上调用Bellman-Ford算法。由于Bellman-Ford算法能够检测负权回路，如果存在负权回路则报告存在负权回路并结束整个算法；否则得到在G’上调用Bellman-Ford算法得到的h(x)函数；</span>
<span class="c1">/// - 根据h(x)函数对G中的每一条边进行重赋权，使得G中的每一条边都是非负的；</span>
<span class="c1">/// - 对重赋权后的G进行循环调用Dijkstra算法，得到每对顶点间的最短路径；</span>
<span class="c1">/// - 对得到的每对顶点间的最短路径再根据h(x)函数反向构造出原来权值下的最短路径值。</span>
<span class="c1">/// @remarks    Johnson算法是一个&lt;b&gt;实际上非常好&lt;/b&gt;的算法，它使得所有的情况（可能存在负权值和负权回路）都可以使用最好的Dijkstra算法来达到最好的运行效率。</span>
<span class="kt">void</span> <span class="n">Johnson</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Johnson最短路径&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="c1">//生成P384页的图25-1</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="mi">1</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="mi">2</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="mi">3</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="mi">4</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="mi">5</span> <span class="p">);</span>
  <span class="n">GraphicsViaAdjacencyList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">(</span> <span class="n">v</span><span class="p">,</span> <span class="n">Digraph</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">8</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span> <span class="p">);</span>
  <span class="kt">int</span> <span class="k">const</span> <span class="n">n</span> <span class="o">=</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">();</span>

  <span class="c1">//generate g&#39;</span>
  <span class="n">GraphicsViaAdjacencyList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">gplus</span><span class="p">(</span> <span class="n">v</span><span class="p">,</span> <span class="n">Digraph</span> <span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">g</span><span class="p">.</span><span class="n">IsLinked</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="p">).</span><span class="n">first</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">gplus</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">g</span><span class="p">.</span><span class="n">IsLinked</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="p">).</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">Weight</span> <span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">gplus</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">push_back</span><span class="p">(</span> <span class="mi">0</span> <span class="p">);</span>
  <span class="n">gplus</span><span class="p">.</span><span class="n">GetEdges</span><span class="p">().</span><span class="n">push_back</span><span class="p">(</span> <span class="k">nullptr</span> <span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">gplus</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="n">gplus</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span> <span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">//call bellman-ford algorithm on g&#39;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">d</span><span class="p">(</span> <span class="n">gplus</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">parent_index</span><span class="p">(</span> <span class="n">gplus</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">BellmanFord</span><span class="p">(</span> <span class="n">gplus</span><span class="p">,</span> <span class="n">gplus</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">parent_index</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;存在着负值回路，算法无法进行&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">//re-assign for g</span>
  <span class="k">auto</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">g</span><span class="p">.</span><span class="n">GetAllEdges</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">edges</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">node</span> <span class="o">=</span> <span class="n">g</span><span class="p">.</span><span class="n">IsLinked</span><span class="p">(</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span> <span class="p">).</span><span class="n">second</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">Weight</span> <span class="o">+=</span> <span class="p">(</span> <span class="n">d</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">]</span> <span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">//loop call dijkstra algorithm on g</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">D</span><span class="p">(</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">n</span> <span class="p">)</span> <span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">d2</span><span class="p">(</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">parent_index2</span><span class="p">(</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>

    <span class="n">Dijkstra</span><span class="p">(</span> <span class="n">g</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">parent_index2</span> <span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">d2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">//display result</span>
  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  &quot;</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">Johnson</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Johnson最短路径</span>
<span class="mi">0</span>  <span class="mi">1</span>  <span class="o">-</span><span class="mi">3</span>  <span class="mi">2</span>  <span class="o">-</span><span class="mi">4</span>  
<span class="mi">3</span>  <span class="mi">0</span>  <span class="o">-</span><span class="mi">4</span>  <span class="mi">1</span>  <span class="o">-</span><span class="mi">1</span>  
<span class="mi">7</span>  <span class="mi">4</span>  <span class="mi">0</span>  <span class="mi">5</span>  <span class="mi">3</span>  
<span class="mi">2</span>  <span class="o">-</span><span class="mi">1</span>  <span class="o">-</span><span class="mi">5</span>  <span class="mi">0</span>  <span class="o">-</span><span class="mi">2</span>  
<span class="mi">8</span>  <span class="mi">5</span>  <span class="mi">1</span>  <span class="mi">6</span>  <span class="mi">0</span>  
</pre></div>
</div>
</div>
<div class="section" id="id33">
<h3>第26章：最大流<a class="headerlink" href="#id33" title="永久链接至标题">¶</a></h3>
<ul>
<li><p class="first">流守恒：物质进入到某顶点的速度必须等于离开该顶点的速度。</p>
</li>
<li><p class="first">最大流问题：是关于流网络的最简单问题，它提出这样的问题：在不违背容量限制的条件下，把物质从源点传输到汇点的最大速率是多少？</p>
</li>
<li><p class="first">某个顶点处的总的净流量：为离开该顶点的总的正流量，减去进入该顶点的总的正流量。流守恒性的一种解释是这要瓣，即进行某个非源点非汇点顶点的正网络流，必须等于离开该顶点的正网络流。这个性质（即一个顶点处总的净流量必定为0）通常被非形式化地称为”流进等于流出”。</p>
</li>
<li><p class="first">抵消：利用了抵消处理，可以将两城市间的运输用一个流来表示，该流在两个顶点之间的至多一条边上是正的。也就是说，任何在两城市间相互运输球的情况，都可以通过抵消将其转化成一个相等的情况，球只在一个方向上传输：沿正网络流的方向。</p>
<p>这样：两个顶点之间至多有两条边，而这两条边至多会有一条有正的流值，另一条相应的边的流值为0（明白这点在理解算法时是有用的）。</p>
<img alt="../../_images/max_flow1.jpg" src="../../_images/max_flow1.jpg" />
</li>
<li><p class="first">具有多个源点和多个汇点的网络最大流问题可以转化成普通的单源点、单汇点的最大流问题（通过添加一个单一的源点和一个单一的汇点并置新添加的边的容量为无穷大来达到）。</p>
</li>
<li><p class="first">Ford-Fulkerson算法是求最大流的一般方法，它利用了三点：残留网络、增广路径、最大流最小割定理。</p>
<ul class="simple">
<li>残留网络：Gf由可以容纳更多网络流的边所组成；</li>
<li>增广路径：为残留网络Gf上从s到t的一条简单路径p，其中p中所的边的最小权值为该增广路径的残留容量；</li>
<li>最大流最小割定理：证明了Ford-Fulkerson算法能够得到全局最优解”当一个流是最大流，当且仅当它的残留网络不包含增广路径”。</li>
</ul>
</li>
<li><p class="first">Ford-Fulkerson算法的简明步骤：</p>
<img alt="../../_images/max_flow2.jpg" src="../../_images/max_flow2.jpg" />
<ul class="simple">
<li>初始化G中所有边的流为0；</li>
<li>计算当前图与当前流所映射的残留网络Gf；</li>
<li>从残留网络上选取一条增广路径并计算出残留容量，将残留容量添加到图的当前流上；</li>
<li>循环步骤b-c直到残留网络Gf中不存在增广路径为止；</li>
<li>此时的流即为G的最大流。</li>
</ul>
</li>
<li><p class="first">使用”广度优先搜索”来求增广路径的Ford-Fulkerson算法即称之为Edmonds-Karp算法，这种使用广度优先搜索来求增广路径的算法能够改善Ford-Fulkerson算法的运行时间。</p>
</li>
<li><p class="first">最大二分匹配问题：这是最大流最重要的应用之一，并且有许多其它的问题可以归约成它，有着许多的实际应用。</p>
<img alt="../../_images/max_flow3.jpg" src="../../_images/max_flow3.jpg" />
<p>例如：把一个机器集合L和要同时执行的任何集合R相匹配。E中的边(u,v)，就说明一台特定机器u能够完成一项特定任务v，最大匹配可以为尽可能多的机器提供任务）</p>
</li>
<li><p class="first">解决最大二分匹配问题：先生成一个扩展图G’，再对G’的每条边赋予单位流量1，然后求出最大流，就是该最大二分匹配问题的解。</p>
<img alt="../../_images/max_flow4.png" src="../../_images/max_flow4.png" />
</li>
</ul>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     ford_fulkerson.cpp</span>
<span class="cm"> * @brief    FordFulkerson最大流算法</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;bitset&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;graphics.h&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="p">{</span>

<span class="c1">/// 得到残留网络</span>
<span class="n">GrpahicsViaAdjacencyMatrix</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">GetResidualNetwork</span><span class="p">(</span> <span class="n">GrpahicsViaAdjacencyMatrix</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">g</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">f</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">GrpahicsViaAdjacencyMatrix</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">gplus</span><span class="p">(</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">(),</span> <span class="n">Digraph</span> <span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="n">g</span><span class="p">.</span><span class="n">IsLinked</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="p">)</span> <span class="o">||</span> <span class="n">g</span><span class="p">.</span><span class="n">IsLinked</span><span class="p">(</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">gplus</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">g</span><span class="p">.</span><span class="n">GetEdge</span><span class="p">()[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">f</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="p">);</span>
        <span class="n">gplus</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">g</span><span class="p">.</span><span class="n">GetEdge</span><span class="p">()[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">g</span><span class="p">.</span><span class="n">GetEdge</span><span class="p">()[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">gplus</span><span class="p">.</span><span class="n">GetEdge</span><span class="p">()[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">gplus</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// 运用广度优先算法得到增广路径</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">GetAugmentingPath</span><span class="p">(</span> <span class="n">GrpahicsViaAdjacencyMatrix</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">g</span> <span class="p">)</span> <span class="p">{</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span>

  <span class="c1">//q是一个队列pair&lt;要处理的结点的编号，在该广度优先路径中它的父结点&gt;</span>
  <span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
  <span class="c1">//每一个结点类广度优先遍历中当前的父结点</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">(</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="p">);</span>
  <span class="c1">//标识一个结点是否被访问过了</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span>  <span class="n">trivaled</span><span class="p">(</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">(),</span> <span class="nb">false</span> <span class="p">);</span>

  <span class="c1">//从s==0的结点开始</span>
  <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span> <span class="mi">0</span> <span class="p">);</span>
  <span class="n">parent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">trivaled</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span> <span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">front</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">trivaled</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">g</span><span class="p">.</span><span class="n">IsLinked</span><span class="p">(</span> <span class="n">front</span><span class="p">,</span> <span class="n">i</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span> <span class="n">i</span> <span class="p">);</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">front</span><span class="p">;</span>
        <span class="n">trivaled</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">==</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
          <span class="c1">//找到了t结点。构造出反向路径</span>
          <span class="kt">int</span> <span class="n">current_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
          <span class="k">while</span> <span class="p">(</span> <span class="n">current_index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">)</span> <span class="p">{</span>
            <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">current_index</span> <span class="p">);</span>
            <span class="n">current_index</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">current_index</span><span class="p">];</span>
          <span class="p">}</span>

          <span class="c1">//逆转为正向路径并返回</span>
          <span class="n">reverse</span><span class="p">(</span> <span class="n">path</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">path</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">path</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span>

<span class="c1">/// @brief FordFulkerson最大流算法</span>
<span class="c1">///</span>
<span class="c1">/// &lt;b&gt;最大流问题：是关于流网络的最简单问题，它提出这样的问题：在不违背容量限制的条件下，把物质从源点传输到汇点的最大速率是多少？&lt;/b&gt;\n</span>
<span class="c1">/// Ford-Fulkerson算法是求最大流的一般方法，它利用了三点：残留网络、增广路径、最大流最小割定理。</span>
<span class="c1">/// - 残留网络：G&lt;sub&gt;f&lt;/sub&gt;由可以容纳更多网络流的边所组成；</span>
<span class="c1">/// - 增广路径：为残留网络G&lt;sub&gt;f&lt;/sub&gt;上从s到t的一条简单路径p，其中p中所的边的最小权值为该增广路径的残留容量；</span>
<span class="c1">/// - 最大流最小割定理：证明了Ford-Fulkerson算法能够得到全局最优解“当一个流是最大流，当且仅当它的残留网络不包含增广路径”。</span>
<span class="c1">///</span>
<span class="c1">/// Ford-Fulkerson算法的简明步骤：</span>
<span class="c1">/// - 初始化G中所有边的流为0；</span>
<span class="c1">/// - 计算当前图与当前流所映射的残留网络G&lt;sub&gt;f&lt;/sub&gt;；</span>
<span class="c1">/// - 从残留网络上选取一条增广路径并计算出残留容量，将残留容量添加到图的当前流上；</span>
<span class="c1">/// - 循环步骤b-c直到残留网络G&lt;sub&gt;f&lt;/sub&gt;中不存在增广路径为止；</span>
<span class="c1">/// - 此时的流即为G的最大流。</span>
<span class="c1">///</span>
<span class="c1">/// 使用“广度优先搜索”来求增广路径的Ford-Fulkerson算法即称之为Edmonds-Karp算法，这种使用广度优先搜索来求增广路径</span>
<span class="c1">/// 的算法能够改善Ford-Fulkerson算法的运行时间。</span>
<span class="c1">/// @param  g    使用邻接矩阵表示的图</span>
<span class="kt">int</span> <span class="n">FordFulkerson</span><span class="p">(</span> <span class="n">GrpahicsViaAdjacencyMatrix</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">g</span> <span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="k">const</span> <span class="n">n</span> <span class="o">=</span> <span class="n">g</span><span class="p">.</span><span class="n">GetVertex</span><span class="p">().</span><span class="n">size</span><span class="p">();</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">f</span><span class="p">(</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">n</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">);</span>  <span class="c1">//f=fluent表示当前图上的流</span>

  <span class="k">while</span> <span class="p">(</span> <span class="nb">true</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">//得到残留网络</span>
    <span class="k">auto</span> <span class="n">gplus</span> <span class="o">=</span> <span class="n">GetResidualNetwork</span><span class="p">(</span> <span class="n">g</span><span class="p">,</span> <span class="n">f</span> <span class="p">);</span>
    <span class="k">auto</span> <span class="n">a_path</span> <span class="o">=</span> <span class="n">GetAugmentingPath</span><span class="p">(</span> <span class="n">gplus</span> <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">a_path</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">//增广路径为空，循环结束</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">path_values</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a_path</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">path_values</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="n">gplus</span><span class="p">.</span><span class="n">GetEdge</span><span class="p">()[</span><span class="n">a_path</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">a_path</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">min_path_value</span> <span class="o">=</span> <span class="o">*</span><span class="n">min_element</span><span class="p">(</span> <span class="n">path_values</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">path_values</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a_path</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">a_path</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">a_path</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>

      <span class="n">f</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="n">min_path_value</span><span class="p">;</span>

      <span class="c1">//算法导论P405页有这一句。但是原理上很明显这一句是不应该有的，而且事实也证明加上这一句就是错误的</span>
      <span class="c1">//不解了！也许又是书上的一个bug吧！</span>
      <span class="c1">//f[v][u] = -f[u][v];</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">accumulate</span><span class="p">(</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">begin</span><span class="p">(),</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span> <span class="p">);</span>
<span class="p">}</span>


<span class="c1">/// FordFulkerson最大流算法</span>
<span class="kt">void</span> <span class="n">testFordFulkerson</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;FordFulkerson最大流&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="c1">//生成P397页的图26-1(a)</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="s">&quot;s&quot;</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="s">&quot;v1&quot;</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="s">&quot;v2&quot;</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="s">&quot;v3&quot;</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="s">&quot;v4&quot;</span> <span class="p">);</span>
  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span> <span class="s">&quot;t&quot;</span> <span class="p">);</span>
  <span class="n">GrpahicsViaAdjacencyMatrix</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">g</span><span class="p">(</span> <span class="n">v</span><span class="p">,</span> <span class="n">Digraph</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">16</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">13</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">12</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">14</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">20</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span> <span class="p">);</span>
  <span class="n">g</span><span class="p">.</span><span class="n">Link2Vertex</span><span class="p">(</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span> <span class="p">);</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">FordFulkerson</span><span class="p">(</span> <span class="n">g</span> <span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">testFordFulkerson</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">FordFulkerson最大流</span>
<span class="mi">23</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id34">
<h2>第七部分：其它的零散代码<a class="headerlink" href="#id34" title="永久链接至标题">¶</a></h2>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     computational_geometry.cpp</span>
<span class="cm"> * @brief    计算几何学</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>


<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;bitset&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;exception&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stack&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="kt">double</span> <span class="k">const</span> <span class="n">k_PI</span><span class="o">=</span><span class="mf">3.14159265</span><span class="p">;</span>

<span class="c1">/// 点</span>
<span class="k">struct</span> <span class="n">PointD</span> <span class="p">{</span>
  <span class="n">PointD</span><span class="p">()</span> <span class="o">:</span> <span class="n">X</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Y</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">PointD</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span> <span class="o">:</span> <span class="n">X</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">Y</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">double</span> <span class="n">X</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">Y</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">/// 线段</span>
<span class="k">class</span> <span class="nc">Segments</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Segments</span><span class="p">(</span><span class="n">PointD</span> <span class="n">start</span><span class="p">,</span> <span class="n">PointD</span> <span class="n">end</span><span class="p">)</span> <span class="o">:</span> <span class="n">Start</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">End</span><span class="p">(</span><span class="n">end</span><span class="p">)</span> <span class="p">{}</span>

  <span class="n">Segments</span><span class="p">(</span><span class="kt">double</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y1</span><span class="p">,</span> <span class="kt">double</span> <span class="n">x2</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y2</span><span class="p">)</span> <span class="o">:</span> <span class="n">Start</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="n">End</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="p">{}</span>

  <span class="c1">/// @brief 判断是否与另一条线段相交</span>
  <span class="c1">///</span>
  <span class="c1">/// 先求两条线段所在直线的方程,求出对应的a和b(y=ax+b). &lt;br/&gt;</span>
  <span class="c1">/// 关键在于相交的两条线段一定满足这个性质:任意一条线段的2个端点一定分布在另外一条线段所对应的直线的两侧(或者之上)</span>
  <span class="c1">/// @note 使用了除法,精度不如&lt;算法导论&gt;上介绍的方法好,但是简单易懂</span>
  <span class="kt">bool</span> <span class="n">IsIntersect</span><span class="p">(</span><span class="n">Segments</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">a1</span> <span class="o">=</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">.</span><span class="n">Y</span> <span class="o">-</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">End</span><span class="p">.</span><span class="n">Y</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">.</span><span class="n">X</span> <span class="o">-</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">End</span><span class="p">.</span><span class="n">X</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">b1</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">.</span><span class="n">Y</span> <span class="o">-</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">.</span><span class="n">X</span> <span class="o">*</span> <span class="n">a1</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">a2</span> <span class="o">=</span> <span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">Start</span><span class="p">.</span><span class="n">Y</span> <span class="o">-</span> <span class="n">other</span><span class="p">.</span><span class="n">End</span><span class="p">.</span><span class="n">Y</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">Start</span><span class="p">.</span><span class="n">X</span> <span class="o">-</span> <span class="n">other</span><span class="p">.</span><span class="n">End</span><span class="p">.</span><span class="n">X</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">Start</span><span class="p">.</span><span class="n">Y</span> <span class="o">-</span> <span class="n">other</span><span class="p">.</span><span class="n">Start</span><span class="p">.</span><span class="n">X</span> <span class="o">*</span> <span class="n">a2</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">Start</span><span class="p">.</span><span class="n">Y</span> <span class="o">-</span> <span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">Start</span><span class="p">.</span><span class="n">X</span> <span class="o">*</span> <span class="n">a1</span> <span class="o">+</span> <span class="n">b1</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">End</span><span class="p">.</span><span class="n">Y</span> <span class="o">-</span> <span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">End</span><span class="p">.</span><span class="n">X</span> <span class="o">*</span> <span class="n">a1</span> <span class="o">+</span> <span class="n">b1</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">epsilon</span><span class="p">()</span>
         <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">.</span><span class="n">Y</span> <span class="o">-</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">.</span><span class="n">X</span> <span class="o">*</span> <span class="n">a2</span> <span class="o">+</span> <span class="n">b2</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">End</span><span class="p">.</span><span class="n">Y</span> <span class="o">-</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">End</span><span class="p">.</span><span class="n">X</span> <span class="o">*</span> <span class="n">a2</span> <span class="o">+</span> <span class="n">b2</span><span class="p">))</span>  <span class="o">&lt;=</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">epsilon</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">/// 与另一条线段的叉积</span>
  <span class="kt">double</span> <span class="n">CrossProduct</span><span class="p">(</span><span class="n">Segments</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">PointD</span> <span class="n">p1</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">p2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">p1</span><span class="p">.</span><span class="n">X</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">End</span><span class="p">.</span><span class="n">X</span> <span class="o">-</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">.</span><span class="n">X</span><span class="p">;</span>
    <span class="n">p1</span><span class="p">.</span><span class="n">Y</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">End</span><span class="p">.</span><span class="n">Y</span> <span class="o">-</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">Start</span><span class="p">.</span><span class="n">Y</span><span class="p">;</span>
    <span class="n">p2</span><span class="p">.</span><span class="n">X</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">End</span><span class="p">.</span><span class="n">X</span> <span class="o">-</span> <span class="n">other</span><span class="p">.</span><span class="n">Start</span><span class="p">.</span><span class="n">X</span><span class="p">;</span>
    <span class="n">p2</span><span class="p">.</span><span class="n">Y</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">End</span><span class="p">.</span><span class="n">Y</span> <span class="o">-</span> <span class="n">other</span><span class="p">.</span><span class="n">Start</span><span class="p">.</span><span class="n">Y</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">p1</span><span class="p">.</span><span class="n">X</span> <span class="o">*</span> <span class="n">p2</span><span class="p">.</span><span class="n">Y</span> <span class="o">-</span> <span class="n">p2</span><span class="p">.</span><span class="n">X</span> <span class="o">*</span> <span class="n">p1</span><span class="p">.</span><span class="n">Y</span><span class="p">;</span>
  <span class="p">}</span>


<span class="k">public</span><span class="o">:</span>
  <span class="n">PointD</span> <span class="n">Start</span><span class="p">;</span>
  <span class="n">PointD</span> <span class="n">End</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">/// 确定任意一对线段是否相交</span>
<span class="kt">bool</span> <span class="nf">IsAnySegmentsIntersect</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Segments</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">segs</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">/// 线段的端点</span>
  <span class="k">struct</span> <span class="n">EndPoint</span> <span class="p">{</span>
    <span class="n">EndPoint</span><span class="p">(</span><span class="n">PointD</span> <span class="n">point</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isLeft</span><span class="p">,</span> <span class="n">Segments</span> <span class="k">const</span> <span class="o">*</span><span class="n">releationSegment</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">Point</span><span class="p">(</span><span class="n">Point</span><span class="p">),</span> <span class="n">IsLeft</span><span class="p">(</span><span class="n">isLeft</span><span class="p">),</span> <span class="n">ReleationSegment</span><span class="p">(</span><span class="n">releationSegment</span><span class="p">)</span> <span class="p">{}</span>

    <span class="n">PointD</span>  <span class="n">Point</span><span class="p">;</span>
    <span class="kt">bool</span>  <span class="n">IsLeft</span><span class="p">;</span>
    <span class="n">Segments</span> <span class="k">const</span> <span class="o">*</span><span class="n">ReleationSegment</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="n">EndPoint</span><span class="o">&gt;</span> <span class="n">endpoints</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">segs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Segments</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">seg</span> <span class="o">=</span> <span class="n">segs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">endpoints</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">EndPoint</span><span class="p">(</span><span class="n">seg</span><span class="p">.</span><span class="n">Start</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">seg</span><span class="p">));</span>
    <span class="n">endpoints</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">EndPoint</span><span class="p">(</span><span class="n">seg</span><span class="p">.</span><span class="n">End</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">seg</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="n">sort</span><span class="p">(</span><span class="n">endpoints</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">endpoints</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="n">EndPoint</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span> <span class="n">EndPoint</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">Point</span><span class="p">.</span><span class="n">X</span> <span class="o">!=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">Point</span><span class="p">.</span><span class="n">X</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">Point</span><span class="p">.</span><span class="n">X</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">Point</span><span class="p">.</span><span class="n">X</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">IsLeft</span> <span class="o">!=</span> <span class="n">rhs</span><span class="p">.</span><span class="n">IsLeft</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">IsLeft</span> <span class="o">==</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">Point</span><span class="p">.</span><span class="n">Y</span> <span class="o">&lt;</span> <span class="n">rhs</span><span class="p">.</span><span class="n">Point</span><span class="p">.</span><span class="n">Y</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">});</span>


  <span class="k">struct</span> <span class="n">_Segment_Pred_Fun</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Segments</span> <span class="k">const</span> <span class="o">*</span><span class="n">lhs</span><span class="p">,</span> <span class="n">Segments</span> <span class="k">const</span> <span class="o">*</span><span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">lhs</span><span class="o">-&gt;</span><span class="n">CrossProduct</span><span class="p">(</span><span class="o">*</span><span class="n">rhs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="n">set</span><span class="o">&lt;</span><span class="n">Segments</span> <span class="k">const</span> <span class="o">*</span><span class="p">,</span> <span class="n">_Segment_Pred_Fun</span><span class="o">&gt;</span> <span class="n">t</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">endpoints</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">endpoints</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">IsLeft</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">auto</span> <span class="n">insert_iter</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">endpoints</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ReleationSegment</span><span class="p">).</span><span class="n">first</span><span class="p">;</span>

      <span class="k">auto</span> <span class="n">above_iter</span> <span class="o">=</span> <span class="n">insert_iter</span><span class="p">;</span>
      <span class="n">above_iter</span><span class="o">--</span><span class="p">;</span>
      <span class="k">auto</span> <span class="n">below_iter</span> <span class="o">=</span> <span class="n">insert_iter</span><span class="p">;</span>
      <span class="n">below_iter</span><span class="o">++</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">above_iter</span> <span class="o">!=</span> <span class="n">t</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">above_iter</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">IsIntersect</span><span class="p">(</span><span class="o">*</span><span class="n">endpoints</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ReleationSegment</span><span class="p">))</span>
          <span class="o">||</span> <span class="p">(</span><span class="n">below_iter</span> <span class="o">!=</span> <span class="n">t</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">below_iter</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">IsIntersect</span><span class="p">(</span><span class="o">*</span><span class="n">endpoints</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ReleationSegment</span><span class="p">)))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">auto</span> <span class="n">find_iter</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">endpoints</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ReleationSegment</span><span class="p">);</span>
      <span class="k">auto</span> <span class="n">above_iter</span> <span class="o">=</span> <span class="n">find_iter</span><span class="p">;</span>
      <span class="n">above_iter</span><span class="o">--</span><span class="p">;</span>
      <span class="k">auto</span> <span class="n">below_iter</span> <span class="o">=</span> <span class="n">find_iter</span><span class="p">;</span>
      <span class="n">below_iter</span><span class="o">++</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">above_iter</span> <span class="o">!=</span> <span class="n">t</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">below_iter</span> <span class="o">!=</span> <span class="n">t</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">above_iter</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">IsIntersect</span><span class="p">(</span><span class="o">**</span><span class="n">below_iter</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="n">t</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">find_iter</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//两个点之间的距离</span>
<span class="kt">double</span> <span class="nf">PointDistance</span><span class="p">(</span><span class="n">PointD</span> <span class="n">pp1</span><span class="p">,</span> <span class="n">PointD</span> <span class="n">pp2</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">pp1</span><span class="p">.</span><span class="n">X</span> <span class="o">-</span> <span class="n">pp2</span><span class="p">.</span><span class="n">X</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">pp1</span><span class="p">.</span><span class="n">X</span> <span class="o">-</span> <span class="n">pp2</span><span class="p">.</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">pp1</span><span class="p">.</span><span class="n">Y</span> <span class="o">-</span> <span class="n">pp2</span><span class="p">.</span><span class="n">Y</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">pp1</span><span class="p">.</span><span class="n">Y</span> <span class="o">-</span> <span class="n">pp2</span><span class="p">.</span><span class="n">Y</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">/// 计算p1相对于p0的方向角度</span>
<span class="kt">double</span> <span class="nf">CalcAngleOfTwoPoints</span><span class="p">(</span><span class="n">PointD</span> <span class="n">p0</span><span class="p">,</span> <span class="n">PointD</span> <span class="n">p1</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">X</span> <span class="o">==</span> <span class="n">p0</span><span class="p">.</span><span class="n">X</span><span class="p">)</span> <span class="p">{</span>   <span class="c1">//x坐标相同时的情况</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">Y</span> <span class="o">==</span> <span class="n">p0</span><span class="p">.</span><span class="n">Y</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">Y</span> <span class="o">&gt;</span> <span class="n">p0</span><span class="p">.</span><span class="n">Y</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">k_PI</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">k_PI</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>        <span class="c1">//x坐标不同时的情况</span>
    <span class="kt">double</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">atan</span><span class="p">(</span><span class="n">abs</span><span class="p">((</span><span class="n">p1</span><span class="p">.</span><span class="n">Y</span> <span class="o">-</span> <span class="n">p0</span><span class="p">.</span><span class="n">Y</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">X</span> <span class="o">-</span> <span class="n">p0</span><span class="p">.</span><span class="n">X</span><span class="p">)));</span>    <span class="c1">//普通情况为在一象限时的情况</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">Y</span> <span class="o">&gt;=</span> <span class="n">p0</span><span class="p">.</span><span class="n">Y</span><span class="p">)</span> <span class="p">{</span>     <span class="c1">//在一二象限</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">X</span> <span class="o">&lt;</span> <span class="n">p0</span><span class="p">.</span><span class="n">X</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//二象限</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">k_PI</span> <span class="o">-</span> <span class="n">angle</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>          <span class="c1">//在三四象限</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">X</span> <span class="o">&lt;</span> <span class="n">p0</span><span class="p">.</span><span class="n">X</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//三象限</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">k_PI</span> <span class="o">+</span> <span class="n">angle</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>      <span class="c1">//四象限</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">k_PI</span> <span class="o">-</span> <span class="n">angle</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">angle</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">///判断向量p2,p3相对于p2,p1的转向是不是向左转</span>
<span class="kt">bool</span> <span class="nf">IsLeftTurn</span><span class="p">(</span><span class="n">PointD</span> <span class="n">p1</span><span class="p">,</span> <span class="n">PointD</span> <span class="n">p2</span><span class="p">,</span> <span class="n">PointD</span> <span class="n">p3</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//使用叉积来判断向左转还是向右转 p576页</span>
  <span class="k">return</span> <span class="n">Segments</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">p1</span><span class="p">).</span><span class="n">CrossProduct</span><span class="p">(</span><span class="n">Segments</span><span class="p">(</span><span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// 求凸包的Graham算法</span>
<span class="n">stack</span><span class="o">&lt;</span><span class="n">PointD</span><span class="o">&gt;</span> <span class="n">GrahamConvexHull</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PointD</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">points</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">PointDWapper</span> <span class="p">{</span>
    <span class="n">PointDWapper</span><span class="p">(</span><span class="n">PointD</span> <span class="n">p</span><span class="p">,</span> <span class="kt">double</span> <span class="n">angle</span><span class="p">,</span> <span class="kt">double</span> <span class="n">distance</span><span class="p">)</span> <span class="o">:</span> <span class="n">Point</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">Angle</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">Distance</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">PointD</span> <span class="n">Point</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">Angle</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">Distance</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="n">PointDWapper</span><span class="o">&gt;</span> <span class="n">ps</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">min_iter</span> <span class="o">=</span> <span class="n">min_element</span><span class="p">(</span><span class="n">points</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">points</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="n">PointD</span> <span class="n">p1</span><span class="p">,</span> <span class="n">PointD</span> <span class="n">p2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">p1</span><span class="p">.</span><span class="n">Y</span> <span class="o">&lt;</span> <span class="n">p1</span><span class="p">.</span><span class="n">Y</span><span class="p">;</span>
  <span class="p">});</span>
  <span class="n">PointD</span> <span class="n">min_point</span> <span class="o">=</span> <span class="o">*</span><span class="n">min_iter</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">PointD</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">p</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">X</span> <span class="o">!=</span> <span class="n">min_point</span><span class="p">.</span><span class="n">X</span> <span class="o">||</span> <span class="n">p</span><span class="p">.</span><span class="n">Y</span> <span class="o">!=</span> <span class="n">min_point</span><span class="p">.</span><span class="n">Y</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">PointDWapper</span> <span class="n">pw</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">CalcAngleOfTwoPoints</span><span class="p">(</span><span class="n">min_point</span><span class="p">,</span> <span class="n">p</span><span class="p">),</span> <span class="n">PointDistance</span><span class="p">(</span><span class="n">min_point</span><span class="p">,</span> <span class="n">p</span><span class="p">));</span>
      <span class="n">ps</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pw</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="n">sort</span><span class="p">(</span><span class="n">ps</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ps</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">PointDWapper</span> <span class="n">p1</span><span class="p">,</span> <span class="n">PointDWapper</span> <span class="n">p2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">//以 角度的顺序+距离的逆序 进行排序</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">Angle</span> <span class="o">!=</span> <span class="n">p2</span><span class="p">.</span><span class="n">Angle</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">p1</span><span class="p">.</span><span class="n">Angle</span> <span class="o">&lt;</span> <span class="n">p2</span><span class="p">.</span><span class="n">Angle</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">p1</span><span class="p">.</span><span class="n">Distance</span> <span class="o">&gt;</span> <span class="n">p2</span><span class="p">.</span><span class="n">Distance</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">});</span>

  <span class="c1">//清除角度相同的点 ,只保留举例最远的点</span>
  <span class="n">ps</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">unique</span><span class="p">(</span><span class="n">ps</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ps</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="n">PointDWapper</span> <span class="n">p1</span><span class="p">,</span> <span class="n">PointDWapper</span> <span class="n">p2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">p1</span><span class="p">.</span><span class="n">Angle</span> <span class="o">==</span> <span class="n">p2</span><span class="p">.</span><span class="n">Angle</span><span class="p">;</span>
  <span class="p">}),</span> <span class="n">ps</span><span class="p">.</span><span class="n">end</span><span class="p">());;</span>

  <span class="n">stack</span><span class="o">&lt;</span><span class="n">PointD</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
  <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">min_point</span><span class="p">);</span>
  <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Point</span><span class="p">);</span>
  <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">Point</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ps</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">do</span> <span class="p">{</span>
      <span class="n">PointD</span> <span class="n">top</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
      <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
      <span class="n">PointD</span> <span class="n">next_top</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
      <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">top</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IsLeftTurn</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Point</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span> <span class="n">next_top</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">);</span>
    <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Point</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// 寻找最近点对的分治算法</span>
<span class="n">pair</span><span class="o">&lt;</span><span class="n">PointD</span><span class="p">,</span> <span class="n">PointD</span><span class="o">&gt;</span> <span class="n">_NearestPointPair</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PointD</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">X</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">PointD</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">Y</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pair</span><span class="o">&lt;</span><span class="n">PointD</span><span class="p">,</span> <span class="n">PointD</span><span class="o">&gt;</span> <span class="n">min_pair</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>     <span class="c1">//临界条件,少于或等于3个点时直接求出最近距离点对</span>
    <span class="kt">double</span> <span class="n">min_distance</span> <span class="o">=</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">X</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">X</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">double</span> <span class="n">dis</span> <span class="o">=</span> <span class="n">PointDistance</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dis</span> <span class="o">&lt;</span> <span class="n">min_distance</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">min_distance</span> <span class="o">=</span> <span class="n">dis</span><span class="p">;</span>
          <span class="n">min_pair</span> <span class="o">=</span> <span class="n">make_pair</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">min_pair</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>          <span class="c1">//不满足临界条件,大于3小个点,需要进行分治</span>
    <span class="k">auto</span> <span class="n">pred_by_Y</span> <span class="o">=</span> <span class="p">[](</span><span class="n">PointD</span> <span class="n">p1</span><span class="p">,</span> <span class="n">PointD</span> <span class="n">p2</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">p1</span><span class="p">.</span><span class="n">Y</span> <span class="o">&lt;</span> <span class="n">p2</span><span class="p">.</span><span class="n">Y</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">PointD</span><span class="o">&gt;</span> <span class="n">left_side_X</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">X</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">X</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">PointD</span><span class="o">&gt;</span> <span class="n">right_side_X</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">X</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">X</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">PointD</span><span class="o">&gt;</span> <span class="n">left_side_Y</span><span class="p">(</span><span class="n">left_side_X</span><span class="p">);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">PointD</span><span class="o">&gt;</span> <span class="n">right_side_Y</span><span class="p">(</span><span class="n">right_side_X</span><span class="p">);</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">left_side_Y</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">left_side_Y</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">pred_by_Y</span><span class="p">);</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">right_side_Y</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">right_side_Y</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">pred_by_Y</span><span class="p">);</span>

    <span class="k">auto</span> <span class="n">left_nearest</span> <span class="o">=</span> <span class="n">_NearestPointPair</span><span class="p">(</span><span class="n">left_side_X</span><span class="p">,</span> <span class="n">left_side_Y</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">right_nearest</span> <span class="o">=</span> <span class="n">_NearestPointPair</span><span class="p">(</span><span class="n">right_side_X</span><span class="p">,</span> <span class="n">right_side_Y</span><span class="p">);</span>

    <span class="kt">double</span> <span class="n">nearest_distance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">PointDistance</span><span class="p">(</span><span class="n">left_nearest</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">left_nearest</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">PointDistance</span><span class="p">(</span><span class="n">right_nearest</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">right_nearest</span><span class="p">.</span><span class="n">second</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">nearest_distance</span> <span class="o">=</span> <span class="n">PointDistance</span><span class="p">(</span><span class="n">left_nearest</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">left_nearest</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
      <span class="n">min_pair</span> <span class="o">=</span> <span class="n">left_nearest</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">nearest_distance</span> <span class="o">=</span> <span class="n">PointDistance</span><span class="p">(</span><span class="n">right_nearest</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">right_nearest</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
      <span class="n">min_pair</span> <span class="o">=</span> <span class="n">right_nearest</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">double</span> <span class="n">split_x</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">X</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)).</span><span class="n">X</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">PointD</span><span class="o">&gt;</span> <span class="n">y_plus</span><span class="p">;</span>
    <span class="n">copy_if</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">X</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">back_inserter</span><span class="p">(</span><span class="n">y_plus</span><span class="p">),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">PointD</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">abs</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">X</span> <span class="o">-</span> <span class="n">split_x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">nearest_distance</span><span class="p">;</span>
    <span class="p">});</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">y_plus</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">y_plus</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">pred_by_Y</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">y_plus</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">y_plus</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">,</span> <span class="o">++</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">PointDistance</span><span class="p">(</span><span class="n">y_plus</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y_plus</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">nearest_distance</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">nearest_distance</span> <span class="o">=</span> <span class="n">PointDistance</span><span class="p">(</span><span class="n">y_plus</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y_plus</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
          <span class="n">min_pair</span> <span class="o">=</span> <span class="n">make_pair</span><span class="p">(</span><span class="n">y_plus</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y_plus</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">min_pair</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">/// 寻找最近点对</span>
<span class="n">pair</span><span class="o">&lt;</span><span class="n">PointD</span><span class="p">,</span> <span class="n">PointD</span><span class="o">&gt;</span> <span class="n">GetNearestPointPair</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PointD</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">points</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="n">logic_error</span><span class="p">(</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;Error number of points&quot;</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="n">PointD</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">(</span><span class="n">points</span><span class="p">);</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">PointD</span><span class="o">&gt;</span> <span class="n">Y</span><span class="p">(</span><span class="n">points</span><span class="p">);</span>

  <span class="c1">//数组X按X坐标顺序排列</span>
  <span class="n">sort</span><span class="p">(</span><span class="n">X</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">X</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="n">PointD</span> <span class="n">p1</span><span class="p">,</span> <span class="n">PointD</span> <span class="n">p2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">p1</span><span class="p">.</span><span class="n">X</span> <span class="o">&lt;</span> <span class="n">p2</span><span class="p">.</span><span class="n">X</span><span class="p">;</span>
  <span class="p">});</span>
  <span class="c1">//数组Y按Y坐标顺序排列</span>
  <span class="n">sort</span><span class="p">(</span><span class="n">Y</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">Y</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="n">PointD</span> <span class="n">p1</span><span class="p">,</span> <span class="n">PointD</span> <span class="n">p2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">p1</span><span class="p">.</span><span class="n">Y</span> <span class="o">&lt;</span> <span class="n">p2</span><span class="p">.</span><span class="n">Y</span><span class="p">;</span>
  <span class="p">});</span>

  <span class="k">return</span> <span class="nf">_NearestPointPair</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">testComputionalGeometry</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// 测试IsIntersect算法</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;============测试IsIntersect算法============&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">Segments</span> <span class="nf">s1</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
  <span class="n">Segments</span> <span class="nf">s2</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">Segments</span> <span class="nf">s3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">boolalpha</span> <span class="o">&lt;&lt;</span> <span class="n">s1</span><span class="p">.</span><span class="n">IsIntersect</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">boolalpha</span> <span class="o">&lt;&lt;</span> <span class="n">s1</span><span class="p">.</span><span class="n">IsIntersect</span><span class="p">(</span><span class="n">s3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>


  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;===============Graham凸包算法==============&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">PointD</span><span class="o">&gt;</span> <span class="n">points</span><span class="p">;</span>
  <span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">PointD</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
  <span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">PointD</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
  <span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">PointD</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">));</span>
  <span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">PointD</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">));</span>
  <span class="n">points</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">PointD</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
  <span class="n">stack</span><span class="o">&lt;</span><span class="n">PointD</span><span class="o">&gt;</span> <span class="n">ps</span> <span class="o">=</span> <span class="n">GrahamConvexHull</span><span class="p">(</span><span class="n">points</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ps</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">PointD</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ps</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;(&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">X</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">Y</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;)&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="n">ps</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;============最近点对的分治算法=============&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="n">pair</span><span class="o">&lt;</span><span class="n">PointD</span><span class="p">,</span> <span class="n">PointD</span><span class="o">&gt;</span> <span class="n">pp</span> <span class="o">=</span> <span class="n">GetNearestPointPair</span><span class="p">(</span><span class="n">points</span><span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pp</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">X</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">pp</span><span class="p">.</span><span class="n">first</span><span class="p">.</span><span class="n">Y</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; ====== &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">pp</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">X</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">pp</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">Y</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">testComputionalGeometry</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>============测试IsIntersect算法============
true
false
===============Graham凸包算法==============
(1, 5)
(5, 5)
(5, 1)
(1, 1)
============最近点对的分治算法=============
3, 2 ====== 5, 1
</pre></div>
</div>
<div class="highlight-cpp notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * @file     string_match.cpp</span>
<span class="cm"> * @brief    字符串匹配算法</span>
<span class="cm"> *</span>
<span class="cm"> * Distributed under the GPL License version 3, see: http://www.gnu.org/licenses</span>
<span class="cm"> * Author: chuanqi.tan(at)gmail.com</span>
<span class="cm"> */</span>


<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iterator&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;bitset&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;limits&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>


<span class="k">namespace</span> <span class="n">ita</span> <span class="p">{</span>
<span class="c1">//有限状态自动机</span>
<span class="k">class</span> <span class="nc">DefineAutomationMatcher</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">DefineAutomationMatcher</span><span class="p">(</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">pattern</span><span class="p">)</span> <span class="o">:</span> <span class="n">_pattern</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">_pattern</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>      <span class="c1">//从状态i开始</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">sk_Character_Set</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//经过字符sk_Character_Set[j]进行状态转移</span>
        <span class="kt">size_t</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>                  <span class="c1">//试图转移到状态k</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">_IsPostfix</span><span class="p">(</span><span class="n">_pattern</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">sk_Character_Set</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">k</span><span class="p">))</span> <span class="p">{</span>
          <span class="o">--</span><span class="n">k</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">_state_transfer_f</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sk_Character_Set</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="n">k</span><span class="p">));</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">Match</span><span class="p">(</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">text</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">current_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">text</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">_state_transfer_f</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">make_pair</span><span class="p">(</span><span class="n">current_state</span><span class="p">,</span> <span class="n">text</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">==</span> <span class="n">_state_transfer_f</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">current_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>    <span class="c1">//恢复到初始状态</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">current_state</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">iter</span><span class="p">).</span><span class="n">second</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">current_state</span> <span class="o">==</span> <span class="n">_pattern</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
          <span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="n">_pattern</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>    <span class="c1">//匹配成功</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>    <span class="c1">//匹配失败</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="kt">bool</span> <span class="n">_IsPostfix</span><span class="p">(</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">i</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">str1</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
    <span class="n">string</span> <span class="n">str2</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">str1</span> <span class="o">==</span> <span class="n">str2</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">str2</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="n">k</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="n">string</span> <span class="k">const</span>         <span class="n">sk_Character_Set</span><span class="p">;</span>       <span class="c1">//字符集</span>
  <span class="n">string</span> <span class="k">const</span>                <span class="n">_pattern</span><span class="p">;</span>               <span class="c1">//要匹配的模式</span>
  <span class="n">map</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span>   <span class="n">_state_transfer_f</span><span class="p">;</span>      <span class="c1">//状态转移函数</span>
<span class="p">};</span>

<span class="n">string</span> <span class="k">const</span> <span class="n">DefineAutomationMatcher</span><span class="o">::</span><span class="n">sk_Character_Set</span> <span class="o">=</span> <span class="s">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span><span class="p">;</span>


<span class="c1">//KMP算法</span>
<span class="kt">int</span> <span class="nf">KMPMatch</span><span class="p">(</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">text</span><span class="p">,</span> <span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 计算pattern的部分匹配值</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pi</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// &quot;部分匹配值&quot;就是&quot;前缀&quot;和&quot;后缀&quot;的最长的共有元素的长度。</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">p</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">pi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">//match 过程</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">text</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">text</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
      <span class="o">++</span><span class="n">j</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;=</span> <span class="n">p</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>     <span class="c1">//matched：匹配成功</span>
      <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>    <span class="c1">//swap to next：第一个匹配就不同，移动到下一个</span>
      <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">//尽量右移，</span>
      <span class="c1">//公式为: 移动位数 = 已匹配的字符数 - 对应的部分匹配值</span>
      <span class="n">i</span> <span class="o">+=</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">pi</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>  
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">StringMatchAlgorithms</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">pattern</span> <span class="o">=</span> <span class="s">&quot;abc&quot;</span><span class="p">;</span>
  <span class="n">DefineAutomationMatcher</span> <span class="n">matcher</span><span class="p">(</span><span class="n">pattern</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">50000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">string</span> <span class="n">text</span> <span class="o">=</span> <span class="s">&quot;aaaaaaaaaa&quot;</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">text</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">text</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">26</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">b1</span> <span class="o">=</span> <span class="p">(</span><span class="n">KMPMatch</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">pattern</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="n">b2</span> <span class="o">=</span> <span class="p">(</span><span class="n">matcher</span><span class="p">.</span><span class="n">Match</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">b1</span> <span class="o">!=</span> <span class="n">b2</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;两种方法结果不同！！！ : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">text</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">text</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;出现包含 &#39;abc&#39; 的串 : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">text</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">b1</span> <span class="o">&amp;&amp;</span> <span class="n">b2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;两种方法都匹配成功 : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">text</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;至少一种方法未匹配成功 : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">text</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">b1</span> <span class="o">||</span> <span class="n">b2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;不包含 &#39;abc&#39; 的串被某种方法误匹配：&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">text</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ita</span><span class="o">::</span><span class="n">StringMatchAlgorithms</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>出现包含 &#39;abc&#39; 的串 : abcklcmmpc	两种方法都匹配成功 : abcklcmmpc
出现包含 &#39;abc&#39; 的串 : hhwabcgaua	两种方法都匹配成功 : hhwabcgaua
出现包含 &#39;abc&#39; 的串 : xabckhshth	两种方法都匹配成功 : xabckhshth
出现包含 &#39;abc&#39; 的串 : abczuvfqln	两种方法都匹配成功 : abczuvfqln
出现包含 &#39;abc&#39; 的串 : laudgabckz	两种方法都匹配成功 : laudgabckz
出现包含 &#39;abc&#39; 的串 : vabcionuqg	两种方法都匹配成功 : vabcionuqg
出现包含 &#39;abc&#39; 的串 : oabcbxymqx	两种方法都匹配成功 : oabcbxymqx
出现包含 &#39;abc&#39; 的串 : panabclupq	两种方法都匹配成功 : panabclupq
出现包含 &#39;abc&#39; 的串 : ajabcxaufr	两种方法都匹配成功 : ajabcxaufr
出现包含 &#39;abc&#39; 的串 : gswqbjabcv	两种方法都匹配成功 : gswqbjabcv
出现包含 &#39;abc&#39; 的串 : hquepabchn	两种方法都匹配成功 : hquepabchn
出现包含 &#39;abc&#39; 的串 : tabcliltkl	两种方法都匹配成功 : tabcliltkl
出现包含 &#39;abc&#39; 的串 : jpjsrabccs	两种方法都匹配成功 : jpjsrabccs
出现包含 &#39;abc&#39; 的串 : pbpgxabctx	两种方法都匹配成功 : pbpgxabctx
出现包含 &#39;abc&#39; 的串 : abctrqdwjo	两种方法都匹配成功 : abctrqdwjo
出现包含 &#39;abc&#39; 的串 : cjqbabcvol	两种方法都匹配成功 : cjqbabcvol
出现包含 &#39;abc&#39; 的串 : hmuhrabcqn	两种方法都匹配成功 : hmuhrabcqn
出现包含 &#39;abc&#39; 的串 : lxabcxsups	两种方法都匹配成功 : lxabcxsups
出现包含 &#39;abc&#39; 的串 : qmkdabcdhq	两种方法都匹配成功 : qmkdabcdhq
出现包含 &#39;abc&#39; 的串 : ysznabcvwu	两种方法都匹配成功 : ysznabcvwu
出现包含 &#39;abc&#39; 的串 : cxabcxncsg	两种方法都匹配成功 : cxabcxncsg
出现包含 &#39;abc&#39; 的串 : abcdycvuwj	两种方法都匹配成功 : abcdycvuwj
出现包含 &#39;abc&#39; 的串 : eqoypabchv	两种方法都匹配成功 : eqoypabchv
出现包含 &#39;abc&#39; 的串 : gabcgptznv	两种方法都匹配成功 : gabcgptznv
出现包含 &#39;abc&#39; 的串 : abckqqfpfl	两种方法都匹配成功 : abckqqfpfl
出现包含 &#39;abc&#39; 的串 : abcelcknau	两种方法都匹配成功 : abcelcknau
出现包含 &#39;abc&#39; 的串 : nikamabcla	两种方法都匹配成功 : nikamabcla
出现包含 &#39;abc&#39; 的串 : muqwgxsabc	两种方法都匹配成功 : muqwgxsabc
</pre></div>
</div>
<p class="rubric">引用</p>
<table class="docutils footnote" frame="void" id="id35" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>《算法导论》第2版，机械工业出版社</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id36" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><a class="reference external" href="http://staff.ustc.edu.cn/~lszhuang/alg/">http://staff.ustc.edu.cn/~lszhuang/alg/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id37" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><a class="reference external" href="http://www.wutianqi.com/">http://www.wutianqi.com/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id38" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td><a class="reference external" href="http://www.cnblogs.com/timebug/">http://www.cnblogs.com/timebug/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id39" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td><a class="reference external" href="http://blog.csdn.net/v_JULY_v/">http://blog.csdn.net/v_JULY_v/</a></td></tr>
</tbody>
</table>
<p>如有参考而未能引用的，深表感谢与歉意！</p>
</div>
</div>


        </div>



        <!-- 来必力City版安装代码 -->
        <div id="lv-container" data-id="city" data-uid="MTAyMC80MDU4Ni8xNzExMw==">
        <script type="text/javascript">
           (function(d, s) {
               var j, e = d.getElementsByTagName(s)[0];

               if (typeof LivereTower === 'function') { return; }

               j = d.createElement(s);
               j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
               j.async = true;

               e.parentNode.insertBefore(j, e);
           })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
        </div>
        <!-- City版安装代码已完成 -->
      </div>
    </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="../../language/cpp/cpp_micro.html" title="C++ 宏编程 学习笔记"
             >下一页</a> |</li>
        <li class="right" >
          <a href="../os.html" title="操作系统概论"
             >上一页</a> |</li>
        <!--<li><a href="../../index.html">首页</a>&#160;|</li>-->
        <!--<li><a href="../../contents.html">Documentation</a> &#187;</li>-->
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 CC BY 2.5.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.1 创建。
    </div>
  </body>
</html>