
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh_CN">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Python高级编程 &#8212; Chuanqi 的技术文档</title>
    <link rel="stylesheet" href="../../_static/sphinx13.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/translations.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="Python 学习笔记" href="py_notes.html" />
    <link rel="prev" title="Dive Into Python 学习笔记" href="dive_into_python.html" />
    <link rel="canonical" href="http://www.sphinx-doc.org/en/master/language/python/expert_python.html" />

    <!--<link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,700'-->
          <!--rel='stylesheet' type='text/css' />-->
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
      .injected { display:none; }
    </style>
    <script type="text/javascript">
      // intelligent scrolling of the sidebar content
      $(window).scroll(function() {
        var sb = $('.sphinxsidebarwrapper');
        var win = $(window);
        var sbh = sb.height();
        var offset = $('.sphinxsidebar').position()['top'];
        var wintop = win.scrollTop();
        var winbot = wintop + win.innerHeight();
        var curtop = sb.position()['top'];
        var curbot = curtop + sbh;
        // does sidebar fit in window?
        if (sbh < win.innerHeight()) {
          // yes: easy case -- always keep at the top
          sb.css('top', $u.min([$u.max([0, wintop - offset - 10]),
                                $(document).height() - sbh - 200]));
        } else {
          // no: only scroll if top/bottom edge of sidebar is at
          // top/bottom edge of window
          if (curtop > wintop && curbot > winbot) {
            sb.css('top', $u.max([wintop - offset - 10, 0]));
          } else if (curtop < wintop && curbot < winbot) {
            sb.css('top', $u.min([winbot - sbh - offset - 20,
                                  $(document).height() - sbh - 200]));
          }
        }
      });
    </script>

  </head><body>
<div class="pageheader">
  <ul>
    <li><a href="../../index.html">笔记首页</a></li>
    <li><a href="http://blog.tanchuanqi.com">博客首页</a></li>
    <li><a href="https://tanchuanqi.com">个人主页</a></li>
  </ul>
  <div>
    <a href="../../index.html">
      <img src="../../_static/sphinxheader.png" alt="SPHINX" />
    </a>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="py_notes.html" title="Python 学习笔记"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="dive_into_python.html" title="Dive Into Python 学习笔记"
             accesskey="P">上一页</a> |</li>
        <!--<li><a href="../../index.html">首页</a>&#160;|</li>-->
        <!--<li><a href="../../contents.html">Documentation</a> &#187;</li>-->
 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Python高级编程</a><ul>
<li><a class="reference internal" href="#id1">第一章：准备工作</a></li>
<li><a class="reference internal" href="#id2">第二章：语法最佳实现-低于类级</a></li>
<li><a class="reference internal" href="#id3">第三章：语法最佳实现-类级</a></li>
<li><a class="reference internal" href="#id4">第四章：选择好的名称</a></li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="dive_into_python.html"
                        title="上一章">Dive Into Python 学习笔记</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="py_notes.html"
                        title="下一章">Python 学习笔记</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="转向" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
    <div class="documentwrapper">
      <div class="bodywrapper">
        <div class="body" role="main">
          
  <div class="section" id="python">
<h1>Python高级编程<a class="headerlink" href="#python" title="永久链接至标题">¶</a></h1>
<div class="section" id="id1">
<h2>第一章：准备工作<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<ul>
<li><div class="first line-block">
<div class="line">Python的交互式命令行工具会在启动时查找环境变量PYTHONSTARTUP，并执行该变量中所指定的文件里的程序代码。</div>
<div class="line">如一般的添加自动补全的功能readline.parse_and_bind(‘tab: complete’)。</div>
</div>
</li>
<li><p class="first">iPython是一个增强型的命令行工具。</p>
</li>
<li><p class="first">Python中的setuptools相当于Debian中的apt，easy_install就是调用setuptools的工具。</p>
</li>
</ul>
</div>
<div class="section" id="id2">
<h2>第二章：语法最佳实现-低于类级<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<ul>
<li><p class="first">每当要对序列中的内容进行循环处理时，就应该尝试用 <strong>列表推导式</strong></p>
</li>
<li><p class="first"><strong>迭代器</strong> 和 <strong>生成器</strong> ,现代语言很多都有生成器，使用关键字 <strong>yield</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot; 迭代器的约定在于：</span>
<span class="sd">        next()方法返回下一个元素</span>
<span class="sd">        迭代完成后抛出StopIteration异常</span>
<span class="sd">        __iter__()方式返回迭代器本身</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="k">class</span> <span class="nc">MyIterator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="k">return</span> <span class="ne">StopIteration</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">i</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

<span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">MyIterator</span><span class="p">()]</span>

<span class="sd">&quot;&quot;&quot;生成器返回一个特殊的对象：generator对象,它知道如何保存正在执行的环境。</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">yield</span> <span class="n">i</span>

<span class="n">my_iter</span> <span class="o">=</span> <span class="n">f</span><span class="p">()</span>
<span class="p">[</span><span class="n">my_iter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
<dl class="docutils">
<dt>生成器的工作原理是：</dt>
<dd><p class="first last">每次遇到yield时，就相当于函数返回值似的返回这个值并保存当前的运行状态；当对应的迭代器再次被调用next()时，就恢复保存的状态并继续运行。</p>
</dd>
</dl>
<p>一次返回一个元素，在很多时候可以提高整体性能，不必像传统迭代方式那样一次完成所有的计算。</p>
</li>
<li><dl class="first docutils">
<dt><strong>输入式生成器</strong></dt>
<dd><p class="first">使用 <strong>(yield)</strong> 来转换为输入式生成器，等待 <strong>send()方法</strong> 传递参数再继续执行:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
<span class="gp">... </span>  <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="k">yield</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span> <span class="n">i</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="n">f</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>
<span class="go">45</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="mi">445</span><span class="p">)</span>
<span class="go">445</span>
</pre></div>
</div>
</dd>
</dl>
<div class="line-block">
<div class="line">send(123)方法相当于将(yield)赋值为123再调用next()继续。同理还有2个姐妹方法 <strong>throw()</strong> , <strong>close()</strong> 。</div>
<div class="line">throw()相当于抛出一个异常再调用next()继续，而close()相当于抛出GeneratorExit异常再调用next()继续。</div>
</div>
<p>GeneratorExit异常在生成器中无法捕获，因为编译器需要用它来确定调用close()时是否正常退出。所以如果代码与这个异常关联，那么解释程序将抛出一个系统错误并退出。</p>
</li>
<li><dl class="first docutils">
<dt><strong>生成器表达式</strong> ：类型于列表推导式，用圆括号代替中括号。</dt>
<dd><p class="first last">它和列表解析的语法很像，但是在大数据量处理时，生成器表达式的优势就体现出来了，因为它的内存使用方式更好，效率更高， <strong>它并不创建一个列表，只是返回一个生成器</strong> 。</p>
</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">&lt;generator object &lt;genexpr&gt; at 0x011DC5D0&gt;</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>装饰器</strong> : 它是函数和方法的封装（接收一个函数并返回增强版本的新函数）:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">mydec</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_mydec2</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__mydec3</span><span class="p">(</span><span class="o">*</span><span class="n">argv</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
            <span class="nb">print</span> <span class="s2">&quot;Begin&quot;</span><span class="p">,</span> <span class="n">i</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">argv</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
            <span class="nb">print</span> <span class="s2">&quot;End&quot;</span>
            <span class="k">return</span> <span class="n">res</span>
        <span class="k">return</span> <span class="n">__mydec3</span>
    <span class="k">return</span> <span class="n">_mydec2</span>

<span class="nd">@mydec</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">MyF1</span><span class="p">():</span>
    <span class="nb">print</span> <span class="s2">&quot;MyF1() body...&quot;</span>

<span class="nd">@mydec</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">MyF2</span><span class="p">():</span>
    <span class="nb">print</span> <span class="s2">&quot;MyF2() body...&quot;</span>

<span class="n">MyF1</span><span class="p">()</span>
<span class="n">MyF2</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Begin</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MyF1</span><span class="p">()</span> <span class="n">body</span><span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">End</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Begin</span> <span class="mi">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">MyF2</span><span class="p">()</span> <span class="n">body</span><span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">End</span>
</pre></div>
</div>
<p>装饰器应该关注于所封装的函数或方法接收和返回的参数，如果需要，应该尽可能限制其内省工作。</p>
</li>
<li><p class="first">with语法，解决资源释放问题的新语法，相当于 <code class="docutils literal notranslate"><span class="pre">try...expect...finally...</span></code> 的简写形式:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Context</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s2">&quot;Enter ...&quot;</span>
    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exception_type</span><span class="p">,</span> <span class="n">exception_value</span><span class="p">,</span> <span class="n">exception_traceback</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s2">&quot;Leaving ...&quot;</span>

<span class="k">with</span> <span class="n">Context</span><span class="p">():</span>
    <span class="nb">print</span> <span class="s2">&quot;I am in zone...&quot;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Enter</span> <span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">I</span> <span class="n">am</span> <span class="ow">in</span> <span class="n">zone</span><span class="o">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Leaving</span> <span class="o">...</span>
</pre></div>
</div>
<p>能够使用with语句来处理的类就是满足with协议的类，即实现了 <code class="docutils literal notranslate"><span class="pre">__enter__</span></code> , <code class="docutils literal notranslate"><span class="pre">__exit__</span></code> 两个方法。</p>
</li>
</ul>
</div>
<div class="section" id="id3">
<h2>第三章：语法最佳实现-类级<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<ul>
<li><p class="first">最佳实践</p>
<ul class="simple">
<li>避免使用多重继承</li>
<li>super的使用必须一致，大家都倾向于不使用super，我也认为传统的根据类名来调用比较好，super带来的坏处大于好处</li>
<li>不要混用老式的和新式的类，因为它们的MRO（方法解析顺序）不同</li>
<li>调用父类时，为了避免出现问题，快速的使用__mro__检查一下类层次</li>
</ul>
</li>
<li><p class="first">在Python中，类的私有属性是用前导_来实现命名改编的</p>
</li>
<li><p class="first"><strong>描述符</strong> 定义在引用一个对象的特征时所应该完成的事情，其实非常简单易解，就是实现了三个特殊的方法的类。
__get__在特性被读取时调用；__set__在特性被赋值时调用；__del__在特征被del时调用。
示例代码如下:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">UpperString</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">klass</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">my_attr</span> <span class="o">=</span> <span class="n">UpperString</span><span class="p">()</span>

<span class="n">a_instance</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
<span class="n">a_instance</span><span class="o">.</span><span class="n">my_attr</span> <span class="o">=</span> <span class="s2">&quot;tanchuanqi&quot;</span>
<span class="nb">print</span> <span class="n">a_instance</span><span class="o">.</span><span class="n">my_attr</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">TANCHUANQI</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>属性</strong> 把几个方法合并成一个属性，很好理解，也都是语法糖:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="nf">_v_get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">v</span>
    <span class="k">def</span> <span class="nf">_v_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">def</span> <span class="nf">_v_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span> <span class="s2">&quot;del self.v&quot;</span>

    <span class="n">my_property</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_v_get</span><span class="p">,</span> <span class="n">_v_set</span><span class="p">,</span> <span class="n">_v_delete</span><span class="p">,</span> <span class="s2">&quot;This is doc string&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>属性有一点不直观的就是：property()只会绑定当前类中的方法，绝不会绑定派生类中的方法，无论派生类是否重载了相关的函数:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">FirstClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_get_v</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;FirstClass&quot;</span>
    <span class="n">value</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_v</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">SecondClass</span><span class="p">(</span><span class="n">FirstClass</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_get_v</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;SecondClass&quot;</span>
    <span class="c1">#value = property(_get_v)         重新定义一次value property是解决办法</span>

<span class="n">SecondClass</span><span class="p">()</span><span class="o">.</span><span class="n">value</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="s1">&#39;FirstClass&#39;</span>
</pre></div>
</div>
<p>这不合逻辑，所以不要在派生类中重载被关联为property的方法。解决这个问题的办法是再SecondClass中再重新定义一次value property。</p>
</li>
<li><p class="first"><strong>槽</strong> 极少使用，它允许使用__solts__特性来为指定的类设置一个静态列表，并且跳过每个类实例中__dict__列表的创建工作。</p>
</li>
<li><p class="first"><strong>__new__方法</strong> 它是特殊的元构造程序，与__init__不同的地方在于它一定会被调用，子类初始化时也会调用父类的__new__方法。
所以，很多初始化的工作都应该放在__new__方法中处理。</p>
</li>
<li><p class="first"><strong>type 动态生成类型</strong> 内建类型type是内建的基本工厂:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span>

<span class="n">klass</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;MyClass&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nb">object</span><span class="p">,),</span> <span class="p">{</span><span class="s1">&#39;method&#39;</span><span class="p">:</span><span class="n">method</span><span class="p">})</span>
<span class="n">instance</span> <span class="o">=</span> <span class="n">klass</span><span class="p">()</span>
<span class="nb">print</span> <span class="n">instance</span><span class="o">.</span><span class="n">method</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span>
</pre></div>
</div>
</li>
<li><p class="first"><strong>__metaclass__方法</strong> 设置类级别的在类型创建时的操作:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">equip</span><span class="p">(</span><span class="n">classname</span><span class="p">,</span> <span class="n">base_types</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">MyClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">equip</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>任何情况下都要记得，__metaclass__和其它的动态处理类的方法都要谨慎使用，很容易使类的结构变的一团糟！</p>
</li>
</ul>
</div>
<div class="section" id="id4">
<h2>第四章：选择好的名称<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<ul>
<li><p class="first">命名风格：</p>
<ul class="simple">
<li>常量：使用大写+下划线的形式(常量最好统一放在包中的一个独立文件，像Django的config.py)</li>
<li>变量：使用小写+下划线的形式</li>
<li>函数和方法：也应该使用小写+下划线的风格</li>
<li>属性：也是小写+下划线的形式</li>
<li>特殊的方法(__str__,__item__,__repr__, …)应该被放在类定义的最前面</li>
<li>类名：应该总是使用CamelCase的命名风格，当定义模块的私有类时，使用前导下划线</li>
<li>模块和包：除__init__外，模块名称都应该使用 <strong>不带下划线的</strong> 小写字母命名</li>
</ul>
</li>
<li><p class="first">私有元素用一个前导下划线标记_private，私有的变量、方法、类名、模块或包都应该用前导下划线标示为私有。</p>
<dl class="docutils">
<dt>私有元素的争论：</dt>
<dd><p class="first">一个前导下划线是约定为私有元素，而2个前导下划线则会强制进行命名改编(name mailing) 。所以很多人使用2个前导下划线来标识私有元素。
这其实是不合适的，因为 <strong>python中的name mailing的动机不是为了提供私有机制，而是为了确保基类隐式地避免子类中的冲突</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
<span class="gp">... </span>  <span class="k">def</span> <span class="nf">_abc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">[&#39;__doc__&#39;, &#39;__module__&#39;, &#39;_abc&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">B</span><span class="p">:</span>
<span class="gp">... </span>  <span class="k">def</span> <span class="nf">__abc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">pass</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">dir</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="go">[&#39;_B__abc&#39;, &#39;__doc__&#39;, &#39;__module__&#39;]</span>
</pre></div>
</div>
<p class="last">所以，正确的方法是使用1个前导下划线，而不是用2个来画蛇添足，因为2个前导下划线也同样保证不了私有机制。</p>
</dd>
</dl>
</li>
<li><p class="first">参数设计的3原则：</p>
<ul class="simple">
<li>根据设计来构建参数，即必须站在用户的角度来进行参数的设计。</li>
<li><dl class="first docutils">
<dt>在任何情况下，断言assert都必须小心的进行，并且不应该导致Python变成一种静态类型的语言。</dt>
<dd>唯一的使用场景就是保护代码不被无意义的调用。</dd>
</dl>
</li>
<li>小心使用*args和**kw魔法参数，如果你觉得现在必须使用魔法参数，那么一般意味着这个方法需要被分解或重构！</li>
<li>类及它的特性之间应当避免冗余，如SMTP.smtp_send()就是冗余，正确的命名应该是SMTP.send()</li>
</ul>
</li>
<li><p class="first">设计API的原则：</p>
<ul class="simple">
<li>避免冗长，形成高级接口和低级接口的组合</li>
<li>构建命名空间树</li>
<li>分解代码：一个函数不应该超过一个屏幕；类的方法一般不超过10个；一个模块一般不超过500行；</li>
<li>使用Egg：为了避免整个代码库都在一个目录下，并能够单独发布每个包，就可以使用Egg。它提供了构建”命名空间的包”的简单方法，就像Java中的JAR一样。</li>
<li>使用deprecation过程（及warning模块）</li>
</ul>
</li>
</ul>
</div>
</div>


        </div>



        <!-- 来必力City版安装代码 -->
        <div id="lv-container" data-id="city" data-uid="MTAyMC80MDU4Ni8xNzExMw==">
        <script type="text/javascript">
           (function(d, s) {
               var j, e = d.getElementsByTagName(s)[0];

               if (typeof LivereTower === 'function') { return; }

               j = d.createElement(s);
               j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
               j.async = true;

               e.parentNode.insertBefore(j, e);
           })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
        </div>
        <!-- City版安装代码已完成 -->
      </div>
    </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="py_notes.html" title="Python 学习笔记"
             >下一页</a> |</li>
        <li class="right" >
          <a href="dive_into_python.html" title="Dive Into Python 学习笔记"
             >上一页</a> |</li>
        <!--<li><a href="../../index.html">首页</a>&#160;|</li>-->
        <!--<li><a href="../../contents.html">Documentation</a> &#187;</li>-->
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; 版权所有 CC BY 2.5.
      由 <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.1 创建。
    </div>
  </body>
</html>